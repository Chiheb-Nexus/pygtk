/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include <pygobject.h>
#include <pango/pango.h>

%%
modulename pango
%%
import gobject.GObject as PyGObject_Type
%%
ignore-glob *_get_type
%%
ignore
  pango_color_copy
  pango_color_free
  pango_attribute_copy
  pango_attribute_destroy
  pango_attribute_equal
  pango_attr_list_ref
  pango_attr_list_unref
  pango_coverage_ref
  pango_coverage_unref
  pango_font_description_equal
  pango_font_description_free
  pango_font_descriptions_free
  pango_font_map_free_families
  pango_font_metrics_ref
  pango_font_metrics_unref
  pango_font_get_coverage
  pango_font_find_shaper
  pango_glyph_string_free
  pango_layout_get_log_attrs
  pango_tab_array_free
%%
ignore
  pango_context_new
  pango_context_set_font_map
  pango_glyph_string_index_to_x
  pango_glyph_string_x_to_index
  pango_break
  pango_shape
%%
ignore pango_font_description_from_string
%%
override pango_font_description_new kwargs
static int
_wrap_pango_font_description_new(PyGBoxed *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "str", NULL };
    char *str = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|z:PangoFontDescription.__init__",
				     kwlist, &str))
	return -1;

    self->gtype = PANGO_TYPE_FONT_DESCRIPTION;
    self->free_on_dealloc = FALSE;
    if (str)
	self->boxed = pango_font_description_from_string(str);
    else
	self->boxed = pango_font_description_new();
    if (!self->boxed) {
	PyErr_SetString(PyExc_RuntimeError,
			"could not create PangoFontDescription object");
	return -1;
    }
    self->free_on_dealloc = TRUE;
    return 0;
}
%%
override-slot PangoFontDescription.tp_compare
static int
_wrap_pango_font_description_tp_compare(PyGBoxed *self, PyGBoxed *other)
{
    if (self->boxed == other->boxed ||
	pango_font_description_equal(pyg_boxed_get(self, PangoFontDescription),
				pyg_boxed_get(other, PangoFontDescription)))
	return 0;
    if (self->boxed > other->boxed)
	return -1;
    return 1;
}
%%
override-slot PangoFontDescription.tp_hash
static long
_wrap_pango_font_description_tp_hash(PyGBoxed *self)
{
    return (long)pango_font_description_hash(
		pyg_boxed_get(self, PangoFontDescription));
}
%%
override pango_font_description_copy noargs
static PyObject *
_wrap_pango_font_description_copy(PyObject *self)
{
    return pyg_boxed_new(PANGO_TYPE_FONT_DESCRIPTION,
			 pyg_boxed_get(self, PangoFontDescription),
			 TRUE, TRUE);
}
%%
override pango_context_list_families noargs
static PyObject *
_wrap_pango_context_list_families(PyGObject *self)
{
    PangoFontFamily **families;
    gint n_families, i;
    PyObject *ret;

    pango_context_list_families(PANGO_CONTEXT(self->obj), &families,
				&n_families);
    ret = PyTuple_New(n_families);
    for (i = 0; i < n_families; i++) {
	PyObject *family;

	family = pygobject_new((GObject *)families[i]);
	PyTuple_SetItem(ret, i, family);
    }
    g_free(families);
    return ret;
}
%%
override pango_font_get_glyph_extents kwargs
static PyObject *
_wrap_pango_font_get_glyph_extents(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "glyph", NULL };
    gint glyph;
    PangoRectangle ink_rect, logical_rect;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "i:PangoFont.get_glyph_extents", kwlist,
				     &glyph))
	return NULL;
    pango_font_get_glyph_extents(PANGO_FONT(self->obj), (PangoGlyph)glyph,
				 &ink_rect, &logical_rect);
    return Py_BuildValue("((iiii)(iiii))",
			 ink_rect.x, ink_rect.y,
			 ink_rect.width, ink_rect.height,
			 logical_rect.x, logical_rect.y,
			 logical_rect.width, logical_rect.height);
}
%%
override pango_font_family_list_faces noargs
static PyObject *
_wrap_pango_font_family_list_faces(PyGObject *self)
{
    PangoFontFace **faces;
    gint n_faces, i;
    PyObject *ret;

    pango_font_family_list_faces(PANGO_FONT_FAMILY(self->obj),
				 &faces, &n_faces);
    ret = PyTuple_New(n_faces);
    for (i = 0; i < n_faces; i++) {
	PyObject *face;

	face = pygobject_new((GObject *)faces[i]);
	PyTuple_SetItem(ret, i, face);
    }
    g_free(faces);
    return ret;
}
%%
override pango_font_map_list_families noargs
static PyObject *
_wrap_pango_font_map_list_families(PyGObject *self)
{
    PangoFontFamily **families;
    gint n_families, i;
    PyObject *ret;

    pango_font_map_list_families(PANGO_FONT_MAP(self->obj), &families,
				 &n_families);
    ret = PyTuple_New(n_families);
    for (i = 0; i < n_families; i++) {
	PyObject *family;

	family = pygobject_new((GObject *)families[i]);
	PyTuple_SetItem(ret, i, family);
    }
    g_free(families);
    return ret;
}
%%
override pango_glyph_string_extents kwargs
static PyObject *
_wrap_pango_glyph_string_extents(PyObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "font", NULL };
    PyObject *font;
    PangoRectangle ink_rect, logical_rect;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:PangoGlyphString.extents", kwlist,
				     &font))
	return NULL;
    if (!pygobject_check(font, &PyPangoFont_Type)) {
	PyErr_SetString(PyExc_TypeError, "font must be a PangoFont");
	return NULL;
    }

    pango_glyph_string_extents(pyg_boxed_get(self, PangoGlyphString),
			       PANGO_FONT(pygobject_get(font)),
			       &ink_rect, &logical_rect);

    return Py_BuildValue("((iiii)(iiii))",
			 ink_rect.x, ink_rect.y,
			 ink_rect.width, ink_rect.height,
			 logical_rect.x, logical_rect.y,
			 logical_rect.width, logical_rect.height);
}
%%
override pango_glyph_string_extents_range kwargs
static PyObject *
_wrap_pango_glyph_string_extents_range(PyObject *self, PyObject *args,
				       PyObject *kwargs)
{
    static char *kwlist[] = { "start", "end", "font", NULL };
    gint start, end;
    PyObject *font;
    PangoRectangle ink_rect, logical_rect;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "iiO:PangoGlyphString.extents_range",
				     kwlist, &start, &end, &font))
	return NULL;
    if (!pygobject_check(font, &PyPangoFont_Type)) {
	PyErr_SetString(PyExc_TypeError, "font must be a PangoFont");
	return NULL;
    }

    pango_glyph_string_extents_range(pyg_boxed_get(self, PangoGlyphString),
				     start, end,
				     PANGO_FONT(pygobject_get(font)),
				     &ink_rect, &logical_rect);

    return Py_BuildValue("((iiii)(iiii))",
			 ink_rect.x, ink_rect.y,
			 ink_rect.width, ink_rect.height,
			 logical_rect.x, logical_rect.y,
			 logical_rect.width, logical_rect.height);
}
%%
override pango_glyph_string_get_logical_widths kwargs
static PyObject *
_wrap_pango_glyph_string_get_logical_widths(PyObject *self, PyObject *args,
					    PyObject *kwargs)
{
    static char *kwlist[] = { "text", "embedding_level", NULL };
    const char *text;
    gint length, embedding_level, *logical_widths;
    gint i, slen;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s#i:PangoGlyphString.get_logical_widths",
				     kwlist, &text, &length, &embedding_level))
	return NULL;
    slen = g_utf8_strlen(text, length);
    logical_widths = g_new(int, slen);
    pango_glyph_string_get_logical_widths(pyg_boxed_get(self,PangoGlyphString),
					  text, length, embedding_level,
					  logical_widths);
    ret = PyTuple_New(slen);
    for (i = 0; i < slen; i++) {
	PyObject *item = PyInt_FromLong(logical_widths[i]);

	PyTuple_SetItem(ret, i, item);
    }
    g_free(logical_widths);
    return ret;
}
%%
override pango_layout_set_markup kwargs
static PyObject *
_wrap_pango_layout_set_markup(PyGObject *self, PyObject *args,PyObject *kwargs)
{
    static char *kwlist[] = { "markup", NULL };
    char *markup;
    gint length;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s#:PangoLayout.set_markup",
				     kwlist, &markup, &length))
	return NULL;

    pango_layout_set_markup(PANGO_LAYOUT(self->obj), markup, length);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override pango_layout_set_markup_with_accel kwargs
static PyObject *
_wrap_pango_layout_set_markup_with_accel(PyGObject *self, PyObject *args,
					 PyObject *kwargs)
{
    static char *kwlist[] = { "markup", "accel_marker", NULL };
    char *markup;
    gint length, accel_length;
    Py_UNICODE *accel_marker, pychr;
    gunichar accel_char;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s#u#:PangoLayout.set_markup_with_accel",
				     kwlist, &markup, &length,
				     &accel_marker, &accel_length))
	return NULL;
    if (accel_length != 1) {
	PyErr_SetString(PyExc_TypeError, "accel_marker must be a unicode string of length 1");
	return NULL;
    }
    pango_layout_set_markup_with_accel(PANGO_LAYOUT(self->obj), markup, length,
				       (gunichar)accel_marker[0], &accel_char);

#if !defined(Py_UNICODE_SIZE) || Py_UNICODE_SIZE == 2
    if (accel_char >= 0xffff) {
	PyErr_SetString(PyExc_ValueError, "unicode character is too big to fit in a 16-bit unicode character");
	return NULL;
    }
#endif
    pychr = (Py_UNICODE)accel_char;
    return PyUnicode_FromUnicode(&pychr, 1);
}
%%
override pango_layout_index_to_pos kwargs
static PyObject *
_wrap_pango_layout_index_to_pos(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "index", NULL };
    gint index;
    PangoRectangle pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "i:PangoLayout.index_to_pos", kwlist,
				     &index))
	return NULL;

    pango_layout_index_to_pos(PANGO_LAYOUT(self->obj), index, &pos);
    return Py_BuildValue("(iiii)", pos.x, pos.y, pos.width, pos.height);
}
%%
override pango_layout_get_cursor_pos kwargs
static PyObject *
_wrap_pango_layout_get_cursor_pos(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "index", NULL };
    gint index;
    PangoRectangle strong_pos, weak_pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "i:PangoLayout.get_cursor_pos", kwlist,
				     &index))
	return NULL;

    pango_layout_get_cursor_pos(PANGO_LAYOUT(self->obj), index,
				&strong_pos, &weak_pos);
    return Py_BuildValue("((iiii)(iiii))",
			 strong_pos.x, strong_pos.y,
			 strong_pos.width, strong_pos.height,
			 weak_pos.x, weak_pos.y,
			 weak_pos.width, weak_pos.height);
}
%%
override pango_layout_move_cursor_visually kwargs
static PyObject *
_wrap_pango_layout_move_cursor_visually(PyGObject *self, PyObject *args,
					PyObject *kwargs)
{
    static char *kwlist[] = { "strong", "old_index", "old_trailing", "direction", NULL };
    gboolean strong;
    gint old_index, old_trailing, direction, new_index = 0, new_trailing = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "iiii:PangoLayout.move_cursor_visually",
				     kwlist, &strong, &old_index,
				     &old_trailing, &direction))
	return NULL;

    pango_layout_move_cursor_visually(PANGO_LAYOUT(self->obj), strong,
				      old_index, old_trailing, direction,
				      &new_index, &new_trailing);
    return Py_BuildValue("(ii)", new_index, new_trailing);
}
%%
override pango_layout_xy_to_index kwargs
static PyObject *
_wrap_pango_layout_xy_to_index(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    gint x, y, index, trailing;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "ii:PangoLayout.xy_to_index", kwlist,
				     &x, &y))
	return NULL;

    pango_layout_xy_to_index(PANGO_LAYOUT(self->obj), x, y, &index, &trailing);

    return Py_BuildValue("(ii)", index, trailing);
}
%%
override pango_layout_get_extents noargs
static PyObject *
_wrap_pango_layout_get_extents(PyGObject *self)
{
    PangoRectangle ink_rect, logical_rect;

    pango_layout_get_extents(PANGO_LAYOUT(self->obj),
			     &ink_rect, &logical_rect);

    return Py_BuildValue("((iiii)(iiii))",
			 ink_rect.x, ink_rect.y,
			 ink_rect.width, ink_rect.height,
			 logical_rect.x, logical_rect.y,
			 logical_rect.width, logical_rect.height);
}
%%
override pango_layout_get_pixel_extents noargs
static PyObject *
_wrap_pango_layout_get_pixel_extents(PyGObject *self)
{
    PangoRectangle ink_rect, logical_rect;

    pango_layout_get_extents(PANGO_LAYOUT(self->obj),
			     &ink_rect, &logical_rect);

    return Py_BuildValue("((iiii)(iiii))",
			 ink_rect.x, ink_rect.y,
			 ink_rect.width, ink_rect.height,
			 logical_rect.x, logical_rect.y,
			 logical_rect.width, logical_rect.height);
}
%%
override pango_layout_get_size noargs
static PyObject *
_wrap_pango_layout_get_size(PyGObject *self)
{
    gint width, height;

    pango_layout_get_size(PANGO_LAYOUT(self->obj), &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
%%
override pango_layout_get_pixel_size noargs
static PyObject *
_wrap_pango_layout_get_pixel_size(PyGObject *self)
{
    gint width, height;

    pango_layout_get_pixel_size(PANGO_LAYOUT(self->obj), &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
%%
override pango_parse_markup kwargs
static PyObject *
_wrap_pango_parse_markup(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "markup_text", "accel_marker", NULL };
    char *markup_text, *text = NULL;
    gint length;
    Py_UNICODE *py_accel_marker, py_accel_char;
    gint py_accel_marker_len;
    gunichar accel_marker, accel_char = 0;
    PangoAttrList *attr_list = NULL;
    GError *error = NULL;
    gboolean ret;
    PyObject *py_ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s#u#:pango.parse_markup",
				     kwlist, &markup_text, &length,
				     &py_accel_marker, &py_accel_marker_len))
	return NULL;
    if (py_accel_marker_len != 1) {
	PyErr_SetString(PyExc_TypeError, "accel_mark must be one character");
	return NULL;
    }
    accel_marker = py_accel_marker[0];
    ret = pango_parse_markup(markup_text, length, accel_marker,
			     &attr_list, &text, &accel_char, &error);
    if (pyg_error_check(&error))
	return NULL;

#if !defined(Py_UNICODE_SIZE) || Py_UNICODE_SIZE == 2
    if (accel_char >= 0xffff) {
	PyErr_SetString(PyExc_ValueError, "unicode character is too big to fit in a 16-bit unicode character");
	return NULL;
    }
#endif
    py_accel_char = (Py_UNICODE)accel_char;

    py_ret = Py_BuildValue("(Nsu#)", pyg_boxed_new(PANGO_TYPE_ATTR_LIST,
						   attr_list, FALSE, TRUE),
			   text, &py_accel_char, 1);
    g_free(text);
    return py_ret;
}
%%
override pango_tab_array_get_tab kwargs
static PyObject *
_wrap_pango_tab_array_get_tab(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tab_index", NULL };
    gint tab_index, location;
    PangoTabAlign alignment;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:PangoTabArray.get_tab",
				     kwlist, &tab_index))
	return NULL;

    pango_tab_array_get_tab(pyg_boxed_get(self, PangoTabArray),
			    tab_index, &alignment, &location);
    return Py_BuildValue("(ii)", (int)alignment, location);
}
%%
override pango_tab_array_get_tabs noargs
static PyObject *
_wrap_pango_tab_array_get_tabs(PyObject *self)
{
    PangoTabAlign *alignments;
    gint *locations, length, i;
    PyObject *ret;

    length = pango_tab_array_get_size(pyg_boxed_get(self, PangoTabArray));
    pango_tab_array_get_tabs(pyg_boxed_get(self, PangoTabArray),
			     &alignments, &locations);
    ret = PyTuple_New(length);
    for (i = 0; i < length; i++) {
	PyObject *item;

	item = Py_BuildValue("(ii)", (int)alignments[i], locations[i]);
	PyTuple_SetItem(ret, i, item);
    }
    return ret;
}
