/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
ignore-glob
  *_get_type
  gtk_marshal_*
  gtk_arg_*
  gtk_args_*
  gtk_signal_connect*
  gtk_signal_add_emission_hook*
  gtk_signal_new*
  gtk_signal_emit*
  gtk_draw_*
  gtk_paint_*
  gtk_init_add_*
  gtk_quit_add_*
  gtk_timeout_add_*
  gtk_idle_add_*
  gtk_accelerator_*
  gtk_accel_group_*
  gtk_accel_groups_*
  gtk_target_list_*
%%
ignore
  gtk_init
  gtk_init_check
  gtk_exit
  gtk_set_locale
  gtk_signal_set_funcs
  gtk_signal_lookup
  gtk_signal_disconnect_by_func
  gtk_signal_disconnect_by_data
  gtk_signal_handler_block_by_func
  gtk_signal_handler_block_by_data
  gtk_signal_handler_unblock_by_func
  gtk_signal_handler_unblock_by_data
  gtk_signal_handler_pending_by_func
  gtk_signal_query
  gtk_quit_remove_by_data
  gtk_idle_remove_by_data
  gtk_object_weakref
  gtk_object_weakunref
  gtk_object_get
  gtk_object_getv
  gtk_object_set
  gtk_object_setv
  gtk_object_set_data
  gtk_object_set_data_full
  gtk_object_get_data
  gtk_object_set_user_data
  gtk_object_get_user_data
  gtk_object_set_data_by_id
  gtk_object_set_data_by_id_full
  gtk_object_get_data_by_id
  gtk_object_remove_data_by_id
  gtk_object_remove_no_notify_by_id
  gtk_object_arg_set
  gtk_object_arg_get
  gtk_widget_get
  gtk_widget_getv
  gtk_widget_set
  gtk_widget_setv
  gtk_container_get_toplevels
  gtk_container_add_child_arg_type
  gtk_container_query_child_args
  gtk_container_child_args_collect
  gtk_container_child_arg_get_info
  gtk_container_foreach
  gtk_container_foreach_full
  gtk_container_forall
  gtk_container_child_getv
  gtk_container_child_setv
  gtk_container_add_with_args
  gtk_container_addv
  gtk_container_child_set
  gtk_container_arg_set
  gtk_container_arg_get
  gtk_progress_bar_new
  gtk_clist_set_row_data_full
  gtk_window_add_embedded_xid
  gtk_window_remove_embedded_xid
  gtk_range_trough_click
  gtk_range_default_htrough_click
  gtk_range_default_vtrough_click
  gtk_tooltips_data_get
  gtk_type_check_object_cast
  gtk_type_check_class_cast
  gtk_type_register_enum
  gtk_type_register_flags
%%
ignore gtk_object_new gtk_object_newv gtk_object_query_args
  gtk_object_add_arg_type gtk_object_args_collect gtk_object_arg_get_info
  gtk_widget_new gtk_widget_newv
%%
ignore gtk_true gtk_false gtk_key_snooper_install gtk_key_snooper_remove
  gtk_get_current_event gtk_get_event_widget gtk_propagate_event
%%
override gtk_main
static PyObject *
_wrap_gtk_main(PyObject *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, ":main"))
	return NULL;

    pygtk_unblock_threads();
    gtk_main();
    pygtk_block_threads();
    if (PyErr_Occurred())
	return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_main_iteration
static PyObject *
_wrap_gtk_main_iteration(PyObject *self, PyObject *args)
{
    int block = 1, ret;

    if(!PyArg_ParseTuple(args,"|i:main_iteration", &block)) 
        return NULL;
    pygtk_unblock_threads();
    ret = gtk_main_iteration_do(block);
    pygtk_block_threads();
    return PyInt_FromLong(ret);
}
%%
override gtk_timeout_add
static PyObject *
_wrap_gtk_timeout_add(PyObject *self, PyObject *args)
{
    guint32 interval;
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 2) {
	PyErr_SetString(PyExc_TypeError,
			"timeout_add requires at least 2 args");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "iO:timeout_add", &interval, &callback)) {
	Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "second arg not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 2, len);

    if (cbargs == NULL)
      return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_timeout_add_full(interval, NULL,
        (GtkCallbackMarshal)pygtk_handler_marshal,
        data, (GtkDestroyNotify)pygtk_destroy_notify));
}
%%
override gtk_idle_add
static PyObject *
_wrap_gtk_idle_add(PyObject *self, PyObject *args)
{
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 1) {
	PyErr_SetString(PyExc_TypeError,
			"idle_add requires at least 1 arg");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 1);
    if (!PyArg_ParseTuple(first, "O:idle_add", &callback)) {
	Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "first arg not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 1, len);

    if (cbargs == NULL)
      return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_idle_add_full(GTK_PRIORITY_DEFAULT, NULL,
        (GtkCallbackMarshal)pygtk_handler_marshal,
        data, (GtkDestroyNotify)pygtk_destroy_notify));
}
%%
override gtk_quit_add
static PyObject *
_wrap_gtk_quit_add(PyObject *self, PyObject *args)
{
    gint main_level;
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 2) {
	PyErr_SetString(PyExc_TypeError,
			"quit_add requires at least 2 args");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "iO:quit_add", &main_level, &callback)) {
	Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "second arg not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 2, len);

    if (cbargs == NULL)
      return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_quit_add_full(main_level, NULL,
        (GtkCallbackMarshal)pygtk_handler_marshal,
        data, (GtkDestroyNotify)pygtk_destroy_notify));
}
%%
override gtk_input_add_full
static PyObject *
_wrap_gtk_input_add_full(PyObject *self, PyObject *args)
{
    int source;
    GdkInputCondition condition;
    PyObject *callback;

    if (!PyArg_ParseTuple(args, "iiO:input_add", &source, &condition,
                          &callback))
        return NULL;
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "3rd arg not callable.");
        return NULL;
    }
    Py_INCREF(callback);
    return PyInt_FromLong(gtk_input_add_full(source, condition, NULL,
			(GtkCallbackMarshal)pygtk_input_marshal, callback,
			(GtkDestroyNotify)pygtk_destroy_notify));
}
%%
override gtk_widget_draw
static PyObject *
_wrap_gtk_widget_draw(PyGtk_Object *self, PyObject *args)
{
    GdkRectangle rect;

    if (!PyArg_ParseTuple(args,"(hhhh):GtkWidget.draw",
                         &(rect.x), &(rect.y), &(rect.width), &(rect.height)))
        return NULL;
    gtk_widget_draw(GTK_WIDGET(self->obj), &rect);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_widget_size_request
static PyObject *
_wrap_gtk_widget_size_request(PyGtk_Object *self, PyObject *args)
{
    GtkRequisition requisition;

    if (!PyArg_ParseTuple(args,":GtkWidget.size_request"))
        return NULL;
    gtk_widget_size_request(GTK_WIDGET(self->obj), &requisition);
    return Py_BuildValue("(ii)", requisition.width, requisition.height);
}
%%
override gtk_widget_size_allocate
static PyObject *
_wrap_gtk_widget_size_allocate(PyGtk_Object *self, PyObject *args) 
{
    GtkAllocation allocation;

    if(!PyArg_ParseTuple(args,"(hhhh):GtkWidget.size_allocate",
                         &(allocation.x), &(allocation.y),
                         &(allocation.width), &(allocation.height)))
        return NULL;
    gtk_widget_size_allocate(GTK_WIDGET(self->obj), &allocation);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_widget_get_child_requisition
static PyObject *
_wrap_gtk_widget_get_child_requisition(PyGtk_Object *self, PyObject *args)
{
    GtkRequisition requisition;

    if (!PyArg_ParseTuple(args,":GtkWidget.get_child_requisition"))
        return NULL;
    gtk_widget_get_child_requisition(GTK_WIDGET(self->obj), &requisition);
    return Py_BuildValue("(ii)", requisition.width, requisition.height);
}
%%
override gtk_widget_intersect
static PyObject *
_wrap_gtk_widget_intersect(PyGtk_Object *self, PyObject *args)
{
    GdkRectangle area;
    GdkRectangle intersect;

    if(!PyArg_ParseTuple(args,"(hhhh):GtkWidget.intersect",
                         &(area.x), &(area.y), &(area.width), &(area.height))) 
        return NULL;
    if (gtk_widget_intersect(GTK_WIDGET(self->obj), &area, &intersect))
        return Py_BuildValue("(iiii)", (int)intersect.x, (int)intersect.y,
                             (int)intersect.width, (int)intersect.height);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gtk_widget_get_pointer
static PyObject *
_wrap_gtk_widget_get_pointer(PyGtk_Object *self, PyObject *args)
{
    int x, y;

    if (!PyArg_ParseTuple(args, ":GtkWidget.get_pointer"))
	return NULL;
    gtk_widget_get_pointer(GTK_WIDGET(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gtk_container_children
static PyObject *
_wrap_gtk_container_children(PyGtk_Object *self, PyObject *args)
{
    GList *list, *tmp;
    PyObject *py_list;
    PyObject *gtk_obj;

    if(!PyArg_ParseTuple(args,":GtkContainer.children"))
        return NULL;
    list = gtk_container_children(GTK_CONTAINER(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
	g_list_free(list);
	return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
	gtk_obj = PyGtk_New(GTK_OBJECT(tmp->data));
	if (gtk_obj == NULL) {
	    g_list_free(list);
	    Py_DECREF(py_list);
	    return NULL;
	}
	PyList_Append(py_list, gtk_obj);
	Py_DECREF(gtk_obj);
    }
    g_list_free(list);
    return py_list;
}
%%
override gtk_box_query_child_packing
static PyObject *
_wrap_gtk_box_query_child_packing(PyGtk_Object *self, PyObject *args)
{
    PyObject *child;
    gboolean expand, fill;
    guint padding;
    GtkPackType pack_type;

    if (!PyArg_ParseTuple(args, "O:GtkBox.query_child_packing", &child))
	return NULL;
    if (!PyGtk_Check(child)) {
	PyErr_SetString(PyExc_TypeError, "first arg should be a GtkWidget");
	return NULL;
    }
    gtk_box_query_child_packing(GTK_BOX(self->obj),
				GTK_WIDGET(PyGtk_Get(child)), &expand, &fill,
				&padding, &pack_type);
    return Py_BuildValue("(iiii)", (int)expand, (int)fill, padding, pack_type);
}
%%
override gtk_button_box_get_child_size_default
static PyObject *
_wrap_gtk_button_box_get_child_size_default(PyObject *self, PyObject *args)
{
    int mw, mh;

    if (!PyArg_ParseTuple(args, ":button_box_get_child_size_default"))
        return NULL;
    gtk_button_box_get_child_size_default(&mw, &mh);
    return Py_BuildValue("(ii)", mw, mh);
}
%%
override gtk_button_box_get_child_ipadding_default
static PyObject *
_wrap_gtk_button_box_get_child_ipadding_default(PyObject *self, PyObject *args)
{
    int ipx, ipy;

    if (!PyArg_ParseTuple(args, ":button_box_get_child_ipadding_default"))
        return NULL;
    gtk_button_box_get_child_ipadding_default(&ipx, &ipy);
    return Py_BuildValue("(ii)", ipx, ipy);
}
%%
override gtk_button_box_get_child_size
static PyObject *
_wrap_gtk_button_box_get_child_size(PyGtk_Object *self, PyObject *args)
{
    int mw, mh;

    if (!PyArg_ParseTuple(args, ":GtkButtonBox.get_child_size"))
        return NULL;
    gtk_button_box_get_child_size(GTK_BUTTON_BOX(self->obj), &mw, &mh);
    return Py_BuildValue("(ii)", mw, mh);
}
%%
override gtk_button_box_get_child_ipadding
static PyObject *
_wrap_gtk_button_box_get_child_ipadding(PyGtk_Object *self, PyObject *args)
{
    int ipx, ipy;

    if (!PyArg_ParseTuple(args, ":GtkButtonBox.get_child_ipadding"))
        return NULL;
    gtk_button_box_get_child_ipadding(GTK_BUTTON_BOX(self->obj), &ipx, &ipy);
    return Py_BuildValue("(ii)", ipx, ipy);
}
%%
ignore gtk_clist_new
%%
override gtk_clist_new_with_titles
static PyObject *
_wrap_gtk_clist_new_with_titles(PyGtk_Object *self, PyObject *args)
{
    int count, i;
    PyObject *py_list = NULL;

    if (!PyArg_ParseTuple(args, "i|O:GtkCList.__init__", &count, &py_list))
	return NULL;
    if (py_list) {
	gchar **list;

	if (!PySequence_Check(py_list)) {
	    PyErr_SetString(PyExc_TypeError,"2nd argument not a sequence");
	    return NULL;
	}
	if (PySequence_Length(py_list) < count) {
	    PyErr_SetString(PyExc_TypeError, "sequence not long enough");
	    return NULL;
	}
	list = g_new(gchar *, count);
	for (i = 0; i < count; i++) {
	    PyObject *item = PySequence_GetItem(py_list, i);

	    Py_DECREF(item); /* PySequence_GetItem INCREF's */
	    if (!PyString_Check(item)) {
		PyErr_SetString(PyExc_TypeError, "sequence item not a string");
		g_free(list);
		return NULL;
	    }
	    list[i] = PyString_AsString(item);
	}
	self->obj = (GtkObject *)gtk_clist_new_with_titles(count, list);
	g_free(list);
    } else
	self->obj = (GtkObject *)gtk_clist_new(count);
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError,"could not create GtkCList object");
	return NULL;
    }
    pygtk_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clist_get_text
static PyObject *
_wrap_gtk_clist_get_text(PyGtk_Object *self, PyObject *args)
{
    int r, c;
    char *text = NULL;

    if (!PyArg_ParseTuple(args, "ii:GtkCList.get_text", &r, &c))
	return NULL;
    if (!gtk_clist_get_text(GTK_CLIST(self->obj), r, c, &text) || text==NULL) {
	PyErr_SetString(PyExc_ValueError, "can't get text value");
	return NULL;
    }
    return PyString_FromString(text);
}
%%
override gtk_clist_get_pixmap
static PyObject *
_wrap_gtk_clist_get_pixmap(PyGtk_Object *self, PyObject *args)
{
    PyObject *pixmap, *mask;
    int r, c;
    GdkPixmap *p;
    GdkBitmap *m;

    if (!PyArg_ParseTuple(args, "ii:GtkCList.get_pixmap", &r, &c))
	return NULL;
    if (!gtk_clist_get_pixmap(GTK_CLIST(self->obj), r, c, &p, &m)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixmap value");
	return NULL;
    }
    if (p)
	pixmap = PyGdkWindow_New(p);
    else {
	Py_INCREF(Py_None);
	pixmap = Py_None;
    }
    if (m)
	mask = PyGdkWindow_New(m);
    else {
	Py_INCREF(Py_None);
	mask = Py_None;
    }
    return Py_BuildValue("(NN)", pixmap, mask);
}
%%
override gtk_clist_get_pixtext
static PyObject *
_wrap_gtk_clist_get_pixtext(PyGtk_Object *self, PyObject *args)
{
    PyObject *pixmap, *mask;
    int r, c;
    guint8 spacing;
    char *text;
    GdkPixmap *p;
    GdkBitmap *m;

    if (!PyArg_ParseTuple(args, "ii:GtkCList.get_pixtext", &r, &c))
	return NULL;
    if (!gtk_clist_get_pixtext(GTK_CLIST(self->obj), r, c,
			       &text, &spacing, &p, &m)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixtext value");
	return NULL;
    }
    if (p)
	pixmap = PyGdkWindow_New(p);
    else {
	Py_INCREF(Py_None);
	pixmap = Py_None;
    }
    if (m)
	mask = PyGdkWindow_New(m);
    else {
	Py_INCREF(Py_None);
	mask = Py_None;
    }
    return Py_BuildValue("(ziNN)", text, (int)spacing, pixmap, mask);
}
%%
override gtk_clist_prepend
static PyObject *
_wrap_gtk_clist_prepend(PyGtk_Object *self, PyObject *args)
{
    int col, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTuple(args, "O:GtkCList.prepend", &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "sequence item not a string");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_prepend(GTK_CLIST(self->obj), list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_append
static PyObject *
_wrap_gtk_clist_append(PyGtk_Object *self, PyObject *args)
{
    int col, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTuple(args, "O:GtkCList.append", &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "sequence item not a string");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_append(GTK_CLIST(self->obj), list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_insert
static PyObject *
_wrap_gtk_clist_insert(PyGtk_Object *self, PyObject *args)
{
    int col, row, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTuple(args, "iO:GtkCList.insert", &row, &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "sequence item not a string");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_insert(GTK_CLIST(self->obj), row, list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_set_row_data
static PyObject *
_wrap_gtk_clist_set_row_data(PyGtk_Object *self, PyObject *args)
{
    int row;
    PyObject *data;
    if (!PyArg_ParseTuple(args, "iO:GtkCList.set_row_data", &row, &data))
	return NULL;
    Py_INCREF(data);
    gtk_clist_set_row_data_full(GTK_CLIST(self->obj), row, data,
				(GtkDestroyNotify)pygtk_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clist_get_row_data
static PyObject *
_wrap_gtk_clist_get_row_data(PyGtk_Object *self, PyObject *args)
{
    PyObject *ret;
    int row;

    if (!PyArg_ParseTuple(args, "i:GtkCList.get_row_data", &row))
        return NULL;
    ret = gtk_clist_get_row_data(GTK_CLIST(self->obj), row);
    if (!ret) ret = Py_None;
    Py_INCREF(ret);
    return ret;
}
%%
override gtk_clist_find_row_from_data
static PyObject *
_wrap_gtk_clist_find_row_from_data(PyGtk_Object *self, PyObject *args)
{
    PyObject *data;

    if (!PyArg_ParseTuple(args, "O:GtkCList.find_row_from_data", &data))
        return NULL;
    return PyInt_FromLong(gtk_clist_find_row_from_data(
				GTK_CLIST(self->obj), data));
}
%%
override gtk_clist_get_selection_info
static PyObject *
_wrap_gtk_clist_get_selection_info(PyGtk_Object *self, PyObject *args)
{
    gint x, y, row, column;

    if (!PyArg_ParseTuple(args, "ii:GtkCList.get_selection_info", &x, &y))
	return NULL;
    if (gtk_clist_get_selection_info(GTK_CLIST(self->obj), x, y,
				     &row, &column))
	return Py_BuildValue("(ii)", row, column);
    else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}   
%%
override gtk_combo_set_popdown_strings
static PyObject *
_wrap_gtk_combo_set_popdown_strings(PyGtk_Object *self, PyObject *args)
{
    PyObject *list;
    GList *glist = NULL;
    int len, i;

    if (!PyArg_ParseTuple(args, "O:GtkCombo.set_popdown_strings", &list))
	return NULL;
    if (!PySequence_Check(list)) {
	PyErr_SetString(PyExc_TypeError, "first argument must be a sequence");
	return NULL;
    }
    len = PySequence_Length(list);
    for (i = 0; i < len; i++) {
	PyObject *item = PySequence_GetItem(list, i);

	Py_DECREF(item);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "sequence item not a string");
	    g_list_free(glist);
	    return NULL;
	}
	glist = g_list_append(glist, PyString_AsString(item));
    }
    gtk_combo_set_popdown_strings(GTK_COMBO(self->obj), glist);
    g_list_free(glist);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_curve_get_vector
static PyObject *
_wrap_gtk_curve_get_vector(PyGtk_Object *self, PyObject *args)
{
    int size = -1, i;
    gfloat *vector;
    PyObject *ret;

    if (!PyArg_ParseTuple(args, "|i:GtkCurve.get_vector", &size))
	return NULL;
    if (size < 0) size = GTK_CURVE(self->obj)->num_points;
    vector = g_new(gfloat, size);
    gtk_curve_get_vector(GTK_CURVE(self->obj), size, vector);
    ret = PyTuple_New(size);
    for (i = 0; i < size; i++)
	PyTuple_SetItem(ret, i, PyFloat_FromDouble(vector[i]));
    g_free(vector);
    return ret;
}
%%
override gtk_curve_set_vector
static PyObject *
_wrap_gtk_curve_set_vector(PyGtk_Object *self, PyObject *args)
{
    PyObject *seq;
    int size, i;
    gfloat *vector;

    if (!PyArg_ParseTuple(args, "O:GtkCurve.set_vector", &seq))
	return NULL;
    if (!PySequence_Check(seq)) {
	PyErr_SetString(PyExc_TypeError, "1st argument is not a sequence");
	return NULL;
    }
    size = PySequence_Length(seq);
    vector = g_new(gfloat, size);
    for (i = 0; i < size; i++) {
	PyObject *item = PySequence_GetItem(seq, i);

	Py_DECREF(item);
	item = PyNumber_Float(item); /* item has a ref now */
	if (item == NULL) {
	    g_free(vector);
	    return NULL;
	}
	vector[i] = PyFloat_AsDouble(item);
	Py_DECREF(item);
    }
    gtk_curve_set_vector(GTK_CURVE(self->obj), size, vector);
    g_free(vector);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_editable_insert_text
static PyObject *
_wrap_gtk_editable_insert_text(PyGtk_Object *self, PyObject *args)
{
    char *text;
    int len, pos;

    if (!PyArg_ParseTuple(args, "s#:GtkEditable.insert_text", &text, &len))
        return NULL;
    gtk_editable_insert_text(GTK_EDITABLE(self->obj), text, len, &pos);
    return PyInt_FromLong(pos);
}
%%
override gtk_item_factory_create_items
static void
pygtk_item_factory_cb(PyObject *callback, guint action, GtkWidget *widget)
{
    PyObject *ret;

    pygtk_block_threads();
    ret = PyObject_CallFunction(callback, "iO", action,
				PyGtk_New((GtkObject *)widget));
    if (ret == NULL) {
	if (PyGtk_FatalExceptions)
	    gtk_main_quit();
	else {
	    PyErr_Print();
	    PyErr_Clear();
	}
    } else
	Py_DECREF(ret);
    pygtk_unblock_threads();
}
static PyObject *
_wrap_gtk_item_factory_create_items(PyGtk_Object *self, PyObject *args)
{
    PyObject *list, *cb;
    GtkItemFactoryEntry ent;
    GtkItemFactory *ifact;
    int i, len;

    if (!PyArg_ParseTuple(args, "O!:GtkItemFactory.create_items",
			  &PyList_Type, &list))
	return NULL;
    ifact = GTK_ITEM_FACTORY(self->obj);
    len = PyList_Size(list);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(list, i);

	if (!PyArg_ParseTuple(item, "zzOiz", &(ent.path), &(ent.accelerator),
			      &cb, &(ent.callback_action), &(ent.item_type)))
	    return NULL;
	if (cb == Py_None)
	    ent.callback = NULL;
	else {
	    Py_INCREF(cb);
	    ent.callback = (GtkItemFactoryCallback)pygtk_item_factory_cb;
	}
	gtk_item_factory_create_item(ifact, &ent, cb, 1);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_menu_popup
static void
pygtk_menu_position(GtkMenu *menu, int *x, int *y, PyObject *func)
{
    PyObject *ret;

    pygtk_block_threads();
    ret = PyObject_CallFunction(func, "Oii", PyGtk_New(GTK_OBJECT(menu)),
                                *x, *y);
    if (ret == NULL || !PyArg_ParseTuple(ret, "ii", x, y)) {
        if (PyGtk_FatalExceptions)
            gtk_main_quit();
        else {
            PyErr_Print();
            PyErr_Clear();
        }
        if (ret) {
          Py_DECREF(ret);
        }
    } else {
        Py_DECREF(ret);
    }
    pygtk_unblock_threads();
}
static PyObject *
_wrap_gtk_menu_popup(PyGtk_Object *self, PyObject *args)
{
    PyObject *py_pms, *py_pmi;
    GtkWidget *pms = NULL, *pmi = NULL;
    PyObject *func;
    int button, time;
    if (!PyArg_ParseTuple(args, "OOOii:GtkMenu.popup",
			  &py_pms, &py_pmi, &func, &button, &time))
        return NULL;
    if (PyGtk_Check(py_pms))
        pms = GTK_WIDGET(PyGtk_Get(py_pms));
    else if (py_pms != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkWidget or None");
        return NULL;
    }
    if (PyGtk_Check(py_pmi))
        pmi = GTK_WIDGET(PyGtk_Get(py_pmi));
    else if (py_pmi != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (!PyCallable_Check(func) && func != Py_None) {
        PyErr_SetString(PyExc_TypeError, "third argument not callable");
        return NULL;
    }
    if (func != Py_None) {
	Py_INCREF(func);
	gtk_menu_popup(GTK_MENU(self->obj), pms, pmi,
		       (GtkMenuPositionFunc)pygtk_menu_position,
		       func, button, time);
    } else
	gtk_menu_popup(GTK_MENU(self->obj), pms, pmi, NULL,NULL, button,time);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_pixmap_get
static PyObject *
_wrap_gtk_pixmap_get(PyGtk_Object *self, PyObject *args)
{
    PyObject *pypixmap, *pymask;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTuple(args, ":GtkPixmap.get"))
	return NULL;
    gtk_pixmap_get(GTK_PIXMAP(self->obj), &pixmap, &mask);
    if (pixmap)
	pypixmap = PyGdkWindow_New(pixmap);
    else {
	Py_INCREF(Py_None);
	pypixmap = Py_None;
    }
    if (mask)
	pymask = PyGdkWindow_New(mask);
    else {
	Py_INCREF(Py_None);
	pymask = Py_None;
    }
    return Py_BuildValue("(NN)", pypixmap, pymask);
}

%%
ignore gtk_button_new_with_label
%%
override gtk_button_new
static PyObject *
_wrap_gtk_button_new(PyGtk_Object *self, PyObject *args)
{
    gchar *text = NULL;

    if (!PyArg_ParseTuple(args, "|z:GtkButton.__init__", &text))
	return NULL;
    if (text)
	self->obj = (GtkObject *)gtk_button_new_with_label(text);
    else
	self->obj = (GtkObject *)gtk_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkButton object");
	return NULL;
    }
    pygtk_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_toggle_button_new_with_label
%%
override gtk_toggle_button_new
static PyObject *
_wrap_gtk_toggle_button_new(PyGtk_Object *self, PyObject *args)
{
    gchar *text = NULL;

    if (!PyArg_ParseTuple(args, "|z:GtkToggleButton.__init__", &text))
	return NULL;
    if (text)
	self->obj = (GtkObject *)gtk_toggle_button_new_with_label(text);
    else
	self->obj = (GtkObject *)gtk_toggle_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkToggleButton object");
	return NULL;
    }
    pygtk_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_check_button_new_with_label
%%
override gtk_check_button_new
static PyObject *
_wrap_gtk_check_button_new(PyGtk_Object *self, PyObject *args)
{
    gchar *text = NULL;

    if (!PyArg_ParseTuple(args, "|z:GtkCheckButton.__init__", &text))
	return NULL;
    if (text)
	self->obj = (GtkObject *)gtk_check_button_new_with_label(text);
    else
	self->obj = (GtkObject *)gtk_check_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkCheckButton object");
	return NULL;
    }
    pygtk_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore-glob gtk_radio_button_new_*
%%
override gtk_radio_button_new
static PyObject *
_wrap_gtk_radio_button_new(PyGtk_Object *self, PyObject *args)
{
    PyObject *py_group = Py_None;
    gchar *label = NULL;
    GtkRadioButton *group;

    if (!PyArg_ParseTuple(args, "|Oz:GtkRadioButton.__init__", &py_group,
			  &label))
	return NULL;
    if (py_group == Py_None)
	group = NULL;
    else if (PyGtk_Check(py_group))
	group = GTK_RADIO_BUTTON(PyGtk_Get(py_group));
    else {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a GtkRadioButton or None");
	return NULL;
    }
    /* various configs for create radio buttons ... */
    if (label == NULL) {
	if (group == NULL)
	    self->obj = (GtkObject *)gtk_radio_button_new(NULL);
	else
	    self->obj = (GtkObject *)gtk_radio_button_new(group->group);
    } else {
	if (group == NULL)
	    self->obj = (GtkObject *)gtk_radio_button_new_with_label(NULL,
								     label);
	else
	    self->obj = (GtkObject *)gtk_radio_button_new_with_label
		(group->group, label);
    }
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioButton object");
	return NULL;
    }
    pygtk_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_list_item_new_with_label
%%
override gtk_list_item_new
static PyObject *
_wrap_gtk_list_item_new(PyGtk_Object *self, PyObject *args)
{
    gchar *text = NULL;

    if (!PyArg_ParseTuple(args, "|z:GtkListItem.__init__", &text))
	return NULL;
    if (text)
	self->obj = (GtkObject *)gtk_list_item_new_with_label(text);
    else
	self->obj = (GtkObject *)gtk_list_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkListItem object");
	return NULL;
    }
    pygtk_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_tree_item_new_with_label
%%
override gtk_tree_item_new
static PyObject *
_wrap_gtk_tree_item_new(PyGtk_Object *self, PyObject *args)
{
    gchar *text = NULL;

    if (!PyArg_ParseTuple(args, "|z:GtkTreeItem.__init__", &text))
	return NULL;
    if (text)
	self->obj = (GtkObject *)gtk_tree_item_new_with_label(text);
    else
	self->obj = (GtkObject *)gtk_tree_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkTreeItem object");
	return NULL;
    }
    pygtk_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_menu_item_new_with_label
%%
override gtk_menu_item_new
static PyObject *
_wrap_gtk_menu_item_new(PyGtk_Object *self, PyObject *args)
{
    gchar *text = NULL;

    if (!PyArg_ParseTuple(args, "|z:GtkMenuItem.__init__", &text))
	return NULL;
    if (text)
	self->obj = (GtkObject *)gtk_menu_item_new_with_label(text);
    else
	self->obj = (GtkObject *)gtk_menu_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkMenuItem object");
	return NULL;
    }
    pygtk_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_check_menu_item_new_with_label
%%
override gtk_check_menu_item_new
static PyObject *
_wrap_gtk_check_menu_item_new(PyGtk_Object *self, PyObject *args)
{
    gchar *text = NULL;

    if (!PyArg_ParseTuple(args, "|z:GtkCheckMenuItem.__init__", &text))
	return NULL;
    if (text)
	self->obj = (GtkObject *)gtk_check_menu_item_new_with_label(text);
    else
	self->obj = (GtkObject *)gtk_check_menu_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkCheckMenuItem object");
	return NULL;
    }
    pygtk_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_radio_menu_item_new_with_label
%%
override gtk_radio_menu_item_new
static PyObject *
_wrap_gtk_radio_menu_item_new(PyGtk_Object *self, PyObject *args)
{
    gchar *text = NULL;
    PyObject *py_group = Py_None;
    GtkRadioMenuItem *group;

    if (!PyArg_ParseTuple(args, "|Oz:GtkRadioMenuItem.__init__",
			  &py_group, &text))
	return NULL;
    if (py_group == Py_None)
	group = NULL;
    else if (PyGtk_Check(py_group))
	group = GTK_RADIO_MENU_ITEM(PyGtk_Get(py_group));
    else {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a GtkRadioMenuItem or None");
	return NULL;
    }
    /* various configs for create radio buttons ... */
    if (text == NULL) {
	if (group == NULL)
	    self->obj = (GtkObject *)gtk_radio_menu_item_new(NULL);
	else
	    self->obj = (GtkObject *)gtk_radio_menu_item_new(group->group);
    } else {
	if (group == NULL)
	    self->obj = (GtkObject *)gtk_radio_menu_item_new_with_label(NULL,
									text);
	else
	    self->obj = (GtkObject *)gtk_radio_menu_item_new_with_label
		(group->group, text);
    }
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioMenuItem object");
	return NULL;
    }
    pygtk_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
