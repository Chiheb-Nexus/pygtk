/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include <gtk/gtk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include "pygtk-private.h"
#include "pygtktreemodel.h"

/* small fix */
#undef gdk_window_get_type
#define gdk_window_get_type gdk_window_object_get_type

/* gross hack until gdk-pixbuf types get set up as normal enums/flags */
#define GDK_TYPE_COLORSPACE G_TYPE_INVALID
#define GDK_TYPE_INTERP_TYPE G_TYPE_INVALID
#define GDK_TYPE_PIXBUF_ALPHA_MODE G_TYPE_INVALID

static PyExtensionClass *_PyGObject_Type;
#define PyGObject_Type (*_PyGObject_Type)

static PyExtensionClass *_PyPangoContext_Type;
#define PyPangoContext_Type (*_PyPangoContext_Type)
static PyExtensionClass *_PyPangoFont_Type;
#define PyPangoFont_Type (*_PyPangoFont_Type)
static PyExtensionClass *_PyPangoLayout_Type;
#define PyPangoLayout_Type (*_PyPangoLayout_Type)

%%
init
{
    PyObject *pygobject = PyImport_ImportModule("gobject");
    PyObject *pypango;

    if (pygobject != NULL) {
	PyObject *module_dict = PyModule_GetDict(pygobject);

	_PyGObject_Type = (PyExtensionClass *)PyDict_GetItemString(module_dict,
								   "GObject");
    } else {
	Py_FatalError("could not import gobject");
	return;
    }
    pypango = PyImport_ImportModule("pango");
    if (pypango != NULL) {
	PyObject *module_dict = PyModule_GetDict(pypango);

	_PyPangoContext_Type =
	    (PyExtensionClass *)PyDict_GetItemString(module_dict,
						     "PangoContext");
	_PyPangoFont_Type =
	    (PyExtensionClass *)PyDict_GetItemString(module_dict,
						     "PangoFont");
	_PyPangoLayout_Type =
	    (PyExtensionClass *)PyDict_GetItemString(module_dict,
						     "PangoLayout");
    } else {
	Py_FatalError("could not import pango");
	return;
    }
}

%%
override gdk_draw_polygon kwargs
static PyObject *
_wrap_gdk_draw_polygon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "filled", "points", NULL };
    PyGObject *gc;
    PyObject *py_points;
    gint filled, npoints, i;
    GdkPoint *points;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OiO:GdkDrawable.draw_polygon",
				     kwlist, &gc, &filled, &py_points))
	return NULL;
    if (!pygobject_check(gc, &PyGdkGC_Type)) {
	PyErr_SetString(PyExc_TypeError, "gc must be a GdkGC");
	return NULL;
    }
    if (!PySequence_Check(py_points)) {
	PyErr_SetString(PyExc_TypeError, "points must be a sequence");
	return NULL;
    }
    npoints = PySequence_Length(py_points);
    points = g_new(GdkPoint, npoints);
    for (i = 0; i < npoints; i++) {
	PyObject *item = PySequence_GetItem(py_points, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "hh", &points[i].x, &points[i].y)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "sequence members must be 2-tuples");
	    g_free(points);
	    return NULL;
	}
    }
    gdk_draw_polygon(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj), filled,
		     points, npoints);
    g_free(points);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_text kwargs
static PyObject *
_wrap_gdk_draw_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "font", "gc", "x", "y", "text",NULL};
    PyGObject *gc;
    PyObject *font;
    int x, y, len;
    char *text;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOiis#:GdkDrawable.draw_text",
				     kwlist,  &font,
				     &gc, &x, &y, &text, &len))
	return NULL;
    if (!pyg_boxed_check(font, GDK_TYPE_FONT)) {
	PyErr_SetString(PyExc_TypeError, "font must be a GdkFont");
	return NULL;
    }
    if (!pygobject_check(gc, &PyGdkGC_Type)) {
	PyErr_SetString(PyExc_TypeError, "gc must be a GdkGC");
	return NULL;
    }
    gdk_draw_text(GDK_DRAWABLE(self->obj), pyg_boxed_get(font, GdkFont),
		  GDK_GC(gc->obj), x, y, text, len);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_points kwargs
static PyObject *
_wrap_gdk_draw_points(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "points", NULL };
    PyGObject *gc;
    PyObject *py_points;
    gint npoints, i;
    GdkPoint *points;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GdkDrawable.draw_points",
				     kwlist, &gc, &py_points))
	return NULL;
    if (!pygobject_check(gc, &PyGdkGC_Type)) {
	PyErr_SetString(PyExc_TypeError, "gc must be a GdkGC");
	return NULL;
    }
    if (!PySequence_Check(py_points)) {
	PyErr_SetString(PyExc_TypeError, "points must be a sequence");
	return NULL;
    }
    npoints = PySequence_Length(py_points);
    points = g_new(GdkPoint, npoints);
    for (i = 0; i < npoints; i++) {
	PyObject *item = PySequence_GetItem(py_points, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "hh", &points[i].x, &points[i].y)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "sequence members must be 2-tuples");
	    g_free(points);
	    return NULL;
	}
    }
    gdk_draw_points(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj), points, npoints);
    g_free(points);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_segments kwargs
static PyObject *
_wrap_gdk_draw_segments(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "segs", NULL };
    PyGObject *gc;
    PyObject *py_segs;
    gint nsegs, i;
    GdkSegment *segs;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GdkDrawable.draw_segments",
				     kwlist, &gc, &py_segs))
	return NULL;
    if (!pygobject_check(gc, &PyGdkGC_Type)) {
	PyErr_SetString(PyExc_TypeError, "gc must be a GdkGC");
	return NULL;
    }
    if (!PySequence_Check(py_segs)) {
	PyErr_SetString(PyExc_TypeError, "segs must be a sequence");
	return NULL;
    }
    nsegs = PySequence_Length(py_segs);
    segs = g_new(GdkSegment, nsegs);
    for (i = 0; i < nsegs; i++) {
	PyObject *item = PySequence_GetItem(py_segs, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "hhhh", &segs[i].x1, &segs[i].y1,
			      &segs[i].x2, &segs[i].y2)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "sequence members must be 4-tuples");
	    g_free(segs);
	    return NULL;
	}
    }
    gdk_draw_segments(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj), segs, nsegs);
    g_free(segs);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_lines kwargs
static PyObject *
_wrap_gdk_draw_lines(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "points", NULL };
    PyGObject *gc;
    PyObject *py_points;
    gint npoints, i;
    GdkPoint *points;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:GdkDrawable.draw_lines",
				     kwlist, &gc, &py_points))
	return NULL;
    if (!pygobject_check(gc, &PyGdkGC_Type)) {
	PyErr_SetString(PyExc_TypeError, "gc must be a GdkGC");
	return NULL;
    }
    if (!PySequence_Check(py_points)) {
	PyErr_SetString(PyExc_TypeError, "points must be a sequence");
	return NULL;
    }
    npoints = PySequence_Length(py_points);
    points = g_new(GdkPoint, npoints);
    for (i = 0; i < npoints; i++) {
	PyObject *item = PySequence_GetItem(py_points, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "hh", &points[i].x, &points[i].y)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "sequence members must be 2-tuples");
	    g_free(points);
	    return NULL;
	}
    }
    gdk_draw_lines(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj), points, npoints);
    g_free(points);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore
  gdk_color_copy gdk_color_free
  gdk_color_hash gdk_color_equal
  gdk_color_parse
%%
override gdk_fontset_load kwargs
static PyObject *
_wrap_gdk_fontset_load(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fontset_name", NULL };
    char *fontset_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:fontset_load", kwlist,
				     &fontset_name))
        return NULL;

    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GDK_TYPE_FONT, gdk_fontset_load(fontset_name),
			 FALSE, TRUE);
}
%%
override gdk_text_extents kwargs
static PyObject *
_wrap_gdk_text_extents(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    gchar *text;
    gint length;
    gint lbearing, rbearing, width, ascent, descent;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s#:GdkFont.extents",
				     kwlist, &text, &length))
	return NULL;
    gdk_text_extents(pyg_boxed_get(self, GdkFont), text, length,
		     &lbearing, &rbearing, &width, &ascent, &descent);
    return Py_BuildValue("(iiiii)", lbearing, rbearing, width,
			 ascent, descent);
}
%%
override gdk_pixmap_create_from_xpm kwargs
static PyObject *
_wrap_gdk_pixmap_create_from_xpm(PyObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "window", "transparent_color", "filename", NULL};
    PyGObject *window;
    PyObject *py_trans_color, *ret;
    GdkColor *trans_color = NULL;
    gchar *filename;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOs:pixmap_create_from_xpm", kwlist,
				     &window, &py_trans_color, &filename))
	return NULL;
    if (!pygobject_check(window, &PyGdkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "window must be a GdkWindow");
	return NULL;
    }
    if (pyg_boxed_check(py_trans_color, GDK_TYPE_COLOR))
	trans_color = pyg_boxed_get(py_trans_color, GdkColor);
    else if (py_trans_color != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"transparent_color must be a colour or None");
	return NULL;
    }
    pixmap = gdk_pixmap_create_from_xpm(GDK_WINDOW(window->obj), &mask,
					trans_color, filename);
    if (pixmap == NULL) {
	PyErr_SetString(PyExc_IOError, "can't load pixmap");
	return NULL;
    }
    ret = Py_BuildValue("(NN)",
			pygobject_new((GObject *)pixmap),
			pygobject_new((GObject *)mask));
    gdk_pixmap_unref(pixmap);
    gdk_bitmap_unref(mask);
    return ret;
}
%%
override gdk_pixmap_colormap_create_from_xpm kwargs
static PyObject *
_wrap_gdk_pixmap_colormap_create_from_xpm(PyObject *self, PyObject *args,
					  PyObject *kwargs)
{
    static char *kwlist[] = { "window", "colormap", "transparent_color",
			      "filename", NULL };
    PyObject *py_window, *py_colormap, *py_trans_color, *ret;
    GdkWindow *window = NULL;
    GdkColormap *colormap = NULL;
    GdkColor *trans_color = NULL;
    gchar *filename;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOOs:pixmap_colormap_create_from_xpm",
				     kwlist, &py_window, &py_colormap,
				     &py_trans_color, &filename))
	return NULL;
    if (pygobject_check(py_window, &PyGdkWindow_Type))
	window = GDK_WINDOW(pygobject_get(py_window));
    else if (py_window != Py_None) {
	PyErr_SetString(PyExc_TypeError, "window must be a GdkWindow or None");
	return NULL;
    }
    if (pygobject_check(py_colormap, &PyGdkColormap_Type))
	colormap = GDK_COLORMAP(pygobject_get(py_colormap));
    else if (py_colormap != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"colormap must be a GdkColormap or None");
	return NULL;
    }
    if (pyg_boxed_check(py_trans_color, GDK_TYPE_COLOR))
	trans_color = pyg_boxed_get(py_trans_color, GdkColor);
    else if (py_trans_color != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"transparent_color must be a colour or None");
	return NULL;
    }
    pixmap = gdk_pixmap_colormap_create_from_xpm(window, colormap, &mask,
						 trans_color, filename);
    if (pixmap == NULL) {
	PyErr_SetString(PyExc_IOError, "can't load pixmap");
	return NULL;
    }
    ret = Py_BuildValue("(NN)",
			pygobject_new((GObject *)pixmap),
			pygobject_new((GObject *)mask));
    gdk_pixmap_unref(pixmap);
    gdk_bitmap_unref(mask);
    return ret;
}
%%
override gdk_pixmap_create_from_xpm_d kwargs
static PyObject *
_wrap_gdk_pixmap_create_from_xpm_d(PyObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "window", "transparent_color", "data", NULL };
    PyGObject *window;
    PyObject *py_trans_color, *py_data, *ret;
    GdkColor *trans_color = NULL;
    gchar **data;
    int len, i;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!OO!:pixmap_create_from_xpm_d", kwlist,
				     &window, &py_trans_color,
				     &PyList_Type, &py_data))
	return NULL;
    if (!pygobject_check(window, &PyGdkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "window must be a GdkWindow");
	return NULL;
    }
    if (pyg_boxed_check(py_trans_color, GDK_TYPE_COLOR))
	trans_color = pyg_boxed_get(py_trans_color, GdkColor);
    else if (py_trans_color != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"transparent_color must be a colour or None");
	return NULL;
    }
    len = PyList_Size(py_data);
    data = g_new(gchar *, len);
    for (i = 0; i < len; i ++) {
	PyObject *item = PyList_GetItem(py_data, i);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "data items must be strings");
	    g_free(data);
	    return NULL;
	}
	data[i] = PyString_AsString(item);
    }
    pixmap = gdk_pixmap_create_from_xpm_d(GDK_WINDOW(window->obj), &mask,
					  trans_color, data);
    g_free(data);
    if (pixmap == NULL) {
	PyErr_SetString(PyExc_IOError, "can't load pixmap");
	return NULL;
    }
    ret = Py_BuildValue("(NN)",
			pygobject_new((GObject *)pixmap),
			pygobject_new((GObject *)mask));
    gdk_pixmap_unref(pixmap);
    gdk_bitmap_unref(mask);
    return ret;
}
%%
override gdk_pixmap_colormap_create_from_xpm_d kwargs
static PyObject *
_wrap_gdk_pixmap_colormap_create_from_xpm_d(PyObject *self, PyObject *args,
					    PyObject *kwargs)
{
    static char *kwlist[] = { "window", "colormap", "transparent_color",
			      "data", NULL };
    PyObject *py_window, *py_colormap, *py_trans_color, *py_data, *ret;
    GdkWindow *window = NULL;
    GdkColormap *colormap = NULL;
    GdkColor *trans_color = NULL;
    gchar **data;
    int len, i;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOOO!:pixmap_colormap_create_from_xpm_d",
				     kwlist, &py_window, &py_colormap,
				     &py_trans_color,
				     &PyList_Type, &py_data))
	return NULL;
    if (pygobject_check(py_window, &PyGdkWindow_Type))
	window = GDK_WINDOW(pygobject_get(py_window));
    else if (py_window != Py_None) {
	PyErr_SetString(PyExc_TypeError, "window must be a GdkWindow or None");
	return NULL;
    }
    if (pygobject_check(py_colormap, &PyGdkColormap_Type))
	colormap = GDK_COLORMAP(pygobject_get(py_colormap));
    else if (py_colormap != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"colormap must be a GdkColormap or None");
	return NULL;
    }
    if (pyg_boxed_check(py_trans_color, GDK_TYPE_COLOR))
	trans_color = pyg_boxed_get(py_trans_color, GdkColor);
    else if (py_trans_color != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"transparent_color must be a colour or None");
	return NULL;
    }
    len = PyList_Size(py_data);
    data = g_new(gchar *, len);
    for (i = 0; i < len; i ++) {
	PyObject *item = PyList_GetItem(py_data, i);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "data items must be strings");
	    g_free(data);
	    return NULL;
	}
	data[i] = PyString_AsString(item);
    }
    pixmap = gdk_pixmap_colormap_create_from_xpm_d(window, colormap, &mask,
						   trans_color, data);
    g_free(data);
    if (pixmap == NULL) {
	PyErr_SetString(PyExc_IOError, "can't load pixmap");
	return NULL;
    }
    ret = Py_BuildValue("(NN)",
			pygobject_new((GObject *)pixmap),
			pygobject_new((GObject *)mask));
    gdk_pixmap_unref(pixmap);
    gdk_bitmap_unref(mask);
    return ret;
}
%%
ignore gdk_cursor_new_from_pixmap
%%
override gdk_cursor_new kwargs
static PyObject *
_wrap_gdk_cursor_new(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist1[] = { "cursor_type", NULL };
    static char *kwlist2[] = { "source", "mask", "fg", "bg", "x", "y", NULL };
    PyObject *py_cursor_type;

    self->gtype = GDK_TYPE_CURSOR;
    self->free_on_dealloc = FALSE;
    self->boxed = NULL;
    if (PyArg_ParseTupleAndKeywords(args, kwargs, "O:GdkCursor.__init__",
				    kwlist1, &py_cursor_type)) {
	GdkCursorType cursor_type;

        if (pyg_enum_get_value(GDK_TYPE_CURSOR_TYPE, py_cursor_type,
			       (gint *)&cursor_type))
	    return NULL;
	self->boxed = gdk_cursor_new(cursor_type);
	if (!self->boxed) {
	    PyErr_SetString(PyExc_RuntimeError,
			    "could not create GdkCursor object");
	    return NULL;
	}
	self->free_on_dealloc = TRUE;
    } else {
	PyGObject *source, *mask;
	PyObject *fg, *bg;
	gint x, y;
	PyErr_Clear();

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "OOOOii:GdkCursor.__init__", kwlist2,
					 &source, &mask, &fg, &bg, &x, &y))
	    return NULL;
	if (!pygobject_check(source, &PyGdkPixmap_Type)) {
	    PyErr_SetString(PyExc_TypeError, "source should be a GdkPixmap");
	    return NULL;
	}
	if (!pygobject_check(mask, &PyGdkPixmap_Type)) {
	    PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap");
	    return NULL;
	}
	if (!pyg_boxed_check(fg, GDK_TYPE_COLOR)) {
	    PyErr_SetString(PyExc_TypeError, "fg should be a GdkColor");
	    return NULL;
	}
	if (!pyg_boxed_check(bg, GDK_TYPE_COLOR)) {
	    PyErr_SetString(PyExc_TypeError, "bg should be a GdkColor");
	    return NULL;
	}
	self->boxed = gdk_cursor_new_from_pixmap(GDK_PIXMAP(source->obj),
						 GDK_PIXMAP(mask->obj),
						 pyg_boxed_get(fg, GdkColor),
						 pyg_boxed_get(bg, GdkColor),
						 x, y);
	if (!self->boxed) {
	    PyErr_SetString(PyExc_RuntimeError,
			    "could not create GdkCursor object");
	    return NULL;
	}
	self->free_on_dealloc = TRUE;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_event_getattr
PyObject *
_wrap_gdk_event_getattr(PyObject *self, char *attr)
{
    GdkEvent *event = pyg_boxed_get(self, GdkEvent);
    guint i;

    if (!strcmp(attr, "type"))
	return PyInt_FromLong(event->type);
    if (!strcmp(attr, "window"))
	return pygobject_new((GObject *)event->any.window);
    if (!strcmp(attr, "send_event"))
	return PyInt_FromLong(event->any.send_event);

    switch(event->type) {
    case GDK_NOTHING: break;
    case GDK_DELETE: break;
    case GDK_DESTROY: break;
    case GDK_EXPOSE:            /*GdkEventExpose            expose*/
	if (!strcmp(attr, "area"))
	    return Py_BuildValue("(iiii)",
				 event->expose.area.x,
				 event->expose.area.y,
				 event->expose.area.width,
				 event->expose.area.height);
	if (!strcmp(attr, "count"))
	    return PyInt_FromLong(event->expose.count);
	break;
    case GDK_MOTION_NOTIFY:     /*GdkEventMotion            motion*/
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->motion.time);
	if (!strcmp(attr, "x"))
	    return PyFloat_FromDouble(event->motion.x);
	if (!strcmp(attr, "y"))
	    return PyFloat_FromDouble(event->motion.y);
	if (!strcmp(attr, "axes")) {
	    if (event->motion.axes) {
		PyObject *v = PyTuple_New(event->motion.device->num_axes);
		if (!v) return NULL;
		for (i = 0; i < event->motion.device->num_axes; i++)
		    PyTuple_SetItem(v, i,PyFloat_FromDouble(
						event->motion.axes[i]));
		return v;
	    } else {
		Py_INCREF(Py_None);
		return Py_None;
	    }
	}
	if (!strcmp(attr, "state"))
	    return PyInt_FromLong(event->motion.state);
	if (!strcmp(attr, "is_hint"))
	    return PyInt_FromLong(event->motion.is_hint);
	if (!strcmp(attr, "device"))
	    return pygobject_new((GObject *)event->motion.device);
	if (!strcmp(attr, "x_root"))
	    return PyFloat_FromDouble(event->motion.x_root);
	if (!strcmp(attr, "y_root"))
	    return PyFloat_FromDouble(event->motion.y_root);
	break;
    case GDK_BUTTON_PRESS:      /*GdkEventButton            button*/
    case GDK_2BUTTON_PRESS:     /*GdkEventButton            button*/
    case GDK_3BUTTON_PRESS:     /*GdkEventButton            button*/
    case GDK_BUTTON_RELEASE:    /*GdkEventButton            button*/
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->button.time);
	if (!strcmp(attr, "x"))
	    return PyFloat_FromDouble(event->button.x);
	if (!strcmp(attr, "y"))
	    return PyFloat_FromDouble(event->button.y);
	if (!strcmp(attr, "axes")) {
	    if (event->button.axes) {
		PyObject *v = PyTuple_New(event->button.device->num_axes);
		if (!v) return NULL;
		for (i = 0; i < event->button.device->num_axes; i++)
		    PyTuple_SetItem(v, i,PyFloat_FromDouble(
						event->button.axes[i]));
		return v;
	    } else {
		Py_INCREF(Py_None);
		return Py_None;
	    }
	}
	if (!strcmp(attr, "state"))
	    return PyInt_FromLong(event->button.state);
	if (!strcmp(attr, "button"))
	    return PyInt_FromLong(event->button.button);
	if (!strcmp(attr, "device"))
	    return pygobject_new((GObject *)event->button.device);
	if (!strcmp(attr, "x_root"))
	    return PyFloat_FromDouble(event->button.x_root);
	if (!strcmp(attr, "y_root"))
	    return PyFloat_FromDouble(event->button.y_root);
	break;
    case GDK_KEY_PRESS:         /*GdkEventKey               key*/
    case GDK_KEY_RELEASE:       /*GdkEventKey               key*/
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->key.time);
	if (!strcmp(attr, "state"))
	    return PyInt_FromLong(event->key.state);
	if (!strcmp(attr, "keyval"))
	    return PyInt_FromLong(event->key.keyval);
	if (!strcmp(attr, "string"))
	    return PyString_FromStringAndSize(event->key.string,
					      event->key.length);
	break;
    case GDK_ENTER_NOTIFY:      /*GdkEventCrossing          crossing*/
    case GDK_LEAVE_NOTIFY:      /*GdkEventCrossing          crossing*/
	if (!strcmp(attr, "subwindow"))
	    return pygobject_new((GObject *)event->crossing.subwindow);
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->crossing.time);
	if (!strcmp(attr, "x"))
	    return PyFloat_FromDouble(event->crossing.x);
	if (!strcmp(attr, "y"))
	    return PyFloat_FromDouble(event->crossing.y);
	if (!strcmp(attr, "x_root"))
	    return PyFloat_FromDouble(event->crossing.x_root);
	if (!strcmp(attr, "y_root"))
	    return PyFloat_FromDouble(event->crossing.y_root);
	if (!strcmp(attr, "mode"))
	    return PyInt_FromLong(event->crossing.mode);
	if (!strcmp(attr, "detail"))
	    return PyInt_FromLong(event->crossing.detail);
	if (!strcmp(attr, "focus"))
	    return PyInt_FromLong(event->crossing.focus);
	if (!strcmp(attr, "state"))
	    return PyInt_FromLong(event->crossing.state);
	break;
    case GDK_FOCUS_CHANGE:      /*GdkEventFocus             focus_change*/
	if (!strcmp(attr, "in_"))
	    return PyInt_FromLong(event->focus_change.in);
	break;
    case GDK_CONFIGURE:         /*GdkEventConfigure         configure*/
	if (!strcmp(attr, "x"))
	    return PyInt_FromLong(event->configure.x);
	if (!strcmp(attr, "y"))
	    return PyInt_FromLong(event->configure.y);
	if (!strcmp(attr, "width"))
	    return PyInt_FromLong(event->configure.width);
	if (!strcmp(attr, "height"))
	    return PyInt_FromLong(event->configure.height);
	break;
    case GDK_MAP: break;
    case GDK_UNMAP: break;
    case GDK_PROPERTY_NOTIFY:   /*GdkEventProperty          property*/
	if (!strcmp(attr, "atom"))
	    return PyGdkAtom_New(event->property.atom);
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->property.time);
	if (!strcmp(attr, "state"))
	    return PyInt_FromLong(event->property.state);
	break;
    case GDK_SELECTION_CLEAR:   /*GdkEventSelection         selection*/
    case GDK_SELECTION_REQUEST: /*GdkEventSelection         selection*/
    case GDK_SELECTION_NOTIFY:  /*GdkEventSelection         selection*/
	if (!strcmp(attr, "selection"))
	    return PyGdkAtom_New(event->selection.selection);
	if (!strcmp(attr, "target"))
	    return PyGdkAtom_New(event->selection.target);
	if (!strcmp(attr, "property"))
	    return PyGdkAtom_New(event->selection.property);
	if (!strcmp(attr, "requestor"))
	    return PyInt_FromLong(event->selection.requestor);
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->selection.time);
	break;
    case GDK_PROXIMITY_IN:      /*GdkEventProximity         proximity*/
    case GDK_PROXIMITY_OUT:     /*GdkEventProximity         proximity*/
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->proximity.time);
	if (!strcmp(attr, "device"))
	    return pygobject_new((GObject *)event->proximity.device);
	break;
    case GDK_DRAG_ENTER:        /*GdkEventDND               dnd*/
    case GDK_DRAG_LEAVE:        /*GdkEventDND               dnd*/
    case GDK_DRAG_MOTION:       /*GdkEventDND               dnd*/
    case GDK_DRAG_STATUS:       /*GdkEventDND               dnd*/
    case GDK_DROP_START:        /*GdkEventDND               dnd*/
    case GDK_DROP_FINISHED:     /*GdkEventDND               dnd*/
	if (!strcmp(attr, "context"))
	    return pygobject_new((GObject *)event->dnd.context);
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->dnd.time);
	if (!strcmp(attr, "x_root"))
	    return PyFloat_FromDouble(event->dnd.x_root);
	if (!strcmp(attr, "y_root"))
	    return PyFloat_FromDouble(event->dnd.y_root);
	break;
    case GDK_CLIENT_EVENT:      /*GdkEventClient            client*/
	if (!strcmp(attr, "message_type"))
	    return PyGdkAtom_New(event->client.message_type);
	if (!strcmp(attr, "data_format"))
	    return PyInt_FromLong(event->client.data_format);
	if (!strcmp(attr, "data"))
	    return PyString_FromStringAndSize(event->client.data.b, 20);
	break;
    case GDK_VISIBILITY_NOTIFY: /*GdkEventVisibility        visibility*/
	if (!strcmp(attr, "state"))
	    return PyInt_FromLong(event->visibility.state);
	break;
    case GDK_NO_EXPOSE:         /*GdkEventNoExpose          no_expose*/
	break;
    case GDK_SCROLL:            /*GdkEventScroll            scroll*/
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->scroll.time);
	if (!strcmp(attr, "x"))
	    return PyFloat_FromDouble(event->scroll.x);
	if (!strcmp(attr, "y"))
	    return PyFloat_FromDouble(event->scroll.y);
	if (!strcmp(attr, "state"))
	    return PyInt_FromLong(event->scroll.state);
	if (!strcmp(attr, "direction"))
	    return PyInt_FromLong(event->scroll.direction);
	if (!strcmp(attr, "device"))
	    return pygobject_new((GObject *)event->scroll.device);
	if (!strcmp(attr, "x_root"))
	    return PyFloat_FromDouble(event->scroll.x_root);
	if (!strcmp(attr, "y_root"))
	    return PyFloat_FromDouble(event->scroll.y_root);
	break;
    case GDK_WINDOW_STATE:      /*GdkEventWindowState       window_state*/
	if (!strcmp(attr, "changed_mask"))
	    return PyInt_FromLong(event->window_state.changed_mask);
	if (!strcmp(attr, "new_window_state"))
	    return PyInt_FromLong(event->window_state.new_window_state);
	break;
    case GDK_SETTING:           /*GdkEventSetting           setting*/
	if (!strcmp(attr, "action"))
	    return PyInt_FromLong(event->setting.action);
	if (!strcmp(attr, "name"))
	    return PyString_FromString(event->setting.name);
	break;
    default:
	break;
    }
    PyErr_SetString(PyExc_AttributeError, attr);
    return NULL;
}
%%
override-attr GdkDevice.axes
GdkDevice *device = GDK_DEVICE(self->obj);
PyObject *ret;
gint i;

ret = PyTuple_New(device->num_axes);
for (i = 0; i < device->num_axes; i++)
    PyTuple_SetItem(ret, i, Py_BuildValue("(idd)",
					  device->axes[i].use,
					  device->axes[i].min,
					  device->axes[i].max));
return ret;
%%
override-attr GdkDevice.keys
GdkDevice *device = GDK_DEVICE(self->obj);
PyObject *ret;
gint i;

ret = PyTuple_New(device->num_keys);
for (i = 0; i < device->num_keys; i++)
    PyTuple_SetItem(ret, i, Py_BuildValue("(ii)",
					  device->keys[i].keyval,
					  device->keys[i].modifiers));
return ret;
%%
override gdk_device_get_state kwargs
static PyObject *
_wrap_gdk_device_get_state(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", NULL };
    GdkDevice *device = GDK_DEVICE(self->obj);
    PyGObject *window;
    gdouble *axes;
    GdkModifierType mask;
    PyObject *py_axes;
    guint i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GdkDevice.get_state",
				     kwlist, &window))
	return NULL;
    if (!pygobject_check(window, &PyGdkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "window should be a GdkWindow");
	return NULL;
    }
    axes = g_new0(gdouble, device->num_axes);
    gdk_device_get_state(device, GDK_WINDOW(window->obj), axes, &mask);
    py_axes = PyTuple_New(device->num_axes);
    for (i = 0; i < device->num_axes; i++)
	PyTuple_SetItem(py_axes, i, PyFloat_FromDouble(axes[i]));
    g_free(axes);
    return Py_BuildValue("(Ni)", py_axes, mask);
}
%%
ignore gdk_device_free_history
%%
override gdk_device_get_history kwargs
static PyObject *
_wrap_gdk_device_get_history(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "start", "stop", NULL };
    GdkDevice *device = GDK_DEVICE(self->obj);
    PyGObject *window;
    guint start, stop;
    GdkTimeCoord **events;
    gint n_events;
    PyObject *pyevents;
    guint i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oii:GdkDevice.get_history", kwlist,
				     &window, &start, &stop))
	return NULL;
    if (!pygobject_check(window, &PyGdkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "window should be a GdkWindow");
	return NULL;
    }
    gdk_device_get_history(device, GDK_WINDOW(window->obj), start, stop,
			   &events, &n_events);
    pyevents = PyTuple_New(n_events);
    for (i = 0; i < n_events; i++) {
	PyObject *axes;
	gint j;

	axes = PyTuple_New(device->num_axes);
	for (j = 0; j < device->num_axes; j++)
	    PyTuple_SetItem(axes, j, PyFloat_FromDouble(events[i]->axes[j]));
	PyTuple_SetItem(pyevents, i, Py_BuildValue("(iN)", events[i]->time,
						   axes));
    }
    gdk_device_free_history(events, n_events);
    return pyevents;
}
%%
override gdk_device_get_axis kwargs
static PyObject *
_wrap_gdk_device_get_axis(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "axes", "use", NULL };
    GdkDevice *device = GDK_DEVICE(self->obj);
    PyObject *py_axes;
    gdouble *axes, value;
    GdkAxisUse use;
    gboolean ret;
    gint i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oi:GdkDevice.get_axis",
				     kwlist, &py_axes, &use))
	return NULL;
    if (!PySequence_Check(py_axes)) {
	PyErr_SetString(PyExc_TypeError, "axes must be a sequence");
	return NULL;
    }
    if (PySequence_Length(py_axes) != device->num_axes) {
	PyErr_SetString(PyExc_TypeError, "axes has the wrong length");
	return NULL;
    }
    axes = g_new(gdouble, device->num_axes);
    for (i = 0; i < device->num_axes; i++) {
	PyObject *item = PySequence_GetItem(py_axes, i);

	axes[i] = PyFloat_AsDouble(item);
	Py_DECREF(item);
	if (PyErr_Occurred()) {
	    g_free(axes);
	    return NULL;
       }
    }
    ret = gdk_device_get_axis(device, axes, use, &value);
    g_free(axes);
    if (ret)
	return PyFloat_FromDouble(value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_selection_data_copy gtk_selection_data_free
%%
override-attr GtkSelectionData.data
if (pyg_boxed_get(self, GtkSelectionData)->length >= 0) {
    return PyString_FromStringAndSize(
			pyg_boxed_get(self, GtkSelectionData)->data,
			pyg_boxed_get(self, GtkSelectionData)->length);
} else {
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_selection_data_set kwargs
static PyObject *
_wrap_gtk_selection_data_set(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", "format", "data", NULL };
    GdkAtom type;
    int format, length;
    guchar *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "iis#:GtkSelectionData.set", kwlist,
				     &type, &format, &data, &length))
	return NULL;
    gtk_selection_data_set(pyg_boxed_get(self, GtkSelectionData),
			   type, format, data, length);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_widget_draw kwargs
static PyObject *
_wrap_gtk_widget_draw(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "rect", NULL };
    GdkRectangle rect;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "(hhhh):GtkWidget.draw",
				     kwlist, &(rect.x), &(rect.y),
				     &(rect.width), &(rect.height)))
        return NULL;
    gtk_widget_draw(GTK_WIDGET(self->obj), &rect);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_widget_size_request
static PyObject *
_wrap_gtk_widget_size_request(PyGObject *self, PyObject *args)
{
    GtkRequisition requisition;

    if (!PyArg_ParseTuple(args,":GtkWidget.size_request"))
        return NULL;
    gtk_widget_size_request(GTK_WIDGET(self->obj), &requisition);
    return Py_BuildValue("(ii)", requisition.width, requisition.height);
}
%%
override gtk_widget_size_allocate kwargs
static PyObject *
_wrap_gtk_widget_size_allocate(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "allocation", NULL };
    GtkAllocation allocation;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs,
				    "(hhhh):GtkWidget.size_allocate", kwlist,
				    &(allocation.x), &(allocation.y),
				    &(allocation.width), &(allocation.height)))
        return NULL;
    gtk_widget_size_allocate(GTK_WIDGET(self->obj), &allocation);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_widget_get_child_requisition
static PyObject *
_wrap_gtk_widget_get_child_requisition(PyGObject *self, PyObject *args)
{
    GtkRequisition requisition;

    if (!PyArg_ParseTuple(args,":GtkWidget.get_child_requisition"))
        return NULL;
    gtk_widget_get_child_requisition(GTK_WIDGET(self->obj), &requisition);
    return Py_BuildValue("(ii)", requisition.width, requisition.height);
}
%%
override gtk_widget_get_allocation
static PyObject *
_wrap_gtk_widget_get_allocation(PyGObject *self, PyObject *args)
{
    GtkAllocation allocation;

    if (!PyArg_ParseTuple(args, ":GtkWidget.get_allocation"))
	return NULL;
    allocation = GTK_WIDGET(self->obj)->allocation;
    return Py_BuildValue("(iiii)", (int)allocation.x, (int)allocation.y,
			 (int)allocation.width, (int)allocation.height);
}
%%
override gtk_widget_intersect kwargs
static PyObject *
_wrap_gtk_widget_intersect(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "area", NULL };
    GdkRectangle area;
    GdkRectangle intersect;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "(hhhh):GtkWidget.intersect",
				    kwlist, &(area.x), &(area.y),
				    &(area.width), &(area.height))) 
        return NULL;
    if (gtk_widget_intersect(GTK_WIDGET(self->obj), &area, &intersect))
        return Py_BuildValue("(iiii)", (int)intersect.x, (int)intersect.y,
                             (int)intersect.width, (int)intersect.height);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gtk_widget_get_pointer
static PyObject *
_wrap_gtk_widget_get_pointer(PyGObject *self, PyObject *args)
{
    int x, y;

    if (!PyArg_ParseTuple(args, ":GtkWidget.get_pointer"))
	return NULL;
    gtk_widget_get_pointer(GTK_WIDGET(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gtk_container_children
static PyObject *
_wrap_gtk_container_children(PyGObject *self, PyObject *args)
{
    GList *list, *tmp;
    PyObject *py_list;
    PyObject *gtk_obj;

    if(!PyArg_ParseTuple(args,":GtkContainer.children"))
        return NULL;
    list = gtk_container_children(GTK_CONTAINER(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
	g_list_free(list);
	return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
	gtk_obj = pygobject_new(G_OBJECT(tmp->data));
	if (gtk_obj == NULL) {
	    g_list_free(list);
	    Py_DECREF(py_list);
	    return NULL;
	}
	PyList_Append(py_list, gtk_obj);
	Py_DECREF(gtk_obj);
    }
    g_list_free(list);
    return py_list;
}
%%
override gtk_label_get
static PyObject *
_wrap_gtk_label_get(PyGObject *self, PyObject *args)
{
    gchar *text = NULL;

    if (!PyArg_ParseTuple(args, ":GtkLabel.get"))
	return NULL;
    gtk_label_get(GTK_LABEL(self->obj), &text);
    if (text)
	return PyString_FromString(text);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_window_set_geometry_hints kwargs
static PyObject *
_wrap_gtk_window_set_geometry_hints(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "geometry_widget", "min_width", "min_height",
			      "max_width", "max_height", "base_width",
			      "base_height", "width_inc", "height_inc", NULL };
    PyObject *py_geometry_widget = Py_None;
    GtkWidget *geometry_widget = NULL;
    gint min_width = -1, min_height = -1, max_width = -1, max_height = -1;
    gint base_width = -1, base_height = -1, width_inc = -1, height_inc = -1;
    gdouble min_aspect = -1.0, max_aspect = -1.0;
    GdkGeometry geometry = { 0 };
    GdkWindowHints geom_mask = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
			"|Oiiiiiiiidd:GtkWindow.set_geometry_hints", kwlist,
				     &py_geometry_widget, &min_width,
				     &min_height, &max_width, &max_height,
				     &base_width, &base_height, &width_inc,
				     &height_inc, &min_aspect, &max_aspect))
	return NULL;
    if (pygobject_check(py_geometry_widget, &PyGtkWidget_Type))
	geometry_widget = GTK_WIDGET(pygobject_get(py_geometry_widget));
    else if (py_geometry_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"geometry_widget must be a GtkWidget or None");
	return NULL;
    }
    if (min_width >= 0 || min_height >= 0) {
	geometry.min_width = MAX(min_width, 0);
	geometry.min_height = MAX(min_height, 0);
	geom_mask |= GDK_HINT_MIN_SIZE;
    }
    if (max_width >= 0 || max_height >= 0) {
	geometry.max_width = MAX(max_width, 0);
	geometry.max_height = MAX(max_height, 0);
	geom_mask |= GDK_HINT_MAX_SIZE;
    }
    if (base_width >= 0 || base_height >= 0) {
	geometry.base_width = MAX(base_width, 0);
	geometry.base_height = MAX(base_height, 0);
	geom_mask |= GDK_HINT_BASE_SIZE;
    }
    if (width_inc >= 0 || height_inc >= 0) {
	geometry.width_inc = MAX(width_inc, 0);
	geometry.height_inc = MAX(height_inc, 0);
	geom_mask |= GDK_HINT_RESIZE_INC;
    }
    if (min_aspect >= 0.0 || max_aspect >= 0.0) {
	if (min_aspect <= 0.0 || max_aspect <= 0.0) {
	    PyErr_SetString(PyExc_TypeError, "aspect ratios must be positive");
	    return NULL;
	}
	geometry.min_aspect = min_aspect;
	geometry.max_aspect = max_aspect;
	geom_mask |= GDK_HINT_ASPECT;
    }
    gtk_window_set_geometry_hints(GTK_WINDOW(self->obj), geometry_widget,
				  &geometry, geom_mask);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_box_query_child_packing kwargs
static PyObject *
_wrap_gtk_box_query_child_packing(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    gboolean expand, fill;
    guint padding;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkBox.query_child_packing", kwlist,
				     &child))
	return NULL;
    if (!pygobject_check(child, &PyGtkWidget_Type)) {
	PyErr_SetString(PyExc_TypeError, "first arg should be a GtkWidget");
	return NULL;
    }
    gtk_box_query_child_packing(GTK_BOX(self->obj),
				GTK_WIDGET(child->obj), &expand, &fill,
				&padding, &pack_type);
    return Py_BuildValue("(iiii)", (int)expand, (int)fill, padding, pack_type);
}
%%
ignore gtk_clist_new
%%
override gtk_clist_new_with_titles kwargs
static PyObject *
_wrap_gtk_clist_new_with_titles(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "count", "titles", NULL };
    int count, i;
    PyObject *py_list = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i|O:GtkCList.__init__",
				     kwlist, &count, &py_list))
	return NULL;
    if (py_list) {
	gchar **list;

	if (!PySequence_Check(py_list)) {
	    PyErr_SetString(PyExc_TypeError,"2nd argument not a sequence");
	    return NULL;
	}
	if (PySequence_Length(py_list) < count) {
	    PyErr_SetString(PyExc_TypeError, "sequence not long enough");
	    return NULL;
	}
	list = g_new(gchar *, count);
	for (i = 0; i < count; i++) {
	    PyObject *item = PySequence_GetItem(py_list, i);

	    Py_DECREF(item); /* PySequence_GetItem INCREF's */
	    if (!PyString_Check(item)) {
		PyErr_SetString(PyExc_TypeError, "sequence item not a string");
		g_free(list);
		return NULL;
	    }
	    list[i] = PyString_AsString(item);
	}
	self->obj = (GObject *)gtk_clist_new_with_titles(count, list);
	g_free(list);
    } else
	self->obj = (GObject *)gtk_clist_new(count);
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError,"could not create GtkCList object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clist_get_text kwargs
static PyObject *
_wrap_gtk_clist_get_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    char *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_text",
				     kwlist, &r, &c))
	return NULL;
    if (!gtk_clist_get_text(GTK_CLIST(self->obj), r, c, &text) || text==NULL) {
	PyErr_SetString(PyExc_ValueError, "can't get text value");
	return NULL;
    }
    return PyString_FromString(text);
}
%%
override gtk_clist_get_pixmap kwargs
static PyObject *
_wrap_gtk_clist_get_pixmap(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_pixmap",
				     kwlist, &r, &c))
	return NULL;
    if (!gtk_clist_get_pixmap(GTK_CLIST(self->obj), r, c,
			      &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixmap value");
	return NULL;
    }
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_clist_get_pixtext kwargs
static PyObject *
_wrap_gtk_clist_get_pixtext(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    gchar *text;
    guint8 spacing;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_pixtext",
				     kwlist, &r, &c))
	return NULL;
    if (!gtk_clist_get_pixtext(GTK_CLIST(self->obj), r, c,
			      &text, &spacing, &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixtext value");
	return NULL;
    }
    return Py_BuildValue("(ziNN)", text, (gint)spacing,
			 pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_clist_prepend kwargs
static PyObject *
_wrap_gtk_clist_prepend(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    int col, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCList.prepend",
				     kwlist, &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "sequence item not a string");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_prepend(GTK_CLIST(self->obj), list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_append kwargs
static PyObject *
_wrap_gtk_clist_append(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    int col, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCList.append",
				     kwlist, &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "sequence item not a string");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_append(GTK_CLIST(self->obj), list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_insert kwargs
static PyObject *
_wrap_gtk_clist_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "text", NULL };
    int col, row, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iO:GtkCList.insert",
				     kwlist, &row, &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "sequence item not a string");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_insert(GTK_CLIST(self->obj), row, list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_set_row_data kwargs
static PyObject *
_wrap_gtk_clist_set_row_data(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "row", "data", NULL };
    int row;
    PyObject *data;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iO:GtkCList.set_row_data",
				     kwlist, &row, &data))
	return NULL;
    Py_INCREF(data);
    gtk_clist_set_row_data_full(GTK_CLIST(self->obj), row, data,
				(GtkDestroyNotify)pygtk_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clist_get_row_data kwargs
static PyObject *
_wrap_gtk_clist_get_row_data(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "row", NULL };
    PyObject *ret;
    int row;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkCList.get_row_data",
				     kwlist, &row))
        return NULL;
    ret = gtk_clist_get_row_data(GTK_CLIST(self->obj), row);
    if (!ret) ret = Py_None;
    Py_INCREF(ret);
    return ret;
}
%%
override gtk_clist_find_row_from_data kwargs
static PyObject *
_wrap_gtk_clist_find_row_from_data(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "data", NULL };
    PyObject *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkCList.find_row_from_data", kwlist,
				     &data))
        return NULL;
    return PyInt_FromLong(gtk_clist_find_row_from_data(
				GTK_CLIST(self->obj), data));
}
%%
override gtk_clist_get_selection_info kwargs
static PyObject *
_wrap_gtk_clist_get_selection_info(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    gint x, y, row, column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "ii:GtkCList.get_selection_info", kwlist,
				     &x, &y))
	return NULL;
    if (gtk_clist_get_selection_info(GTK_CLIST(self->obj), x, y,
				     &row, &column))
	return Py_BuildValue("(ii)", row, column);
    else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}   
%%
override gtk_combo_set_popdown_strings kwargs
static PyObject *
_wrap_gtk_combo_set_popdown_strings(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "strings", NULL };
    PyObject *list;
    GList *glist = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkCombo.set_popdown_strings", kwlist,
				     &list))
	return NULL;
    if (!PySequence_Check(list)) {
	PyErr_SetString(PyExc_TypeError, "first argument must be a sequence");
	return NULL;
    }
    len = PySequence_Length(list);
    for (i = 0; i < len; i++) {
	PyObject *item = PySequence_GetItem(list, i);

	Py_DECREF(item);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "sequence item not a string");
	    g_list_free(glist);
	    return NULL;
	}
	glist = g_list_append(glist, PyString_AsString(item));
    }
    gtk_combo_set_popdown_strings(GTK_COMBO(self->obj), glist);
    g_list_free(glist);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_curve_get_vector kwargs
static PyObject *
_wrap_gtk_curve_get_vector(PyGObject *self, PyObject *args,
			   PyObject *kwargs)
{
    static char *kwlist[] = { "size", NULL };
    int size = -1, i;
    gfloat *vector;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|i:GtkCurve.get_vector", kwlist,
				     &size))
	return NULL;
    if (size < 0) size = GTK_CURVE(self->obj)->num_points;
    vector = g_new(gfloat, size);
    gtk_curve_get_vector(GTK_CURVE(self->obj), size, vector);
    ret = PyTuple_New(size);
    for (i = 0; i < size; i++)
	PyTuple_SetItem(ret, i, PyFloat_FromDouble(vector[i]));
    g_free(vector);
    return ret;
}
%%
override gtk_curve_set_vector kwargs
static PyObject *
_wrap_gtk_curve_set_vector(PyGObject *self, PyObject *args,
			   PyObject *kwargs)
{
    static char *kwlist[] = { "vector", NULL };
    PyObject *seq;
    int size, i;
    gfloat *vector;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCurve.set_vector",
				     kwlist, &seq))
	return NULL;
    if (!PySequence_Check(seq)) {
	PyErr_SetString(PyExc_TypeError, "1st argument is not a sequence");
	return NULL;
    }
    size = PySequence_Length(seq);
    vector = g_new(gfloat, size);
    for (i = 0; i < size; i++) {
	PyObject *item = PySequence_GetItem(seq, i);

	Py_DECREF(item);
	item = PyNumber_Float(item); /* item has a ref now */
	if (item == NULL) {
	    g_free(vector);
	    return NULL;
	}
	vector[i] = PyFloat_AsDouble(item);
	Py_DECREF(item);
    }
    gtk_curve_set_vector(GTK_CURVE(self->obj), size, vector);
    g_free(vector);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_drag_find_window kwargs
static PyObject *
_wrap_gdk_drag_find_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "drag_window", "x_root", "y_root", NULL };
    PyGObject *drag_window;
    gint x_root, y_root;
    GdkWindow *dest_window;
    GdkDragProtocol protocol;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oii:GdkDragContext.drag_find_window",
				     kwlist, &drag_window, &x_root, &y_root))
	return NULL;
    if (!pygobject_check(drag_window, &PyGdkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "drag_window must be a GdkWindow");
	return NULL;
    }
    gdk_drag_find_window(GDK_DRAG_CONTEXT(self->obj),
			 GDK_WINDOW(drag_window->obj), x_root, y_root,
			 &dest_window, &protocol);
    return Py_BuildValue("(Ni)", pygobject_new((GObject *)dest_window),
			 protocol);
}
%%
override-attr GdkDragContext.targets
PyObject *atom, *ret = PyList_New(0);
GList *tmp;
if (ret == NULL)
    return NULL;
for (tmp = GDK_DRAG_CONTEXT(self->obj)->targets; tmp; tmp = tmp->next) {
    if ((atom = PyGdkAtom_New(GPOINTER_TO_INT(tmp->data))) == NULL) {
	Py_DECREF(ret);
	return NULL;
    }
    PyList_Append(ret, atom);
    Py_DECREF(atom);
}
return ret;
%%
override gdk_gc_new_with_values kwargs
static PyObject *
_wrap_gdk_gc_new_with_values(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "foreground", "background", "font", "function",
			      "fill", "tile", "stipple", "clip_mask",
			      "subwindow_mode", "ts_x_origin", "ts_y_origin",
			      "clip_x_origin", "clip_y_origin",
			      "graphics_exposures", "line_width", "line_style",
			      "cap_style", "join_style", NULL };
    PyObject *foreground = Py_None, *background = Py_None;
    PyObject *font = Py_None;
    gint function = -1, fill = -1;
    PyObject *tile = Py_None, *stipple = Py_None, *clip_mask = Py_None;
    gint subwindow_mode = -1, ts_x_origin = -1, ts_y_origin = -1;
    gint clip_x_origin = -1, clip_y_origin = -1, graphics_exposures = -1;
    gint line_width = -1, line_style = -1, cap_style = -1, join_style = -1;
    GdkGCValues values;
    GdkGCValuesMask mask = 0;
    GdkGC *gc;
    PyObject *pygc;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|OOOiiOOOiiiiiiiiii:GdkDrawable.new_gc",
				     kwlist, &foreground, &background, &font,
				     &function, &fill, &tile, &stipple,
				     &clip_mask, &subwindow_mode,
				     &ts_x_origin, &ts_y_origin,
				     &clip_x_origin, &clip_y_origin,
				     &graphics_exposures, &line_width,
				     &line_style, &cap_style, &join_style))
	return NULL;
    if (pyg_boxed_check(foreground, GDK_TYPE_COLOR)) {
	mask |= GDK_GC_FOREGROUND;
	values.foreground = *pyg_boxed_get(foreground, GdkColor);
    } else if (foreground != Py_None) {
	PyErr_SetString(PyExc_TypeError, "foreground must be a GdkColor");
	return NULL;
    }
    if (pyg_boxed_check(background, GDK_TYPE_COLOR)) {
	mask |= GDK_GC_BACKGROUND;
	values.background = *pyg_boxed_get(background, GdkColor);
    } else if (background != Py_None) {
	PyErr_SetString(PyExc_TypeError, "background must be a GdkColor");
	return NULL;
    }
    if (pyg_boxed_check(font, GDK_TYPE_FONT)) {
	mask |= GDK_GC_FONT;
	values.font = pyg_boxed_get(font, GdkFont);
    } else if (font != Py_None) {
	PyErr_SetString(PyExc_TypeError, "font must be a GdkFont");
	return NULL;
    }
    if (function != -1) {
	mask |= GDK_GC_FUNCTION;
	values.function = function;
    }
    if (fill != -1) {
	mask |= GDK_GC_FILL;
	values.fill = fill;
    }
    if (pygobject_check(tile, &PyGdkPixmap_Type)) {
	mask |= GDK_GC_TILE;
	values.tile = GDK_PIXMAP(pygobject_get(tile));
    } else if (tile != Py_None) {
	PyErr_SetString(PyExc_TypeError, "tile must be a GdkPixmap");
	return NULL;
    }
    if (pygobject_check(stipple, &PyGdkPixmap_Type)) {
	mask |= GDK_GC_STIPPLE;
	values.stipple = GDK_PIXMAP(pygobject_get(stipple));
    } else if (stipple != Py_None) {
	PyErr_SetString(PyExc_TypeError, "stipple must be a GdkPixmap");
	return NULL;
    }
    if (pygobject_check(clip_mask, &PyGdkPixmap_Type)) {
	mask |= GDK_GC_CLIP_MASK;
	values.clip_mask = GDK_PIXMAP(pygobject_get(clip_mask));
    } else if (clip_mask != Py_None) {
	PyErr_SetString(PyExc_TypeError, "clip_mask must be a GdkPixmap");
	return NULL;
    }
    if (subwindow_mode != -1) {
	mask |= GDK_GC_SUBWINDOW;
	values.subwindow_mode = subwindow_mode;
    }
    if (ts_x_origin != -1) {
	mask |= GDK_GC_TS_X_ORIGIN;
	values.ts_x_origin = ts_x_origin;
    }
    if (ts_y_origin != -1) {
	mask |= GDK_GC_TS_Y_ORIGIN;
	values.ts_y_origin = ts_y_origin;
    }
    if (clip_x_origin != -1) {
	mask |= GDK_GC_CLIP_X_ORIGIN;
	values.clip_x_origin = clip_x_origin;
    }
    if (clip_y_origin != -1) {
	mask |= GDK_GC_CLIP_Y_ORIGIN;
	values.clip_y_origin = clip_y_origin;
    }
    if (graphics_exposures != -1) {
	mask |= GDK_GC_EXPOSURES;
	values.graphics_exposures = graphics_exposures;
    }
    if (line_width != -1) {
	mask |= GDK_GC_LINE_WIDTH;
	values.line_width = line_width;
    }
    if (line_style != -1) {
	mask |= GDK_GC_LINE_STYLE;
	values.line_style = line_style;
    }
    if (cap_style != -1) {
	mask |= GDK_GC_CAP_STYLE;
	values.cap_style = cap_style;
    }
    if (join_style != -1) {
	mask |= GDK_GC_JOIN_STYLE;
	values.join_style = join_style;
    }
    gc = gdk_gc_new_with_values(GDK_DRAWABLE(self->obj), &values, mask);
    pygc = pygobject_new((GObject *)gc);
    gdk_gc_unref(gc);
    return pygc;
}
%%
override gdk_drawable_get_size
static PyObject *
_wrap_gdk_drawable_get_size(PyGObject *self, PyObject *args)
{
    gint width;
    gint height;

    if (!PyArg_ParseTuple(args, ":GdkDrawable.get_size"))
	return NULL;
    gdk_drawable_get_size(GDK_DRAWABLE(self->obj), &width, &height);
    return Py_BuildValue("(ii)", width, height);
}
%%
override gdk_drag_begin kwargs
static PyObject *
_wrap_gdk_drag_begin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", NULL };
    PyObject *py_targets;
    GList *targets = NULL;
    guint i, len;
    GdkDragContext *context;
    PyObject *py_context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GdkWindow.drag_begin",
				     kwlist, &py_targets))
	return NULL;
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a list of ints");
	return NULL;
    }
    len = PySequence_Length(py_targets);
    for (i = 0; i < len; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);

	if (PyInt_Check(item)) {
	    targets = g_list_append(targets,
				    GUINT_TO_POINTER(PyInt_AsLong(item)));
	    Py_DECREF(item);
	} else {
	    PyErr_SetString(PyExc_TypeError, "targets must be a list of ints");
	    Py_DECREF(item);
	    g_list_free(targets);
	    return NULL;
	}
    }
    context = gdk_drag_begin(GDK_WINDOW(self->obj), targets);
    g_list_free(targets);
    py_context = pygobject_new((GObject *)context);
    gdk_drag_context_unref(context);
    return py_context;
}
%%
override gdk_property_get kwargs
static PyObject *
_wrap_gdk_property_get(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "property", "type", "pdelete", NULL };
    GdkAtom property, type = 0;
    gint pdelete = FALSE;

    GdkAtom atype;
    gint aformat, alength;
    guchar *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "i|ii:GdkWindow.property_get", kwlist,
				     &property, &type, &pdelete)) {
	gchar *propname;

	PyErr_Clear();
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "s|ii:GdkWindow.property_get", kwlist,
					 &propname, &type, &pdelete))
	    return NULL;
	property = gdk_atom_intern(propname, FALSE);
    }
    if (gdk_property_get(GDK_WINDOW(self->obj), property, type, 0, 9999,
			 pdelete, &atype, &aformat, &alength, &data)) {
	/* success */
	PyObject *pdata = NULL;
	gint i;
	guint16 *data16;
	guint32 *data32;
	switch (aformat) {
	case 8:
	    if ((pdata = PyString_FromStringAndSize(data, alength)) == NULL)
	        return NULL;
	    break;
	case 16:
	    data16 = (guint16 *)data;
	    if ((pdata = PyTuple_New(alength)) == NULL)
	        return NULL;
	    for (i = 0; i < alength; i++)
		PyTuple_SetItem(pdata, i, PyInt_FromLong(data16[i]));
	    break;
	case 32:
	    data32 = (guint32 *)data;
	    if ((pdata = PyTuple_New(alength)) == NULL)
	        return NULL;
	    for (i = 0; i < alength; i++)
		PyTuple_SetItem(pdata, i, PyInt_FromLong(data32[i]));
	    break;
	default:
	    g_warning("got a property format != 8, 16 or 32");
	    g_assert_not_reached();
	}
	g_free(data);
	return Py_BuildValue("(NiN)", PyGdkAtom_New(atype), aformat, pdata);
    } else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
override gdk_property_change kwargs
static PyObject *
_wrap_gdk_property_change(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "property","type","format","mode","data",NULL };
    GdkAtom property, type;
    gint format;
    PyObject *py_mode, *pdata;
    GdkPropMode mode;
    guchar *data = NULL;
    gint nelements;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "iiiOO:GdkWindow.property_change", kwlist,
				     &property, &type, &format, &py_mode,
				     &pdata)) {
	gchar *propname;

	PyErr_Clear();
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "siiOO:GdkWindow.property_change",
					 kwlist, &propname, &type, &format,
					 &py_mode, &pdata))
	    return NULL;
	property = gdk_atom_intern(propname, FALSE);
    }
    if (pyg_enum_get_value(GDK_TYPE_PROP_MODE, py_mode, (gint *)&mode))
	return NULL;
    switch (format) {
    case 8:
	if (!PyString_Check(pdata)) {
	    PyErr_SetString(PyExc_TypeError, "data not a string and format=8");
	    return NULL;
	}
	data = PyString_AsString(pdata);
	nelements = PyString_Size(pdata);
	break;
    case 16:
	{
	    guint16 *data16;
	    gint i;

	    if (!PySequence_Check(pdata)) {
		PyErr_SetString(PyExc_TypeError,
				"data not a sequence and format=16");
		return NULL;
	    }
	    nelements = PySequence_Length(pdata);
	    data16 = g_new(guint16, nelements);
	    data = (guchar *)data16;
	    for (i = 0; i < nelements; i++) {
		PyObject *item = PySequence_GetItem(pdata, i);
		Py_DECREF(item);
		item = PyNumber_Int(item);
		if (!item) {
		    g_free(data16);
		    PyErr_Clear();
		    PyErr_SetString(PyExc_TypeError,"data element not an int");
		    return NULL;
		}
		data16[i] = PyInt_AsLong(item);
		Py_DECREF(item);
	    }
	}
	break;
    case 32:
	{
	    guint32 *data32;
	    gint i;

	    if (!PySequence_Check(pdata)) {
		PyErr_SetString(PyExc_TypeError,
				"data not a sequence and format=32");
		return NULL;
	    }
	    nelements = PySequence_Length(pdata);
	    data32 = g_new(guint32, nelements);
	    data = (guchar *)data32;
	    for (i = 0; i < nelements; i++) {
		PyObject *item = PySequence_GetItem(pdata, i);
		Py_DECREF(item);
		item = PyNumber_Int(item);
		if (!item) {
		    g_free(data32);
		    PyErr_Clear();
		    PyErr_SetString(PyExc_TypeError,"data element not an int");
		    return NULL;
		}
		data32[i] = PyInt_AsLong(item);
		Py_DECREF(item);
	    }
	}
	break;
    default:
	PyErr_SetString(PyExc_TypeError, "format must be 8, 16 or 32");
	return NULL;
	break;
    }
    gdk_property_change(GDK_WINDOW(self->obj), property, type, format, mode,
			data, nelements);
    if (format != 8)
	g_free(data);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_window_get_geometry
static PyObject *
_wrap_gdk_window_get_geometry(PyGObject *self, PyObject *args)
{
    gint x, y, width, height, depth;

    if (!PyArg_ParseTuple(args, ":GdkWindow.get_geometry"))
	return NULL;
    gdk_window_get_geometry(GDK_WINDOW(self->obj), &x, &y, &width, &height,
			    &depth);
    return Py_BuildValue("(iiiii)", x, y, width, height, depth);
}
%%
override gdk_window_get_position
static PyObject *
_wrap_gdk_window_get_position(PyGObject *self, PyObject *args)
{
    gint x, y;

    if (!PyArg_ParseTuple(args, ":GdkWindow.get_position"))
	return NULL;
    gdk_window_get_position(GDK_WINDOW(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gdk_window_get_origin
static PyObject *
_wrap_gdk_window_get_origin(PyGObject *self, PyObject *args)
{
    gint x, y;

    if (!PyArg_ParseTuple(args, ":GdkWindow.get_origin"))
	return NULL;
    gdk_window_get_origin(GDK_WINDOW(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gdk_window_get_deskrelative_origin
static PyObject *
_wrap_gdk_window_get_deskrelative_origin(PyGObject *self, PyObject *args)
{
    gint x, y;

    if (!PyArg_ParseTuple(args, ":GdkWindow.get_deskrelative_origin"))
	return NULL;
    gdk_window_get_deskrelative_origin(GDK_WINDOW(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gdk_window_get_root_origin
static PyObject *
_wrap_gdk_window_get_root_origin(PyGObject *self, PyObject *args)
{
    gint x, y;

    if (!PyArg_ParseTuple(args, ":GdkWindow.get_root_origin"))
	return NULL;
    gdk_window_get_root_origin(GDK_WINDOW(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gdk_window_get_pointer
static PyObject *
_wrap_gdk_window_get_pointer(PyGObject *self, PyObject *args)
{
    gint x, y;
    GdkModifierType mask;

    if (!PyArg_ParseTuple(args, ":GdkWindow.get_pointer"))
	return NULL;
    gdk_window_get_pointer(GDK_WINDOW(self->obj), &x, &y, &mask);
    return Py_BuildValue("(iii)", x, y, (gint)mask);
}
%%
override gdk_window_get_children
static PyObject *
_wrap_gdk_window_get_children(PyGObject *self, PyObject *args)
{
    GList *children, *tmp;
    PyObject *list;

    if (!PyArg_ParseTuple(args, ":GdkWindow.get_children"))
	return NULL;
    children = gdk_window_get_children(GDK_WINDOW(self->obj));
    list = PyList_New(0);
    for (tmp = children; tmp != NULL; tmp = tmp->next) {
	PyObject *item = pygobject_new((GObject *)tmp->data);

	PyList_Append(list, item);
	Py_DECREF(item);
    }
    g_list_free(children);
    return list;
}
%%
override gtk_tree_model_get_iter
static PyObject *
_wrap_gtk_tree_model_get_iter(PyGObject *self, PyObject *args) {
    GtkTreeIter iter;
    GtkTreePath *path;

    path = pygtk_tree_path_from_pyobject(args);
    if (!path) {
	PyErr_SetString(PyExc_TypeError, "GtkTreeModel.get_iter requires at least one integer argument");
	return NULL;
    }
    if (gtk_tree_model_get_iter(GTK_TREE_MODEL(self->obj), &iter, path)) {
	gtk_tree_path_free(path);
	return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    } else {
	gtk_tree_path_free(path);
	PyErr_SetString(PyExc_ValueError, "invalid tree path");
	return NULL;
    }
}
%%
override gtk_tree_model_get_value kwargs
static PyObject *
_wrap_gtk_tree_model_get_value(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    static char *kwlist[] = { "iter", "column", "value", NULL };
    PyObject *iter, *ret;
    gint column;
    GValue value = { 0, };

    if (!PyArg_ParseTupleAndKeywords(args,kwargs, "Oi:GtkTreeModel.get_value",
				     kwlist, &iter, &column))
	return NULL;
    if (column < 0 ||
	column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	PyErr_SetString(PyExc_ValueError, "column number is out of range");
	return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    gtk_tree_model_get_value(GTK_TREE_MODEL(self->obj),
			     pyg_boxed_get(iter, GtkTreeIter), column, &value);
    ret = pyg_value_as_pyobject(&value);
    g_value_unset(&value);
    return ret;
}
%%
ignore gtk_list_store_newv
%%
override gtk_list_store_new
static PyObject *
_wrap_gtk_list_store_new(PyGObject *self, PyObject *args)
{
    guint len, i;
    GType *column_types;

    len = PyTuple_Size(args);
    column_types = g_new(GType, len);
    for (i = 0; i < len; i++) {
	PyObject *item = PyTuple_GetItem(args, i);

	column_types[i] = pyg_type_from_object(item);
	if (column_types[i] == 0) {
	    g_free(column_types);
	    return NULL;
	}
    }
    self->obj = (GObject *)gtk_list_store_newv(len, column_types);
    g_free(column_types);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkListStore object");
        return NULL;
    }
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_store_set_value kwargs
static PyObject *
_wrap_gtk_list_store_set_value(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "column", "value", NULL };
    PyObject *iter, *pyvalue;
    gint column;
    GValue value = { 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OiO:GtkListStore.set_value",
				     kwlist, &iter, &column, &pyvalue))
	return NULL;
    if (column < 0 ||
	column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	PyErr_SetString(PyExc_ValueError, "column number is out of range");
	return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    g_value_init(&value, GTK_LIST_STORE(self->obj)->column_headers[column]);
    if (pyg_value_from_pyobject(&value, pyvalue)) {
	PyErr_SetString(PyExc_TypeError,
			"value is of the wrong type for this column");
	return NULL;
    }
    gtk_list_store_set_value(GTK_LIST_STORE(self->obj),
			     pyg_boxed_get(iter, GtkTreeIter), column, &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_store_insert kwargs
static PyObject *
_wrap_gtk_list_store_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", NULL };
    GtkTreeIter iter;
    gint position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkListStore.insert",
				     kwlist, &position))
	return NULL;
    gtk_list_store_insert(GTK_LIST_STORE(self->obj), &iter, position);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_insert_before kwargs
static PyObject *
_wrap_gtk_list_store_insert_before(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "sibling", NULL };
    PyObject *sibling;
    GtkTreeIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkListStore.insert_before",
				     kwlist, &sibling))
	return NULL;
    if (!pyg_boxed_check(sibling, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    gtk_list_store_insert_before(GTK_LIST_STORE(self->obj), &iter,
				 pyg_boxed_get(sibling, GtkTreeIter));
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_insert_after kwargs
static PyObject *
_wrap_gtk_list_store_insert_after(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "sibling", NULL };
    PyObject *sibling;
    GtkTreeIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkListStore.insert_after",
				     kwlist, &sibling))
	return NULL;
    if (!pyg_boxed_check(sibling, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    gtk_list_store_insert_after(GTK_LIST_STORE(self->obj), &iter,
				pyg_boxed_get(sibling, GtkTreeIter));
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_prepend
static PyObject *
_wrap_gtk_list_store_prepend(PyGObject *self, PyObject *args)
{
    GtkTreeIter iter;

    if (!PyArg_ParseTuple(args, ":GtkListStore.prepend"))
	return NULL;
    gtk_list_store_prepend(GTK_LIST_STORE(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_append
static PyObject *
_wrap_gtk_list_store_append(PyGObject *self, PyObject *args)
{
    GtkTreeIter iter;

    if (!PyArg_ParseTuple(args, ":GtkListStore.append"))
	return NULL;
    gtk_list_store_append(GTK_LIST_STORE(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
ignore gtk_tree_store_newv
%%
override gtk_tree_store_new
static PyObject *
_wrap_gtk_tree_store_new(PyGObject *self, PyObject *args)
{
    guint len, i;
    GType *column_types;

    len = PyTuple_Size(args);
    column_types = g_new(GType, len);
    for (i = 0; i < len; i++) {
	PyObject *item = PyTuple_GetItem(args, i);

	column_types[i] = pyg_type_from_object(item);
	if (column_types[i] == 0) {
	    g_free(column_types);
	    return NULL;
	}
    }
    self->obj = (GObject *)gtk_tree_store_newv(len, column_types);
    g_free(column_types);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkTreeStore object");
        return NULL;
    }
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_store_set_value kwargs
static PyObject *
_wrap_gtk_tree_store_set_value(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "column", "value", NULL };
    PyObject *iter, *pyvalue;
    gint column;
    GValue value = { 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OiO:GtkTreeStore.set_value",
				     kwlist, &iter, &column, &pyvalue))
	return NULL;
    if (column < 0 ||
	column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	PyErr_SetString(PyExc_ValueError, "column number is out of range");
	return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    g_value_init(&value, GTK_TREE_STORE(self->obj)->column_headers[column]);
    if (pyg_value_from_pyobject(&value, pyvalue)) {
	PyErr_SetString(PyExc_TypeError,
			"value is of the wrong type for this column");
	return NULL;
    }
    gtk_tree_store_set_value(GTK_TREE_STORE(self->obj),
			     pyg_boxed_get(iter, GtkTreeIter), column, &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore
  gtk_tree_store_set
  gtk_tree_store_setv
  gtk_tree_store_get
  gtk_tree_store_getv
%%
override gtk_tree_store_insert kwargs
static PyObject *
_wrap_gtk_tree_store_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "position", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;
    gint position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oi:GtkTreeStore.insert",
				     kwlist, &py_parent, &position))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_insert(GTK_TREE_STORE(self->obj), &iter, parent, position);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_insert_before kwargs
static PyObject *
_wrap_gtk_tree_store_insert_before(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", NULL };
    PyObject *py_parent, *py_sibling;
    GtkTreeIter iter, *parent = NULL, *sibling = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkTreeStore.insert_before",
				     kwlist, &py_parent, &py_sibling))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    if (pyg_boxed_check(py_sibling, GTK_TYPE_TREE_ITER))
	sibling = pyg_boxed_get(py_sibling, GtkTreeIter);
    else if (py_sibling != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sibling must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_insert_before(GTK_TREE_STORE(self->obj), &iter, parent,
				 sibling);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_insert_after kwargs
static PyObject *
_wrap_gtk_tree_store_insert_after(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", NULL };
    PyObject *py_parent, *py_sibling;
    GtkTreeIter iter, *parent = NULL, *sibling = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkTreeStore.insert_after",
				     kwlist, &py_parent, &py_sibling))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    if (pyg_boxed_check(py_sibling, GTK_TYPE_TREE_ITER))
	sibling = pyg_boxed_get(py_sibling, GtkTreeIter);
    else if (py_sibling != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sibling must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_insert_after(GTK_TREE_STORE(self->obj), &iter, parent,
				sibling);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_prepend kwargs
static PyObject *
_wrap_gtk_tree_store_prepend(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTreeStore.prepend",
				     kwlist, &py_parent))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_append kwargs
static PyObject *
_wrap_gtk_tree_store_append(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTreeStore.append",
				     kwlist, &py_parent))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_get_root_iter
static PyObject *
_wrap_gtk_tree_store_get_root_iter(PyGObject *self, PyObject *args)
{
    GtkTreeIter iter;

    if (!PyArg_ParseTuple(args, ":GtkTreeStore.get_root_iter"))
	return NULL;
    gtk_tree_store_get_root_iter(GTK_TREE_STORE(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
ignore
  gtk_tree_view_new
  gtk_tree_view_column_new_with_attributes
%%
override gtk_tree_view_column_new kwargs
static PyObject *
_wrap_gtk_tree_view_column_new(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    PyObject *py_cell = NULL, *key, *item;
    GtkTreeViewColumn *tvc;
    gchar *title = NULL;
    GtkCellRenderer *cell = NULL;
    gint i = 0;

    if (!PyArg_ParseTuple(args, "|zO:GtkTreeViewColumn.__init__", &title,
			  &py_cell))
	return NULL;
    if (py_cell != NULL) {
	if (pygobject_check(py_cell, &PyGtkCellRenderer_Type))
	    cell = GTK_CELL_RENDERER(pygobject_get(py_cell));
	else if (py_cell != Py_None) {
	    PyErr_SetString(PyExc_TypeError,
			    "cell must be a GtkCellRenderer or None");
	    return NULL;
	}
    }
    tvc = gtk_tree_view_column_new();
    if (title)
	gtk_tree_view_column_set_title(tvc, title);
    if (cell)
	gtk_tree_view_column_set_cell_renderer(tvc, cell);
    if (kwargs) {
	while (PyDict_Next(kwargs, &i, &key, &item)) {
	    gchar *attr = PyString_AsString(key);

	    if (!PyInt_Check(item)) {
		gchar err[128];
		g_snprintf(err, sizeof(err),
			   "%s must be an integer column number", attr);
		PyErr_SetString(PyExc_TypeError, err);
		g_object_unref(G_OBJECT(tvc));
		return NULL;
	    }
	    gtk_tree_view_column_add_attribute(tvc, cell, attr,
					       PyInt_AsLong(item));
	}
    }
    self->obj = (GObject *)tvc;
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_view_get_path_at_pos kwargs
static PyObject *
_wrap_gtk_tree_view_get_path_at_pos(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "window", "x", "y", NULL };
    PyGObject *window;
    gint x, y;
    GtkTreePath *path;
    GtkTreeViewColumn *column;
    gint cell_x, cell_y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oii:GtkTreeView.get_path_at_pos",
				     kwlist, &window, &x, &y))
	return NULL;
    if (!pygobject_check(window, &PyGdkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "window must be a GdkWindow");
	return NULL;
    }
    if (gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(self->obj),
				      GDK_WINDOW(window->obj), x, y,
				      &path, &column, &cell_x, &cell_y)) {
	PyObject *ret = PyTuple_New(4);

	if (path) {
	    PyTuple_SetItem(ret, 0, pygtk_tree_path_to_pyobject(path));
	    gtk_tree_path_free(path);
	} else {
	    Py_INCREF(Py_None);
	    PyTuple_SetItem(ret, 0, Py_None);
	}
	PyTuple_SetItem(ret, 1, pygobject_new((GObject *)column));
	PyTuple_SetItem(ret, 2, PyInt_FromLong(cell_x));
	PyTuple_SetItem(ret, 3, PyInt_FromLong(cell_y));
	return ret;
    } else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
override gtk_tree_selection_get_selected
static PyObject *
_wrap_gtk_tree_selection_get_selected(PyGObject *self, PyObject *args)
{
    GtkTreeModel *model;
    GtkTreeIter iter;

    if (!PyArg_ParseTuple(args, ":GtkTreeSelection.get_selected"))
	return NULL;
    if (gtk_tree_selection_get_selected(GTK_TREE_SELECTION(self->obj),
					&model, &iter))
	return Py_BuildValue("(NN)", pygobject_new((GObject *)model),
			     pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter,
					   TRUE, TRUE));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_binding_entry_add_signal

static PyObject *
_wrap_gtk_binding_entry_add_signal(PyGObject *self, PyObject *args)
{
    PyObject *first;
    gint len, i;
    PyObject *class;
    guint keyval, modifiers;
    gchar *signal_name;
    GType class_type;
    GtkBindingSet *bset = NULL;
    GSList *slist = NULL;
    gchar *errmsg;

    len = PyTuple_Size(args);
    if (len < 4) {
	PyErr_SetString(PyExc_TypeError, "binding_entry_add_signal requires at"
			" least 4 arguments");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 4);
    if (!PyArg_ParseTuple(first, "Oiis:binding_entry_add_signal", &class,
			  &keyval, &modifiers, &signal_name)) {
	Py_DECREF(first);
	return NULL;
    }
    Py_DECREF(first);

    class_type = pyg_type_from_object(class);
    if (class_type == 0)
	return NULL;

    bset = gtk_binding_set_by_class(gtk_type_class(class_type));

    /* extra args */
    if ((len-4)%2) {
	PyErr_SetString(PyExc_ValueError,
			"GtkBindingSet.add_signal requires an even number"
			" of parameter pairs following the first four args");
	return NULL;
    }
    for (i=4; i < len; i+=2) {
	PyObject *item;
	GType arg_type;
	GtkBindingArg *arg = NULL;

	item = PyTuple_GET_ITEM(args, i);
	arg_type = pyg_type_from_object(item);
	if (!arg_type) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "GtkBindingSet.add_signal parameter types"
			    " must be int");
	    goto arg_error;
	}
	arg = g_new0 (GtkBindingArg, 1);
	slist = g_slist_prepend(slist, arg);
    
	arg->arg_type = arg_type;
	switch (GTK_FUNDAMENTAL_TYPE(arg->arg_type)) {
	case GTK_TYPE_CHAR:
	case GTK_TYPE_UCHAR:
	case GTK_TYPE_INT:
	case GTK_TYPE_UINT:
	case GTK_TYPE_BOOL:
	case GTK_TYPE_ENUM:
	case GTK_TYPE_FLAGS:
	case GTK_TYPE_LONG:
	case GTK_TYPE_ULONG:
	    arg->arg_type = GTK_TYPE_LONG;
	    item = PyTuple_GET_ITEM(args, i+1);
	    if (!PyInt_Check(item)) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal "
					 "arg[%u] must be int", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    arg->d.long_data = (glong)PyInt_AsLong(item);
	    break;
	case GTK_TYPE_FLOAT:
	case GTK_TYPE_DOUBLE:
	    arg->arg_type = GTK_TYPE_DOUBLE;
	    item = PyTuple_GET_ITEM(args, i+1);
	    if (!PyFloat_Check(item)) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal "
					 "arg[%u] must be float", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    arg->d.long_data = (gdouble)PyFloat_AsDouble(item);
	    break;
	case GTK_TYPE_STRING:
	    arg->arg_type = GTK_TYPE_STRING;
	    if (arg->arg_type != GTK_TYPE_IDENTIFIER)
		arg->arg_type = GTK_TYPE_STRING;
	    item = PyTuple_GET_ITEM(args, i+1);
	    if (!PyString_Check(item)) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
					 "must be non-empty string", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    arg->d.string_data = (gchar*)PyString_AsString(item);
	    if (!arg->d.string_data) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
					 "must be non-empty string", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    break;
	default:
	    errmsg = g_strdup_printf("GtkBindingSet.add_signal unsupported "
				     "type %10s for arg[%u]",
				     gtk_type_name(arg->arg_type), i+1);
	    PyErr_SetString(PyExc_TypeError, errmsg);
	    g_free(errmsg);
	    goto arg_error;
	} /* switch */
    }

    slist = g_slist_reverse (slist);
    gtk_binding_entry_add_signall (bset, keyval,modifiers, signal_name, slist);

    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);

    Py_INCREF(Py_None);
    return Py_None;

arg_error:
    if (slist) {
	g_slist_foreach(slist, (GFunc)g_free, NULL);
	g_slist_free(slist);
    }
    return NULL;
}

/* -------------- haven't updated stuff below this line -------------- */
%%
ignore-glob
  *_get_type
  gtk_marshal_*
  gtk_arg_*
  gtk_args_*
  gtk_signal_connect*
  gtk_signal_add_emission_hook*
  gtk_signal_new*
  gtk_draw_*
  gtk_paint_*
  gtk_init_add_*
  gtk_quit_add_*
  gtk_timeout_add_*
  gtk_idle_add_*
  gtk_accelerator_*
  gtk_target_list_*
  gtk_pattern_*
  gtk_gc_*
  gtk_signal_*
  gtk_tree_path_*
%%
ignore
  gtk_binding_set_new
  gtk_binding_set_by_class
  gtk_binding_set_find
  gtk_binding_set_clear
  gtk_init
  gtk_init_check
  gtk_exit
  gtk_set_locale
  gtk_accel_group_ref
  gtk_accel_group_unref
  gtk_accel_groups_activate
  gtk_accel_group_activate
  gtk_accel_group_attach
  gtk_accel_group_detach
  gtk_accel_group_get_entry
  gtk_accel_group_lock_entry
  gtk_accel_group_unlock_entry
  gtk_accel_group_add
  gtk_accel_group_remove
  gtk_accel_group_handle_add
  gtk_accel_group_handle_remove
  gtk_accel_group_create_add
  gtk_accel_group_create_remove
  gtk_accel_groups_from_object
  gtk_accel_group_entries_from_object
  gtk_signal_set_funcs
  gtk_signal_lookup
  gtk_signal_disconnect_by_func
  gtk_signal_disconnect_by_data
  gtk_signal_handler_block_by_func
  gtk_signal_handler_block_by_data
  gtk_signal_handler_unblock_by_func
  gtk_signal_handler_unblock_by_data
  gtk_signal_handler_pending_by_func
  gtk_signal_n_emissions
  gtk_signal_n_emissions_by_name
  gtk_signal_name
  gtk_signal_remove_emission_hook
  gtk_signal_query
  gtk_signal_emit
  gtk_signal_emit_by_name
  gtk_signal_emitv
  gtk_signal_emitv_by_name
  gtk_quit_remove_by_data
  gtk_idle_remove_by_data
  gtk_object_weakref
  gtk_object_weakunref
  gtk_object_get
  gtk_object_getv
  gtk_object_set
  gtk_object_setv
  gtk_object_set_data
  gtk_object_set_data_full
  gtk_object_get_data
  gtk_object_set_user_data
  gtk_object_get_user_data
  gtk_object_set_data_by_id
  gtk_object_set_data_by_id_full
  gtk_object_get_data_by_id
  gtk_object_remove_data_by_id
  gtk_object_remove_no_notify_by_id
  gtk_object_arg_set
  gtk_object_arg_get
  gtk_trace_referencing
  gtk_widget_get
  gtk_widget_getv
  gtk_widget_set
  gtk_widget_setv
  gtk_container_get_toplevels
  gtk_container_add_child_arg_type
  gtk_container_query_child_args
  gtk_container_child_args_collect
  gtk_container_child_arg_get_info
  gtk_container_foreach
  gtk_container_foreach_full
  gtk_container_forall
  gtk_container_child_getv
  gtk_container_child_setv
  gtk_container_add_with_args
  gtk_container_addv
  gtk_container_child_set
  gtk_container_arg_set
  gtk_container_arg_get
  gtk_progress_bar_new
  gtk_clist_set_row_data_full
  gtk_window_add_embedded_xid
  gtk_window_remove_embedded_xid
  gtk_range_trough_click
  gtk_range_default_htrough_click
  gtk_range_default_vtrough_click
  gtk_tooltips_data_get
  gtk_type_check_object_cast
  gtk_type_check_class_cast
  gtk_type_register_enum
  gtk_type_register_flags
  gtk_preview_uninit
  gtk_item_factory_create_item
  gtk_item_factory_delete_entry
  gtk_item_factory_delete_entries
  gtk_item_factory_popup_with_data
  gtk_item_factory_popup_data
  gtk_item_factory_set_translate_func
  gtk_item_factory_create_items_ac
  gtk_item_factory_create_menu_entries
  gtk_menu_attach_to_widget
  gtk_radio_menu_item_group
  gtk_radio_menu_item_set_group
  gtk_radio_button_group
  gtk_radio_button_set_group
%%
ignore gtk_object_new gtk_object_newv gtk_object_query_args
  gtk_object_add_arg_type gtk_object_args_collect gtk_object_arg_get_info
  gtk_widget_new gtk_widget_newv
%%
ignore gtk_true gtk_false gtk_key_snooper_install gtk_key_snooper_remove
  gtk_get_current_event gtk_get_event_widget gtk_propagate_event
%%
override gtk_main
static PyObject *
_wrap_gtk_main(PyObject *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, ":main"))
	return NULL;

    pygtk_unblock_threads();
    gtk_main();
    pygtk_block_threads();
    if (PyErr_Occurred())
	return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_main_iteration kwargs
static PyObject *
_wrap_gtk_main_iteration(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"block", NULL};
    int block = 1, ret;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:main_iteration", kwlist,
				    &block)) 
        return NULL;
    pygtk_unblock_threads();
    ret = gtk_main_iteration_do(block);
    pygtk_block_threads();
    return PyInt_FromLong(ret);
}
%%
override gtk_timeout_add
static PyObject *
_wrap_gtk_timeout_add(PyObject *self, PyObject *args)
{
    guint32 interval;
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 2) {
	PyErr_SetString(PyExc_TypeError,
			"timeout_add requires at least 2 args");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "iO:timeout_add", &interval, &callback)) {
	Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "second arg not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 2, len);

    if (cbargs == NULL)
      return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_timeout_add_full(interval, NULL,
        (GtkCallbackMarshal)pygtk_handler_marshal,
        data, (GtkDestroyNotify)pygtk_destroy_notify));
}
%%
override gtk_idle_add
static PyObject *
_wrap_gtk_idle_add(PyObject *self, PyObject *args)
{
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 1) {
	PyErr_SetString(PyExc_TypeError,
			"idle_add requires at least 1 arg");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 1);
    if (!PyArg_ParseTuple(first, "O:idle_add", &callback)) {
	Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "first arg not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 1, len);

    if (cbargs == NULL)
      return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_idle_add_full(GTK_PRIORITY_DEFAULT, NULL,
        (GtkCallbackMarshal)pygtk_handler_marshal,
        data, (GtkDestroyNotify)pygtk_destroy_notify));
}
%%
override gtk_quit_add
static PyObject *
_wrap_gtk_quit_add(PyObject *self, PyObject *args)
{
    gint main_level;
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 2) {
	PyErr_SetString(PyExc_TypeError,
			"quit_add requires at least 2 args");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "iO:quit_add", &main_level, &callback)) {
	Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "second arg not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 2, len);

    if (cbargs == NULL)
      return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_quit_add_full(main_level, NULL,
        (GtkCallbackMarshal)pygtk_handler_marshal,
        data, (GtkDestroyNotify)pygtk_destroy_notify));
}
%%
override gtk_input_add_full kwargs
static PyObject *
_wrap_gtk_input_add_full(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "source", "condition", "callback", NULL };
    int source;
    GdkInputCondition condition;
    PyObject *callback;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iiO:input_add", kwlist,
				     &source, &condition, &callback))
        return NULL;
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "3rd arg not callable.");
        return NULL;
    }
    Py_INCREF(callback);
    return PyInt_FromLong(gtk_input_add_full(source, condition, NULL,
			(GtkCallbackMarshal)pygtk_input_marshal, callback,
			(GtkDestroyNotify)pygtk_destroy_notify));
}
%%
override gtk_editable_insert_text kwargs
static PyObject *
_wrap_gtk_editable_insert_text(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;
    int len, pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s#:GtkEditable.insert_text",
				     kwlist, &text, &len))
        return NULL;
    gtk_editable_insert_text(GTK_EDITABLE(self->obj), text, len, &pos);
    return PyInt_FromLong(pos);
}
%%
override gtk_item_factory_create_items kwargs
static void
pygtk_item_factory_cb(PyObject *callback, guint action, GtkWidget *widget)
{
    PyObject *ret;

    pygtk_block_threads();
    ret = PyObject_CallFunction(callback, "iO", action,
				pygobject_new((GObject *)widget));
    if (ret == NULL) {
	if (PyGtk_FatalExceptions)
	    gtk_main_quit();
	else {
	    PyErr_Print();
	    PyErr_Clear();
	}
    } else
	Py_DECREF(ret);
    pygtk_unblock_threads();
}
static PyObject *
_wrap_gtk_item_factory_create_items(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "entries", NULL };
    PyObject *list, *cb;
    GtkItemFactoryEntry ent;
    GtkItemFactory *ifact;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkItemFactory.create_items", kwlist,
				     &PyList_Type, &list))
	return NULL;
    ifact = GTK_ITEM_FACTORY(self->obj);
    len = PyList_Size(list);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(list, i);

	if (!PyArg_ParseTuple(item, "zzOiz", &(ent.path), &(ent.accelerator),
			      &cb, &(ent.callback_action), &(ent.item_type)))
	    return NULL;
	if (cb == Py_None)
	    ent.callback = NULL;
	else {
	    Py_INCREF(cb);
	    ent.callback = (GtkItemFactoryCallback)pygtk_item_factory_cb;
	}
	gtk_item_factory_create_item(ifact, &ent, cb, 1);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_menu_popup kwargs
static void
pygtk_menu_position(GtkMenu *menu, int *x, int *y, PyObject *func)
{
    PyObject *ret;

    pygtk_block_threads();
    ret = PyObject_CallFunction(func, "Oii", pygobject_new((GObject *)menu),
                                *x, *y);
    if (ret == NULL || !PyArg_ParseTuple(ret, "ii", x, y)) {
        if (PyGtk_FatalExceptions)
            gtk_main_quit();
        else {
            PyErr_Print();
            PyErr_Clear();
        }
        if (ret) {
          Py_DECREF(ret);
        }
    } else {
        Py_DECREF(ret);
    }
    pygtk_unblock_threads();
}
static PyObject *
_wrap_gtk_menu_popup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent_menu_shell", "parent_menu_item", "func",
		       "button", "activate_time", NULL };
    PyGObject *py_pms, *py_pmi;
    GtkWidget *pms = NULL, *pmi = NULL;
    PyObject *func;
    int button, time;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,  "OOOii:GtkMenu.popup",
				     kwlist, &py_pms, &py_pmi, &func,
				     &button, &time))
        return NULL;
    if (pygobject_check(py_pms, &PyGtkWidget_Type))
        pms = GTK_WIDGET(py_pms->obj);
    else if ((PyObject *)py_pms != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_pmi, &PyGtkWidget_Type))
        pmi = GTK_WIDGET(py_pmi->obj);
    else if ((PyObject *)py_pmi != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (!PyCallable_Check(func) && func != Py_None) {
        PyErr_SetString(PyExc_TypeError, "third argument not callable");
        return NULL;
    }
    if (func != Py_None) {
	Py_INCREF(func);
	gtk_menu_popup(GTK_MENU(self->obj), pms, pmi,
		       (GtkMenuPositionFunc)pygtk_menu_position,
		       func, button, time);
    } else
	gtk_menu_popup(GTK_MENU(self->obj), pms, pmi, NULL,NULL, button,time);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_pixmap_get
static PyObject *
_wrap_gtk_pixmap_get(PyGObject *self, PyObject *args)
{
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTuple(args, ":GtkPixmap.get"))
	return NULL;
    gtk_pixmap_get(GTK_PIXMAP(self->obj), &pixmap, &mask);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}

%%
ignore gtk_button_new_with_label gtk_button_new_from_stock gtk_button_new_with_mnemonic
%%
override gtk_button_new kwargs
static PyObject *
_wrap_gtk_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", "stock", NULL };
    gchar *text = NULL, *stock = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|zz:GtkButton.__init__",
				     kwlist, &text, &stock))
	return NULL;
    if (stock)
	self->obj = (GObject *)gtk_button_new_from_stock(stock);
    else if (text)
	self->obj = (GObject *)gtk_button_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkButton object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_toggle_button_new_with_label gtk_toggle_button_new_with_mnemonic
%%
override gtk_toggle_button_new kwargs
static PyObject *
_wrap_gtk_toggle_button_new(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|z:GtkToggleButton.__init__", kwlist,
				     &text))
	return NULL;
    if (text)
	self->obj = (GObject *)gtk_toggle_button_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_toggle_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkToggleButton object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_check_button_new_with_label gtk_check_button_new_with_mnemonic
%%
override gtk_check_button_new kwargs
static PyObject *
_wrap_gtk_check_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|z:GtkCheckButton.__init__",
				     kwlist, &text))
	return NULL;
    if (text)
	self->obj = (GObject *)gtk_check_button_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_check_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkCheckButton object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore-glob gtk_radio_button_new_*
%%
override gtk_radio_button_new kwargs
static PyObject *
_wrap_gtk_radio_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "group", "label", NULL };
    PyObject *py_group = Py_None;
    gchar *label = NULL;
    GtkRadioButton *group;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,"|Oz:GtkRadioButton.__init__",
				     kwlist, &py_group, &label))
	return NULL;
    if (py_group == Py_None)
	group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioButton_Type))
	group = GTK_RADIO_BUTTON(pygobject_get(py_group));
    else {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a GtkRadioButton or None");
	return NULL;
    }
    /* various configs for create radio buttons ... */
    if (label == NULL) {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_button_new(NULL);
	else
	    self->obj = (GObject *)gtk_radio_button_new(group->group);
    } else {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_button_new_with_mnemonic(NULL,label);
	else
	    self->obj = (GObject *)gtk_radio_button_new_with_mnemonic
		(group->group, label);
    }
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioButton object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_list_item_new_with_label
%%
override gtk_list_item_new kwargs
static PyObject *
_wrap_gtk_list_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkListItem.__init__",
				     kwlist, &text))
	return NULL;
    if (text)
	self->obj = (GObject *)gtk_list_item_new_with_label(text);
    else
	self->obj = (GObject *)gtk_list_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkListItem object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_menu_item_new_with_label gtk_menu_item_new_with_mnemonic
%%
override gtk_menu_item_new kwargs
static PyObject *
_wrap_gtk_menu_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkMenuItem.__init__",
				     kwlist, &text))
	return NULL;
    if (text)
	self->obj = (GObject *)gtk_menu_item_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_menu_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkMenuItem object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_check_menu_item_new_with_label gtk_check_menu_item_new_with_mnemonic
%%
override gtk_check_menu_item_new kwargs
static PyObject *
_wrap_gtk_check_menu_item_new(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|z:GtkCheckMenuItem.__init__", kwlist,
				     &text))
	return NULL;
    if (text)
	self->obj = (GObject *)gtk_check_menu_item_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_check_menu_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkCheckMenuItem object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_radio_menu_item_new_with_label gtk_radio_menu_item_new_with_mnemonic
%%
override gtk_radio_menu_item_new kwargs
static PyObject *
_wrap_gtk_radio_menu_item_new(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "group", "label", NULL };
    gchar *text = NULL;
    PyObject *py_group = Py_None;
    GtkRadioMenuItem *group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|Oz:GtkRadioMenuItem.__init__", kwlist,
				     &py_group, &text))
	return NULL;
    if (py_group == Py_None)
	group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioMenuItem_Type))
	group = GTK_RADIO_MENU_ITEM(pygobject_get(py_group));
    else {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a GtkRadioMenuItem or None");
	return NULL;
    }
    /* various configs for create radio buttons ... */
    if (text == NULL) {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_menu_item_new(NULL);
	else
	    self->obj = (GObject *)gtk_radio_menu_item_new(group->group);
    } else {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_menu_item_new_with_mnemonic(NULL,
									 text);
	else
	    self->obj = (GObject *)gtk_radio_menu_item_new_with_mnemonic
		(group->group, text);
    }
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioMenuItem object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_ctree_construct
  gtk_ctree_insert_gnode
  gtk_ctree_export_to_gnode
  gtk_ctree_post_recursive
  gtk_ctree_post_recursive_to_depth
  gtk_ctree_pre_recursive
  gtk_ctree_pre_recursive_to_depth
  gtk_ctree_find_node_ptr
%%
ignore gtk_ctree_new
%%
override gtk_ctree_new_with_titles kwargs
static PyObject*
_wrap_gtk_ctree_new_with_titles(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "columns", "tree_column", "titles", NULL };
    int columns, tree_column;
    PyObject *py_titles = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii|O:GtkCTree.__init__",
				     kwlist, &columns, &tree_column,
				     &py_titles))
	return NULL;
    if (py_titles) {
	gchar **titles;
	gint i;

	if (!PySequence_Check(py_titles)) {
	    PyErr_SetString(PyExc_TypeError, "titles must be a sequence");
	    return NULL;
	}
	if (PySequence_Length(py_titles) < columns) {
	    PyErr_SetString(PyExc_TypeError, "titles too short");
	    return NULL;
	}
	titles = g_new(gchar *, columns);
	for (i = 0; i < columns; i++) {
	    PyObject *item = PySequence_GetItem(py_titles, i);

	    Py_DECREF(item);
	    if (!PyString_Check(item)) {
		PyErr_SetString(PyExc_TypeError, "sequence item not a string");
		g_free(titles);
		return NULL;
	    }
	    titles[i] = PyString_AsString(item);
	}
	self->obj = (GObject *)gtk_ctree_new_with_titles(columns,
						tree_column, titles);
	g_free(titles);
    } else
	self->obj = (GObject *)gtk_ctree_new(columns, tree_column);
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError,"could not create GtkCTree object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_ctree_insert_node kwargs
static PyObject *
_wrap_gtk_ctree_insert_node(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", "text", "spacing",
			      "pixmap_closed", "mask_closed", "pixmap_opened",
			      "mask_opened", "is_leaf", "expanded", NULL };
    PyObject *py_parent, *py_sibling, *py_text;
    PyGObject *py_pixmap_closed, *py_mask_closed;
    PyGObject *py_pixmap_opened, *py_mask_opened;
    GtkCTreeNode *parent = NULL, *sibling = NULL, *ret;
    gchar **text = NULL;
    GdkPixmap *pixmap_closed = NULL, *pixmap_opened = NULL;
    GdkBitmap *mask_closed = NULL, *mask_opened = NULL;
    gint spacing, is_leaf, expanded, columns, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOOiOOOOii:GtkCTree.insert_node", kwlist,
				     &py_parent, &py_sibling, &py_text,
				     &spacing, &py_pixmap_closed,
				     &py_mask_closed, &py_pixmap_opened,
				     &py_mask_opened, &is_leaf, &expanded))
	return NULL;
    if (PyGtkCTreeNode_Check(py_parent))
	parent = PyGtkCTreeNode_Get(py_parent);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError, "parent must be a CTreeNode or None");
	return NULL;
    }
    if (PyGtkCTreeNode_Check(py_sibling))
	sibling = PyGtkCTreeNode_Get(py_sibling);
    else if (py_sibling != Py_None) {
	PyErr_SetString(PyExc_TypeError,"sibling must be a CTreeNode or None");
	return NULL;
    }
    if (pygobject_check(py_pixmap_closed, &PyGdkPixmap_Type))
	pixmap_closed = GDK_PIXMAP(py_pixmap_closed->obj);
    else if ((PyObject *)py_pixmap_closed != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"pixmap_closed must be a GdkPixmap or None");
	return NULL;
    }
    if (pygobject_check(py_mask_closed, &PyGdkPixmap_Type))
	mask_closed = GDK_PIXMAP(py_mask_closed->obj);
    else if ((PyObject *)py_mask_closed != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"mask_closed must be a GdkBitmap or None");
	return NULL;
    }
    if (pygobject_check(py_pixmap_opened, &PyGdkPixmap_Type))
	pixmap_opened = GDK_PIXMAP(py_pixmap_opened->obj);
    else if ((PyObject *)py_pixmap_opened != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"pixmap_opened must be a GdkPixmap or None");
	return NULL;
    }
    if (pygobject_check(py_mask_opened, &PyGdkPixmap_Type))
	mask_opened = GDK_PIXMAP(py_mask_opened->obj);
    else if ((PyObject *)py_mask_opened != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"mask_opened must be a GdkBitmap or None");
	return NULL;
    }
    if (!PySequence_Check(py_text)) {
	PyErr_SetString(PyExc_TypeError, "text must be a sequence");
	return NULL;
    }
    columns = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_text) < columns) {
	PyErr_SetString(PyExc_TypeError, "text is too short");
	return NULL;
    }
    text = g_new(gchar *, columns);
    for (i = 0; i < columns; i++) {
	PyObject *item = PySequence_GetItem(py_text, i);

	Py_DECREF(item);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError,"text sequence item not a string");
	    g_free(text);
	    return NULL;
	}
	text[i] = PyString_AsString(item);
    }
    ret = gtk_ctree_insert_node(GTK_CTREE(self->obj), parent, sibling, text,
				spacing, pixmap_closed, mask_closed,
				pixmap_opened, mask_opened, is_leaf, expanded);
    g_free(text);
    return PyGtkCTreeNode_New(ret);
}
%%
ignore gtk_ctree_find_by_row_data_custom gtk_ctree_find_all_by_row_data_custom
%%
override gtk_ctree_find_by_row_data kwargs
static PyObject *
_wrap_gtk_ctree_find_by_row_data(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyObject *py_node, *data;
    GtkCTreeNode *node = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkCTree.find_by_row_data", kwlist,
				     &py_node, &data))
	return NULL;
    if (PyGtkCTreeNode_Check(py_node))
	node = PyGtkCTreeNode_Get(py_node);
    else if (py_node != Py_None) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode or None");
	return NULL;
    }
    ret = gtk_ctree_find_by_row_data(GTK_CTREE(self->obj), node, data);
    if (ret)
	return PyGtkCTreeNode_New(ret);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_ctree_find_all_by_row_data kwargs
static PyObject *
_wrap_gtk_ctree_find_all_by_row_data(PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyObject *py_node, *data, *list;
    GtkCTreeNode *node = NULL;
    GList *ret, *tmp;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkCTree.find_all_by_row_data",kwlist,
				     &py_node, &data))
	return NULL;
    if (PyGtkCTreeNode_Check(py_node))
	node = PyGtkCTreeNode_Get(py_node);
    else if (py_node != Py_None) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode or None");
	return NULL;
    }
    ret = gtk_ctree_find_all_by_row_data(GTK_CTREE(self->obj), node, data);
    if ((list = PyList_New(0)) == NULL)
	return NULL;
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *item = PyGtkCTreeNode_New((GtkCTreeNode *)tmp->data);

	if (item == NULL) {
	    Py_DECREF(list);
	    return NULL;
	}
	PyList_Append(list, item);
	Py_DECREF(item);
    }
    g_list_free(ret);
    return list;
}
%%
override gtk_ctree_node_get_text kwargs
static PyObject *
_wrap_gtk_ctree_node_get_text(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyObject *node;
    int column;
    char *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!i:GtkCTree.node_get_text", kwlist,
				     &PyGtkCTreeNode_Type, &node, &column))
	return NULL;
    if (!gtk_ctree_node_get_text(GTK_CTREE(self->obj),
				 PyGtkCTreeNode_Get(node), column, &text)) {
	PyErr_SetString(PyExc_ValueError, "can't get text value");
	return NULL;
    }
    return PyString_FromString(text);
}
%%
override gtk_ctree_node_get_pixmap kwargs
static PyObject *
_wrap_gtk_ctree_node_get_pixmap(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyObject *node;
    int column;
    GdkPixmap *pixmap = NULL;
    GdkBitmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!i:GtkCTree.node_get_pixmap", kwlist,
				     &PyGtkCTreeNode_Type, &node, &column))
	return NULL;
    if (!gtk_ctree_node_get_pixmap(GTK_CTREE(self->obj),
				   PyGtkCTreeNode_Get(node), column,
				   &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixmap value");
	return NULL;
    }
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_ctree_node_get_pixtext kwargs
static PyObject *
_wrap_gtk_ctree_node_get_pixtext(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyObject *node;
    int column;
    gchar *text = NULL;
    guint8 spacing;
    GdkPixmap *pixmap = NULL;
    GdkBitmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!i:GtkCTree.node_get_pixtext", kwlist,
				     &PyGtkCTreeNode_Type, &node, &column))
	return NULL;
    if (!gtk_ctree_node_get_pixtext(GTK_CTREE(self->obj),
				   PyGtkCTreeNode_Get(node), column,
				   &text, &spacing, &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixtext value");
	return NULL;
    }
    return Py_BuildValue("(siNN)", text, (int)spacing,
			 pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_ctree_get_node_info kwargs
static PyObject *
_wrap_gtk_ctree_get_node_info(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *node;
    gchar *text;
    guint8 spacing;
    GdkPixmap *pixmap_closed, *pixmap_opened;
    GdkBitmap *mask_closed, *mask_opened;
    gboolean is_leaf, expanded;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkCTree.get_node_info",
				     kwlist, &PyGtkCTreeNode_Type, &node))
	return NULL;
    if (!gtk_ctree_get_node_info(GTK_CTREE(self->obj),PyGtkCTreeNode_Get(node),
				 &text, &spacing, &pixmap_closed, &mask_closed,
				 &pixmap_opened, &mask_opened,
				 &is_leaf, &expanded)) {
	PyErr_SetString(PyExc_ValueError, "can't get node info");
	return NULL;
    }
    return Py_BuildValue("(siNNNNii)", text, (int)spacing,
			 pygobject_new((GObject *)pixmap_opened),
			 pygobject_new((GObject *)mask_closed),
			 pygobject_new((GObject *)pixmap_opened),
			 pygobject_new((GObject *)mask_opened),
			 (int)is_leaf, (int)expanded);
}
%%
ignore gtk_ctree_node_set_row_data_full
%%
override gtk_ctree_node_set_row_data kwargs
static PyObject *
_wrap_gtk_ctree_node_set_row_data(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyObject *node, *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!O:GtkCTree.node_set_row_data", kwlist,
				     &PyGtkCTreeNode_Type, &node, &data))
	return NULL;
    Py_INCREF(data);
    gtk_ctree_node_set_row_data_full(GTK_CTREE(self->obj),
				     PyGtkCTreeNode_Get(node), data,
				     (GtkDestroyNotify)pygtk_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_ctree_node_get_row_data kwargs
static PyObject *
_wrap_gtk_ctree_node_get_row_data(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *node, *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkCTree.node_get_row_data", kwlist,
				     &PyGtkCTreeNode_Type, &node))
	return NULL;
    data = gtk_ctree_node_get_row_data(GTK_CTREE(self->obj),
				       PyGtkCTreeNode_Get(node));
    if (!data) data = Py_None;
    Py_INCREF(data);
    return data;
}
%%
ignore gtk_tree_remove_items
%%
override gtk_toolbar_append_item kwargs
static PyObject *
_wrap_gtk_toolbar_append_item(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
			      "icon", "callback", "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param;
    GtkWidget *icon = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "zzzOOO:GtkToolbar.append_item", kwlist,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"forth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_append_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
				  tooltip_private_text, icon, NULL, NULL);
    if (ret && PyCallable_Check(callback)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_prepend_item kwargs
static PyObject *
_wrap_gtk_toolbar_prepend_item(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
			      "icon", "callback", "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param;
    GtkWidget *icon = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "zzzOOO:GtkToolbar.prepend_item", kwlist,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"forth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_prepend_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
				  tooltip_private_text, icon, NULL, NULL);
    if (ret && PyCallable_Check(callback)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_insert_item kwargs
static PyObject *
_wrap_gtk_toolbar_insert_item(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
			      "icon", "callback", "user_data", "position",
			      NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param;
    GtkWidget *icon = NULL, *ret;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "zzzOOOi:GtkToolbar.insert_item", kwlist,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param, &position))
	return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"forth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_insert_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
				  tooltip_private_text, icon, NULL, NULL,
				  position);
    if (ret && PyCallable_Check(callback)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_append_element kwargs
static PyObject *
_wrap_gtk_toolbar_append_element(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
			      "tooltip_private_text", "icon", "callback",
			      "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOzzzOOO:GtkToolbar.append_element",
				     kwlist,
				     &py_type, &py_widget,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
			   py_type, (gint *)&type))
	return NULL;
    if (!pygobject_check(py_widget, &PyGtkWidget_Type))
	widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"second argument must be a GtkWidget or None");
	return NULL;
    }
    if (!pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sixth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_append_element(GTK_TOOLBAR(self->obj), type, widget,
				     text, tooltip_text, tooltip_private_text,
				     icon, NULL, NULL);
    if (ret && PyCallable_Check(callback) &&
	(type == GTK_TOOLBAR_CHILD_BUTTON ||
	 type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	 type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_prepend_element kwargs
static PyObject *
_wrap_gtk_toolbar_prepend_element(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
			      "tooltip_private_text", "icon", "callback",
			      "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOzzzOOO:GtkToolbar.prepend_element",
				     kwlist,
				     &py_type, &py_widget,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
			   py_type, (gint *)&type))
	return NULL;
    if (!pygobject_check(py_widget, &PyGtkWidget_Type))
	widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"second argument must be a GtkWidget or None");
	return NULL;
    }
    if (!pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sixth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_prepend_element(GTK_TOOLBAR(self->obj), type, widget,
				      text, tooltip_text, tooltip_private_text,
				      icon, NULL, NULL);
    if (ret && PyCallable_Check(callback) &&
	(type == GTK_TOOLBAR_CHILD_BUTTON ||
	 type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	 type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_insert_element kwargs
static PyObject *
_wrap_gtk_toolbar_insert_element(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
			      "tooltip_private_text", "icon", "callback",
			      "user_data", "position", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOzzzOOOi:GtkToolbar.insert_element",
				     kwlist,
				     &py_type, &py_widget,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param, &position))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
			   py_type, (gint *)&type))
	return NULL;
    if (!pygobject_check(py_widget, &PyGtkWidget_Type))
	widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"second argument must be a GtkWidget or None");
	return NULL;
    }
    if (!pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sixth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_insert_element(GTK_TOOLBAR(self->obj), type, widget,
				     text, tooltip_text, tooltip_private_text,
				     icon, NULL, NULL, position);
    if (ret && PyCallable_Check(callback) &&
	(type == GTK_TOOLBAR_CHILD_BUTTON ||
	 type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	 type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_notebook_query_tab_label_packing kwargs
static PyObject *
_wrap_gtk_notebook_query_tab_label_packing(PyGObject *self, PyObject *args,
					   PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    gboolean expand, fill;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkNotebook.query_tab_label_packing",
				     kwlist, &child))
	return NULL;
    if (!pygobject_check(child, &PyGtkWidget_Type)) {
	PyErr_SetString(PyExc_TypeError, "child must be a GtkWidget");
	return NULL;
    }
    gtk_notebook_query_tab_label_packing(GTK_NOTEBOOK(self->obj),
					 GTK_WIDGET(child->obj),
					 &expand, &fill, &pack_type);
    return Py_BuildValue("(iii)", expand, fill, pack_type);
}
%%
override gtk_list_insert_items kwargs
static PyObject *
_wrap_gtk_list_insert_items(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "items", "position", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int position, len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!i:GtkList.insert_items",
				     kwlist, &PyList_Type, &py_items,
				     &position))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_insert_items(GTK_LIST(self->obj), items, position);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_append_items kwargs
static PyObject *
_wrap_gtk_list_append_items(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.append_items",
				     kwlist, &PyList_Type, &py_items))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_append_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_prepend_items kwargs
static PyObject *
_wrap_gtk_list_prepend_items(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.preppend_items",
				     kwlist, &PyList_Type, &py_items))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_prepend_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_remove_items kwargs
static PyObject *
_wrap_gtk_list_remove_items(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.remove_items",
				     kwlist, &PyList_Type, &py_items))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_remove_items(GTK_LIST(self->obj), items);
    g_list_free(items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_list_remove_items_no_unref
%%
override gtk_color_selection_get_current_color
static PyObject *
_wrap_gtk_color_selection_get_current_color(PyGObject *self, PyObject *args)
{
    GdkColor colour = { 0, };

    if (!PyArg_ParseTuple(args, ":GtkColorSelection.get_current_color"))
        return NULL;
    gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(self->obj),
					  &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gtk_color_selection_get_previous_color
static PyObject *
_wrap_gtk_color_selection_get_previous_color(PyGObject *self, PyObject *args)
{
    GdkColor colour = { 0, };

    if (!PyArg_ParseTuple(args, ":GtkColorSelection.get_previous_color"))
        return NULL;
    gtk_color_selection_get_previous_color(GTK_COLOR_SELECTION(self->obj),
					   &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gtk_calendar_get_date
static PyObject *
_wrap_gtk_calendar_get_date(PyGObject *self, PyObject *args)
{
    guint year, month, day;

    if (!PyArg_ParseTuple(args, ":GtkCalendar.get_date"))
	return NULL;
    gtk_calendar_get_date(GTK_CALENDAR(self->obj), &year, &month, &day);
    return Py_BuildValue("(iii)", year, month, day);
}
%%
override gtk_drag_dest_set kwargs
static PyObject *
_wrap_gtk_drag_dest_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "flags", "targets", "actions", NULL };
    PyObject *py_flags, *py_targets, *py_actions;
    GtkDestDefaults flags;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOO:GtkWidget.drag_dest_set", kwlist,
				     &py_flags, &py_targets, &py_actions))
	return NULL;
    if (pyg_flags_get_value(GTK_TYPE_DEST_DEFAULTS, py_flags, (gint *)&flags))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
			     py_actions, (gint *)&actions))
	return NULL;
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
			      &targets[i].flags, &targets[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(targets);
	    return NULL;
	}
    }
    gtk_drag_dest_set(GTK_WIDGET(self->obj), flags, targets, n_targets,
		      actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_source_set kwargs
static PyObject *
_wrap_gtk_drag_source_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start_button_mask", "targets", "actions", NULL };
    PyObject *py_sbmask, *py_targets, *py_actions;
    GdkModifierType sbmask;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOO:GtkWidget.drag_source_set", kwlist,
				     &py_sbmask, &py_targets, &py_actions))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,
			     py_sbmask, (gint *)&sbmask))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
			     py_actions, (gint *)&actions))
	return NULL;
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
			      &targets[i].flags, &targets[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(targets);
	    return NULL;
	}
    }
    gtk_drag_source_set(GTK_WIDGET(self->obj), sbmask, targets, n_targets,
			actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_begin kwargs
static PyObject *
_wrap_gtk_drag_begin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "actions", "button", "event", NULL };
    PyObject *py_targets, *py_actions, *event;
    GtkTargetEntry *tents;
    GtkTargetList *targets;
    GdkDragAction actions;
    gint button, n_targets, i;
    GdkDragContext *context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOiO:GtkWidget.drag_begin", kwlist,
				     &py_targets, &py_actions, &button,
				     &event))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
			     py_actions, (gint *)&actions))
	return NULL;
    if (!pyg_boxed_check(event, GDK_TYPE_EVENT)) {
	PyErr_SetString(PyExc_TypeError, "event must be a GdkEvent");
	return NULL;
    }
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    tents = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &tents[i].target,
			      &tents[i].flags, &tents[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(tents);
	    return NULL;
	}
    }
    targets = gtk_target_list_new(tents, n_targets);
    g_free(tents);
    context = gtk_drag_begin(GTK_WIDGET(self->obj), targets, actions, button,
			     pyg_boxed_get(event, GdkEvent));
    gtk_target_list_unref(targets);
    return pygobject_new((GObject *)context);
}
%%
ignore
  gtk_drag_source_handle_event gtk_drag_dest_handle_event
  gtk_selection_request gtk_selection_notify gtk_selection_property_notify
  gtk_selection_incr_event
%%
override gtk_selection_add_targets kwargs
static PyObject *
_wrap_gtk_selection_add_targets(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "selection", "targets", NULL };
    PyObject *py_targets;
    GtkTargetEntry *targets;
    int selection, n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "iO:GtkWidget.selection_add_targets",
				     kwlist, &selection, &py_targets))
	return NULL;
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
			      &targets[i].flags, &targets[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(targets);
	    return NULL;
	}
    }
    gtk_selection_add_targets(GTK_WIDGET(self->obj), (GdkAtom)selection,
			      targets, n_targets);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_text_iter_free
%%
override gtk_text_iter_copy
static PyObject *
_wrap_gtk_text_iter_copy(PyGBoxed *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, ":GtkTextIter.copy"))
	return NULL;
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, pyg_boxed_get(self, GtkTextIter),
			 TRUE, TRUE);
}
%%
override gtk_text_iter_get_char
static PyObject *
_wrap_gtk_text_iter_get_char(PyGBoxed *self, PyObject *args)
{
    gunichar chr;
    Py_UNICODE pychr;

    if (!PyArg_ParseTuple(args, ":GtkTextIter.get_char"))
	return NULL;
    chr = gtk_text_iter_get_char(pyg_boxed_get(self, GtkTextIter));
    if (chr > 0xffff) {
	PyErr_SetString(PyExc_RuntimeError, "python's broken unicode handling only supports 16 bit unicode, and you just hit this limit");
	return NULL;
    }
    pychr = (Py_UNICODE)chr;
    return PyUnicode_FromUnicode(&pychr, 1);

}
%%
override gtk_text_iter_get_slice kwargs
static PyObject *
_wrap_gtk_text_iter_get_slice(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextIter.get_slice",
				     kwlist, &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_slice(pyg_boxed_get(self, GtkTextIter),
				   pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_text kwargs
static PyObject *
_wrap_gtk_text_iter_get_text(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextIter.get_text",
				     kwlist, &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_text(pyg_boxed_get(self, GtkTextIter),
				   pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_visible_slice kwargs
static PyObject *
_wrap_gtk_text_iter_get_visible_slice(PyGBoxed *self, PyObject *args,
				      PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkTextIter.get_visible_slice", kwlist,
				     &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_visible_slice(pyg_boxed_get(self, GtkTextIter),
					   pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_visible_text kwargs
static PyObject *
_wrap_gtk_text_iter_get_visible_text(PyGBoxed *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkTextIter.get_visible_text", kwlist,
				     &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_visible_text(pyg_boxed_get(self, GtkTextIter),
					  pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_marks
static PyObject *
_wrap_gtk_text_iter_get_marks(PyGBoxed *self, PyObject *args)
{
    GSList *ret, *tmp;
    PyObject *pyret;

    if (!PyArg_ParseTuple(args, ":GtkTextIter.get_marks"))
	return NULL;
    ret = gtk_text_iter_get_marks(pyg_boxed_get(self, GtkTextIter));
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *mark = pygobject_new((GObject *)tmp->data);
	PyList_Append(pyret, mark);
	Py_DECREF(mark);
    }
    g_slist_free(ret);
    return pyret;
}
%%
override gtk_text_iter_get_toggled_tags kwargs
static PyObject *
_wrap_gtk_text_iter_get_toggled_tags(PyGBoxed *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "toggled_on", NULL };
    GSList *ret, *tmp;
    int toggled_on;
    PyObject *pyret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "i:GtkTextIter.get_toggled_tags", kwlist,
				     &toggled_on))
	return NULL;
    ret = gtk_text_iter_get_toggled_tags(pyg_boxed_get(self, GtkTextIter),
					 toggled_on);
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *tag = pygobject_new((GObject *)tmp->data);
	PyList_Append(pyret, tag);
	Py_DECREF(tag);
    }
    g_slist_free(ret);
    return pyret;
}
%%
override gtk_text_iter_get_tags
static PyObject *
_wrap_gtk_text_iter_get_tags(PyGBoxed *self, PyObject *args)
{
    GSList *ret, *tmp;
    PyObject *pyret;

    if (!PyArg_ParseTuple(args, ":GtkTextIter.get_tags"))
	return NULL;
    ret = gtk_text_iter_get_tags(pyg_boxed_get(self, GtkTextIter));
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *tag = pygobject_new((GObject *)tmp->data);
	PyList_Append(pyret, tag);
	Py_DECREF(tag);
    }
    g_slist_free(ret);
    return pyret;
}
%%
override gtk_text_iter_forward_search kwargs
static PyObject *
_wrap_gtk_text_iter_forward_search(PyGBoxed *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "str", "visible_only", "slice", "limit", NULL };
    gchar *str;
    gint visible_only, slice;
    PyObject *py_limit = Py_None;
    GtkTextIter match_start, match_end, *limit = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "sii|O:GtkTextIter.forward_search",
				     kwlist, &str, &visible_only, &slice,
				     &py_limit))
	return NULL;
    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
	limit = pyg_boxed_get(py_limit, GtkTextIter);
    else if (py_limit != Py_None) {
	PyErr_SetString(PyExc_TypeError,"limit must be a GtkTextIter or None");
	return NULL;
    }
    if (gtk_text_iter_forward_search(pyg_boxed_get(self, GtkTextIter), str,
				     visible_only, slice, &match_start,
				     &match_end, limit))
	return Py_BuildValue("(NN)",
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_start,
					   TRUE, TRUE),
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_end,
					   TRUE, TRUE));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_text_iter_backward_search kwargs
static PyObject *
_wrap_gtk_text_iter_backward_search(PyGBoxed *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "str", "visible_only", "slice", "limit", NULL };
    gchar *str;
    gint visible_only, slice;
    PyObject *py_limit = Py_None;
    GtkTextIter match_start, match_end, *limit = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "sii|O:GtkTextIter.backward_search",
				     kwlist, &str, &visible_only, &slice,
				     &py_limit))
	return NULL;
    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
	limit = pyg_boxed_get(py_limit, GtkTextIter);
    else if (py_limit != Py_None) {
	PyErr_SetString(PyExc_TypeError,"limit must be a GtkTextIter or None");
	return NULL;
    }
    if (gtk_text_iter_backward_search(pyg_boxed_get(self, GtkTextIter), str,
				      visible_only, slice, &match_start,
				      &match_end, limit))
	return Py_BuildValue("(NN)",
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_start,
					   TRUE, TRUE),
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_end,
					   TRUE, TRUE));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_text_buffer_create_tag kwargs
static PyObject *
_wrap_gtk_text_buffer_create_tag(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tag_name", NULL };
    gchar *tag_name;
    GtkTextTag *tag;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:GtkTextBuffer.create_tag", kwlist,
				     &tag_name))
	return NULL;
    tag = gtk_text_buffer_create_tag(GTK_TEXT_BUFFER(self->obj),
				     tag_name, NULL);
    return pygobject_new((GObject *)tag);
}
%%
override gtk_text_buffer_get_iter_at_line_offset kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line_offset(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "line_number", "char_offset", NULL };
    GtkTextIter iter;
    int line_number, char_offset;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkTextBuffer.get_iter_at_line_offset", kwlist, &line_number, &char_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_line_offset(GTK_TEXT_BUFFER(self->obj), &iter,
					    line_number, char_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_iter_at_line_index kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line_index(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "line_number", "byte_offset", NULL };
    GtkTextIter iter;
    int line_number, byte_offset;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkTextBuffer.get_iter_at_line_index", kwlist, &line_number, &byte_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_line_index(GTK_TEXT_BUFFER(self->obj), &iter,
					   line_number, byte_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_iter_at_offset kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_offset(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    int char_offset;
    static char *kwlist[] = { "char_offset", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkTextBuffer.get_iter_at_offset", kwlist, &char_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj),
				       &iter, char_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_iter_at_line kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    int line_number;
    static char *kwlist[] = { "line_number", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkTextBuffer.get_iter_at_line", kwlist, &line_number))
        return NULL;

    gtk_text_buffer_get_iter_at_line(GTK_TEXT_BUFFER(self->obj),
				     &iter, line_number);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_start_iter
static PyObject *
_wrap_gtk_text_buffer_get_start_iter(PyGObject *self, PyObject *args)
{
    GtkTextIter iter;

    if (!PyArg_ParseTuple(args, ":GtkTextBuffer.get_start_iter"))
        return NULL;

    gtk_text_buffer_get_start_iter(GTK_TEXT_BUFFER(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_end_iter
static PyObject *
_wrap_gtk_text_buffer_get_end_iter(PyGObject *self, PyObject *args)
{
    GtkTextIter iter;

    if (!PyArg_ParseTuple(args, ":GtkTextBuffer.get_end_iter"))
        return NULL;

    gtk_text_buffer_get_end_iter(GTK_TEXT_BUFFER(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_bounds
static PyObject *
_wrap_gtk_text_buffer_get_bounds(PyGObject *self, PyObject *args)
{
    GtkTextIter start, end;

    if (!PyArg_ParseTuple(args, ":GtkTextBuffer.get_bounds"))
        return NULL;

    gtk_text_buffer_get_bounds(GTK_TEXT_BUFFER(self->obj), &start, &end);
    return Py_BuildValue("(NN)",
			 pyg_boxed_new(GTK_TYPE_TEXT_ITER, &start, TRUE, TRUE),
			 pyg_boxed_new(GTK_TYPE_TEXT_ITER, &end, TRUE, TRUE));
}
%%
override gtk_text_buffer_get_iter_at_mark kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_mark(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyGObject *mark;
    static char *kwlist[] = { "mark", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextBuffer.get_iter_at_mark", kwlist, &mark))
        return NULL;
    if (!pygobject_check(mark, &PyGtkTextMark_Type)) {
        PyErr_SetString(PyExc_TypeError, "mark should be a GtkTextMark");
        return NULL;
    }

    gtk_text_buffer_get_iter_at_mark(GTK_TEXT_BUFFER(self->obj), &iter,
				     GTK_TEXT_MARK(mark->obj));
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}


