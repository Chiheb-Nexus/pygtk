/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include <gtk/gtk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include "pygtk-private.h"
#include "pygtktreemodel.h"
#include "pygtkcellrenderer.h"

/* from the gdk portion ... */
extern PyTypeObject PyGdkColormap_Type;
extern PyTypeObject PyGdkGC_Type;
extern PyTypeObject PyGdkWindow_Type;
extern PyTypeObject PyGdkPixmap_Type;
extern PyTypeObject PyGdkImage_Type;
extern PyTypeObject PyGdkPixbuf_Type;
extern PyTypeObject PyGdkPixbufAnimation_Type;
extern PyTypeObject PyGdkDragContext_Type;

%%
init
    PyGtkListStore_Type.tp_as_number  = PyGtkTreeModel_Type.tp_as_number;
    PyGtkListStore_Type.tp_as_mapping = PyGtkTreeModel_Type.tp_as_mapping;
    PyGtkListStore_Type.tp_iter       = PyGtkTreeModel_Type.tp_iter;
    PyGtkTreeStore_Type.tp_as_number  = PyGtkTreeModel_Type.tp_as_number;
    PyGtkTreeStore_Type.tp_as_mapping = PyGtkTreeModel_Type.tp_as_mapping;
    PyGtkTreeStore_Type.tp_iter       = PyGtkTreeModel_Type.tp_iter;
    PyPyGtkGenericTreeModel_Type.tp_as_number  = PyGtkTreeModel_Type.tp_as_number;
    PyPyGtkGenericTreeModel_Type.tp_as_mapping = PyGtkTreeModel_Type.tp_as_mapping;
    PyPyGtkGenericTreeModel_Type.tp_iter       = PyGtkTreeModel_Type.tp_iter;
%%
modulename gtk
%%
import gobject.GObject as PyGObject_Type
import atk.Object as PyAtkObject_Type
import pango.Context as PyPangoContext_Type
import pango.Font as PyPangoFont_Type
import pango.Layout as PyPangoLayout_Type
%%
ignore-glob
  *_get_type
  _*
  *_ref
  *_unref
%%
override-attr GtkStyle.fg
static PyObject *
_wrap_gtk_style__get_fg(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->fg);
}
%%
override-attr GtkStyle.bg
static PyObject *
_wrap_gtk_style__get_bg(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->bg);
}
%%
override-attr GtkStyle.light
static PyObject *
_wrap_gtk_style__get_light(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->light);
}
%%
override-attr GtkStyle.dark
static PyObject *
_wrap_gtk_style__get_dark(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->dark);
}
%%
override-attr GtkStyle.mid
static PyObject *
_wrap_gtk_style__get_mid(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->mid);
}
%%
override-attr GtkStyle.text
static PyObject *
_wrap_gtk_style__get_text(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->text);
}
%%
override-attr GtkStyle.base
static PyObject *
_wrap_gtk_style__get_base(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->base);
}
%%
override-attr GtkStyle.text_aa
static PyObject *
_wrap_gtk_style__get_text_aa(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_COLOUR_ARRAY, style->text_aa);
}
%%
override-attr GtkStyle.white
static PyObject *
_wrap_gtk_style__get_white(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return pyg_boxed_new(GDK_TYPE_COLOR, &style->white, TRUE, TRUE);
}
static int
_wrap_gtk_style__set_white(PyGObject *self, PyObject *value, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    if (!pyg_boxed_check(value, GDK_TYPE_COLOR)) {
	PyErr_SetString(PyExc_TypeError, "can only assign a GdkColor");
	return -1;
    }
    style->white = *pyg_boxed_get(value, GdkColor);
    return 0;
}
%%
override-attr GtkStyle.black
static PyObject *
_wrap_gtk_style__get_black(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return pyg_boxed_new(GDK_TYPE_COLOR, &style->black, TRUE, TRUE);
}
static int
_wrap_gtk_style__set_black(PyGObject *self, PyObject *value, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    if (!pyg_boxed_check(value, GDK_TYPE_COLOR)) {
	PyErr_SetString(PyExc_TypeError, "can only assign a GdkColor");
	return -1;
    }
    style->black = *pyg_boxed_get(value, GdkColor);
    return 0;
}
%%
override-attr GtkStyle.fg_gc
static PyObject *
_wrap_gtk_style__get_fg_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->fg_gc);
}
%%
override-attr GtkStyle.bg_gc
static PyObject *
_wrap_gtk_style__get_bg_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->bg_gc);
}
%%
override-attr GtkStyle.light_gc
static PyObject *
_wrap_gtk_style__get_light_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->light_gc);
}
%%
override-attr GtkStyle.dark_gc
static PyObject *
_wrap_gtk_style__get_dark_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->dark_gc);
}
%%
override-attr GtkStyle.mid_gc
static PyObject *
_wrap_gtk_style__get_mid_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->mid_gc);
}
%%
override-attr GtkStyle.text_gc
static PyObject *
_wrap_gtk_style__get_text_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->text_gc);
}
%%
override-attr GtkStyle.base_gc
static PyObject *
_wrap_gtk_style__get_base_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->base_gc);
}
%%
override-attr GtkStyle.text_aa_gc
static PyObject *
_wrap_gtk_style__get_text_aa_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_GC_ARRAY, style->text_aa_gc);
}
%%
override-attr GtkStyle.white_gc
static PyObject *
_wrap_gtk_style__get_white_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return pygobject_new((GObject *)style->white_gc);
}
static int
_wrap_gtk_style__set_white_gc(PyGObject *self, PyObject *value, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    if (!pygobject_check(value, &PyGdkGC_Type)) {
	PyErr_SetString(PyExc_TypeError, "can only assign a GdkGC");
	return -1;
    }
    style->white_gc = GDK_GC(pygobject_get(value));
    return 0;
}
%%
override-attr GtkStyle.black_gc
static PyObject *
_wrap_gtk_style__get_black_gc(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return pygobject_new((GObject *)style->black_gc);
}
static int
_wrap_gtk_style__set_black_gc(PyGObject *self, PyObject *value, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    if (!pygobject_check(value, &PyGdkGC_Type)) {
	PyErr_SetString(PyExc_TypeError, "can only assign a GdkGC");
	return -1;
    }
    style->black_gc = GDK_GC(pygobject_get(value));
    return 0;
}
%%
override-attr GtkStyle.bg_pixmap
static PyObject *
_wrap_gtk_style__get_bg_pixmap(PyGObject *self, void *closure)
{
    GtkStyle *style = GTK_STYLE(self->obj);

    return _pygtk_style_helper_new(style, STYLE_PIXMAP_ARRAY, style->bg_pixmap);
}
%%
override gtk_paint_polygon kwargs
static PyObject *
_wrap_gtk_paint_polygon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "points", "fill", NULL };
    PyObject *window, *py_state_type, *py_shadow_type, *py_area;
    GtkStateType state_type;
    GtkShadowType shadow_type;
    GdkRectangle area;
    PyObject *widget;
    const gchar *detail;
    PyObject *py_points;
    gint npoints, i;
    GdkPoint *points;
    gboolean fill;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				    "O!OOOO!zOi:GdkDrawable.draw_polygon",
				     kwlist, &PyGdkWindow_Type, &window,
				     &py_state_type, &py_shadow_type, &py_area,
				     &PyGtkWidget_Type, &widget, &detail,
				     &py_points, &fill))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type,
			   (gint *)&state_type))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type,
			   (gint *)&shadow_type))
	return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
	return NULL;
    if (!PySequence_Check(py_points)) {
	PyErr_SetString(PyExc_TypeError, "points must be a sequence");
	return NULL;
    }
    npoints = PySequence_Length(py_points);
    points = g_new(GdkPoint, npoints);
    for (i = 0; i < npoints; i++) {
	PyObject *item = PySequence_GetItem(py_points, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "hh", &points[i].x, &points[i].y)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "sequence members must be 2-tuples");
	    g_free(points);
	    return NULL;
	}
    }
    gtk_paint_polygon(GTK_STYLE(self->obj), GDK_WINDOW(pygobject_get(window)),
		      state_type, shadow_type, &area,
		      GTK_WIDGET(pygobject_get(widget)), detail,
		      points, npoints, fill);
    g_free(points);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override-attr GtkSelectionData.data
static PyObject *
_wrap_gtk_selection_data__get_data(PyGObject *self, void *closure)
{
    if (pyg_boxed_get(self, GtkSelectionData)->length >= 0) {
	return PyString_FromStringAndSize(
			pyg_boxed_get(self, GtkSelectionData)->data,
			pyg_boxed_get(self, GtkSelectionData)->length);
    } else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
ignore gtk_selection_data_copy gtk_selection_data_free
%%
override gtk_selection_data_set kwargs
static PyObject *
_wrap_gtk_selection_data_set(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", "format", "data", NULL };
    PyObject *py_type;
    GdkAtom type;
    int format, length;
    guchar *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Ois#:GtkSelectionData.set", kwlist,
				     &py_type, &format, &data, &length))
	return NULL;
    type = pygdk_atom_from_pyobject(py_type);
    if (PyErr_Occurred())
	return NULL;
    
    gtk_selection_data_set(pyg_boxed_get(self, GtkSelectionData),
			   type, format, data, length);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_selection_data_get_text noargs
static PyObject *
_wrap_gtk_selection_data_get_text(PyObject *self)
{
    guchar *ret;

    ret = gtk_selection_data_get_text(pyg_boxed_get(self, GtkSelectionData));
    if (ret) {
	PyObject *py_ret = PyUnicode_DecodeUTF8(ret, strlen(ret), "strict");
	g_free(ret);
	return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_selection_data_get_targets noargs
static PyObject *
_wrap_gtk_selection_data_get_targets(PyObject *self)
{
    GdkAtom *targets;
    gint n_atoms;

    if (gtk_selection_data_get_targets(pyg_boxed_get(self, GtkSelectionData),
				       &targets, &n_atoms)) {
	PyObject *ret;
	gint i;

	ret = PyTuple_New(n_atoms);
	for (i = 0; i < n_atoms; i++)
	    PyTuple_SetItem(ret, i, PyGdkAtom_New(targets[i]));
	g_free(targets);
	return ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_get_row_drag_data noargs
static PyObject *
_wrap_gtk_tree_get_row_drag_data(PyObject *self)
{
    GtkTreeModel *tree_model;
    GtkTreePath *path;

    if (gtk_tree_get_row_drag_data(pyg_boxed_get(self, GtkSelectionData),
				   &tree_model, &path)) {
	PyObject *ret = Py_BuildValue("(NN)",
				      pygobject_new((GObject *)tree_model),
				      pygtk_tree_path_to_pyobject(path));

	gtk_tree_path_free(path);
	return ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_widget_translate_coordinates kwargs
static PyObject *
_wrap_gtk_widget_translate_coordinates(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dest_widget", "src_x", "src_y", NULL };
    PyObject *py_dest_widget;
    int src_x, src_y;
    GtkWidget *dest_widget = NULL;
    int dest_x, dest_y;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oii:GtkWidget.translate_coordinates",
				     kwlist, &py_dest_widget, &src_x, &src_y)) {
        return NULL;
    }
	
    if (pygobject_check(py_dest_widget, &PyGtkWidget_Type)) {
        dest_widget = GTK_WIDGET(pygobject_get(py_dest_widget));
    } else if (py_dest_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"dest_widget must be a GtkWidget or None");
	return NULL;
    }
    
    if (!gtk_widget_translate_coordinates(GTK_WIDGET(self->obj), 
                                          dest_widget,
					  src_x,
					  src_y,
					  &dest_x,
					  &dest_y)) {
       return Py_BuildValue ("()");
   }
   
   return Py_BuildValue ("(ii)", &dest_x, &dest_y);   
}
%%
override gtk_widget_size_request noargs
static PyObject *
_wrap_gtk_widget_size_request(PyGObject *self)
{
    GtkRequisition requisition;

    gtk_widget_size_request(GTK_WIDGET(self->obj), &requisition);
    return Py_BuildValue("(ii)", requisition.width, requisition.height);
}
%%
override gtk_widget_get_child_requisition noargs
static PyObject *
_wrap_gtk_widget_get_child_requisition(PyGObject *self)
{
    GtkRequisition requisition;

    gtk_widget_get_child_requisition(GTK_WIDGET(self->obj), &requisition);
    return Py_BuildValue("(ii)", requisition.width, requisition.height);
}
%%
override gtk_widget_get_allocation noargs
static PyObject *
_wrap_gtk_widget_get_allocation(PyGObject *self)
{
    GtkAllocation allocation;

    allocation = GTK_WIDGET(self->obj)->allocation;
    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &allocation, TRUE, TRUE);
}
%%
override gtk_widget_intersect kwargs
static PyObject *
_wrap_gtk_widget_intersect(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "area", NULL };
    PyObject *py_area;
    GdkRectangle area, intersect;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkWidget.intersect",
				    kwlist, &py_area))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
	return NULL;    
    if (gtk_widget_intersect(GTK_WIDGET(self->obj), &area, &intersect))
	return pyg_boxed_new(GDK_TYPE_RECTANGLE, &intersect, TRUE, TRUE);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gtk_widget_get_pointer noargs
static PyObject *
_wrap_gtk_widget_get_pointer(PyGObject *self)
{
    int x, y;

    gtk_widget_get_pointer(GTK_WIDGET(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gtk_widget_path noargs
static PyObject *
_wrap_gtk_widget_path(PyGObject *self)
{
    guint length;
    gchar *path;
    gchar *path_reversed;
    PyObject *result;

    gtk_widget_path(GTK_WIDGET(self->obj), &length, &path, &path_reversed);
    result = PyString_FromString(path);
    g_free(path);
    g_free(path_reversed);

    return result;
}
%%
override gtk_widget_class_path noargs
static PyObject *
_wrap_gtk_widget_class_path(PyGObject *self)
{
    guint length;
    gchar *path;
    gchar *path_reversed;
    PyObject *result;

    gtk_widget_class_path(GTK_WIDGET(self->obj), &length, &path,
			  &path_reversed);
    result = PyString_FromString(path);
    g_free(path);
    g_free(path_reversed);

    return result;
}
%%
override gtk_container_children noargs
static PyObject *
_wrap_gtk_container_children(PyGObject *self)
{
    if (PyErr_Warn(PyExc_DeprecationWarning, "use GtkContainer.get_children"))
	return NULL;
    return _wrap_gtk_container_get_children(self);
}
%%
override gtk_container_get_children noargs
static PyObject *
_wrap_gtk_container_get_children(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *py_list;

    list = gtk_container_get_children(GTK_CONTAINER(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
	g_list_free(list);
	return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
	PyObject *gtk_obj = pygobject_new(G_OBJECT(tmp->data));

	if (gtk_obj == NULL) {
	    g_list_free(list);
	    Py_DECREF(py_list);
	    return NULL;
	}
	PyList_Append(py_list, gtk_obj);
	Py_DECREF(gtk_obj);
    }
    g_list_free(list);
    return py_list;
}
%%
override gtk_container_set_focus_chain kwargs
static PyObject *
_wrap_gtk_container_set_focus_chain(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "focusable_widgets", NULL };
    PyObject *py_focusable_widgets;
    gint len, i;
    GList *focusable_widgets = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkContainer.set_focus_chain", kwlist,
				     &py_focusable_widgets))
	return NULL;
    if (!PySequence_Check(py_focusable_widgets)) {
	PyErr_SetString(PyExc_TypeError,
			"focusable_widgets must be a sequence");
	return NULL;
    }
    len = PySequence_Length(py_focusable_widgets);
    for (i = 0; i < len; i++) {
	PyObject *item = PySequence_GetItem(py_focusable_widgets, i);

	if (!pygobject_check(item, &PyGtkWidget_Type)) {
	    PyErr_SetString(PyExc_TypeError,
			    "focusable_widgets members must be GtkWidgets");
	    Py_DECREF(item);
	    return NULL;
	}
	focusable_widgets = g_list_prepend(focusable_widgets,
					   pygobject_get(item));
	Py_DECREF(item);
    }
    focusable_widgets = g_list_reverse(focusable_widgets);
    gtk_container_set_focus_chain(GTK_CONTAINER(self->obj), focusable_widgets);
    g_list_free(focusable_widgets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_container_get_focus_chain noargs
static PyObject *
_wrap_gtk_container_get_focus_chain(PyGObject *self)
{
    GList *list = NULL;

    if (gtk_container_get_focus_chain(GTK_CONTAINER(self->obj), &list)) {
	PyObject *py_list;
	GList *tmp;

	if ((py_list = PyList_New(0)) == NULL) {
	    g_list_free(list);
	    return NULL;
	}
	for (tmp = list; tmp != NULL; tmp = tmp->next) {
	    PyObject *gtk_obj = pygobject_new(G_OBJECT(tmp->data));

	    if (gtk_obj == NULL) {
		g_list_free(list);
		Py_DECREF(py_list);
		return NULL;
	    }
	    PyList_Append(py_list, gtk_obj);
	    Py_DECREF(gtk_obj);
	}
	g_list_free(list);
	return py_list;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_container_child_get_property
static PyObject *
_wrap_gtk_container_child_get_property(PyGObject *self, PyObject *args)
{
    PyGObject *pychild;
    gchar *property_name;
    GtkContainer *container;
    GtkWidget *child;
    GList *children;
    GObjectClass *class;
    GParamSpec *pspec;
    GValue value = { 0, } ;
    PyObject *ret;
    
    if (!PyArg_ParseTuple(args, "O!s:GtkContainer.child_get_property",
			  &PyGtkWidget_Type, &pychild, 
			  &property_name)) {
	return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);
    
    children = gtk_container_get_children(container);
    if (g_list_find(children, child) == NULL) {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a child");
	return NULL;	
    }
	   
    class = G_OBJECT_GET_CLASS(container);
    pspec = gtk_container_class_find_child_property(class, property_name);
    if (!pspec) {
	gchar buf[512];
	g_snprintf(buf, sizeof(buf),
		   "container does not support property `%s'",
		   property_name);
	
	PyErr_SetString(PyExc_TypeError, buf);
	return NULL;
    }
    
    g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

    gtk_container_child_get_property(container,
				     child,
				     property_name,
				     &value);
    
    ret = pyg_value_as_pyobject(&value, TRUE);
    g_value_unset(&value);
    
    return ret;
}
%%
override gtk_container_child_set_property
static PyObject *
_wrap_gtk_container_child_set_property(PyGObject *self, PyObject *args)
{
    gchar *property_name;
    PyGObject *pychild;
    GtkContainer *container;
    GtkWidget *child;
    GList *children;
    PyGObject *pyvalue;
    GObjectClass *class;
    GParamSpec *pspec;
    GValue value = { 0, } ;
    
    if (!PyArg_ParseTuple(args, "O!sO:GtkContainer.child_set_property",
			  &PyGtkWidget_Type, &pychild, 
			  &property_name, &pyvalue)) {
	return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);
    
    children = gtk_container_get_children(container);
    if (g_list_find(children, child) == NULL) {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a child");
	return NULL;	
    }

    class = G_OBJECT_GET_CLASS(self->obj);
    pspec = gtk_container_class_find_child_property(class, property_name);
    if (!pspec) {
	gchar buf[512];
	g_snprintf(buf, sizeof(buf),
		   "container does not support property `%s'",
		   property_name);
	PyErr_SetString(PyExc_TypeError, buf);
		
	return NULL;
    }
    
    g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
    
    pyg_value_from_pyobject(&value, (PyObject*)pyvalue);
    
    gtk_container_child_set_property(container,
				     child,
				     property_name,
				     &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_container_child_set
static PyObject *
_wrap_gtk_container_child_set(PyGObject *self, PyObject *args)
{
    PyGObject *pychild;
    GtkContainer *container;
    GtkWidget *child;
    GList *children;
    GObjectClass *class;
    int len, i;

    pychild = (PyGObject*)PyTuple_GetItem(args, 0);
    if (!pygobject_check(pychild, &PyGtkWidget_Type)) {
	PyErr_SetString(PyExc_TypeError, "first argument should be a GtkWidget");
	return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);

    children = gtk_container_get_children(container);
    if (g_list_find(children, child) == NULL) {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a child");
	return NULL;	
    }

    len = PyTuple_Size(args);
    if ((len - 1) % 2) {
	PyErr_SetString(PyExc_TypeError,
			"Argument list must be column, value pairs.  No -1 "
			"termination is needed.");
	return NULL;
    }
    
    class = G_OBJECT_GET_CLASS(self->obj);
    for (i = 1; i < len; i+=2) {
	PyObject *py_property = PyTuple_GetItem(args, i);
	PyObject *py_value = PyTuple_GetItem(args, i + 1);
	gchar *property_name;
	GParamSpec *pspec;
	GValue value = { 0 };
	
	if (!PyString_Check(py_property)) {
	    PyErr_SetString(PyExc_TypeError,
			    "Expected string argument for property.");
	    return NULL;
	}

	property_name = PyString_AsString(py_property);
	    
	pspec = gtk_container_class_find_child_property(class, property_name);
	if (!pspec) {
	    gchar buf[512];
	    g_snprintf(buf, sizeof(buf),
		       "container does not support property `%s'",
		       property_name);
	    PyErr_SetString(PyExc_TypeError, buf);
	    
	    return NULL;
	}
	
	g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

	pyg_value_from_pyobject(&value, (PyObject*)py_value);
	
	gtk_container_child_set_property(container, child, property_name, &value);
    
	g_value_unset(&value);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_container_child_get
static PyObject *
_wrap_gtk_container_child_get(PyGObject *self, PyObject *args)
{
    PyGObject *pychild;
    GtkContainer *container;
    GtkWidget *child;
    GList *children;
    GObjectClass *class;
    int len, i;
    PyObject *tuple;
    
    pychild = (PyGObject*)PyTuple_GetItem(args, 0);
    if (!pygobject_check(pychild, &PyGtkWidget_Type)) {
	PyErr_SetString(PyExc_TypeError, "first argument should be a GtkWidget");
	return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);

    children = gtk_container_get_children(container);
    if (g_list_find(children, child) == NULL) {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a child");
	return NULL;	
    }

    len = PyTuple_Size(args);
    tuple = PyTuple_New(len-1);
    class = G_OBJECT_GET_CLASS(self->obj);
    for (i = 1; i < len; i++) {
	PyObject *py_property = PyTuple_GetItem(args, i);
	gchar *property_name;
	GParamSpec *pspec;
	GValue value = { 0 };
	PyObject *item;
	
	if (!PyString_Check(py_property)) {
	    PyErr_SetString(PyExc_TypeError,
			    "Expected string argument for property.");
	    return NULL;
	}

	property_name = PyString_AsString(py_property);
	    
	pspec = gtk_container_class_find_child_property(class, property_name);
	if (!pspec) {
	    gchar buf[512];
	    g_snprintf(buf, sizeof(buf),
		       "container does not support property `%s'",
		       property_name);
	    PyErr_SetString(PyExc_TypeError, buf);
	    
	    return NULL;
	}
	
	g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

	gtk_container_child_get_property(container, child, property_name, &value);
	
	item = pyg_value_as_pyobject(&value, TRUE);
	PyTuple_SetItem(tuple, i-1, item);
	Py_INCREF(item);
	
	g_value_unset(&value);
    }
    
    Py_INCREF(tuple);
    return tuple;
}
%%
override gtk_container_add_with_properties
static PyObject *
_wrap_gtk_container_add_with_properties(PyGObject *self, PyObject *args)
{
    PyGObject *pychild;
    GtkContainer *container;
    GtkWidget *child;
    GObjectClass *class;
    int len, i;

    pychild = (PyGObject*)PyTuple_GetItem(args, 0);
    if (!pygobject_check(pychild, &PyGtkWidget_Type)) {
	PyErr_SetString(PyExc_TypeError, "first argument should be a GtkWidget");
	return NULL;
    }

    container = GTK_CONTAINER(self->obj);
    child = GTK_WIDGET(pychild->obj);

    len = PyTuple_Size(args);
    if ((len - 1) % 2) {
	PyErr_SetString(PyExc_TypeError,
			"Argument list must be column, value pairs.  No -1 "
			"termination is needed.");
	return NULL;
    }
    
    gtk_widget_freeze_child_notify(child);

    gtk_container_add(container, child);
    
    class = G_OBJECT_GET_CLASS(self->obj);
    for (i = 1; i < len; i+=2) {
	PyObject *py_property = PyTuple_GetItem(args, i);
	PyObject *py_value = PyTuple_GetItem(args, i + 1);
	gchar *property_name;
	GParamSpec *pspec;
	GValue value = { 0 };
	
	if (!PyString_Check(py_property)) {
	    PyErr_SetString(PyExc_TypeError,
			    "Expected string argument for property.");
	    return NULL;
	}

	property_name = PyString_AsString(py_property);
	    
	pspec = gtk_container_class_find_child_property(class, property_name);
	if (!pspec) {
	    gchar buf[512];
	    g_snprintf(buf, sizeof(buf),
		       "container does not support property `%s'",
		       property_name);
	    PyErr_SetString(PyExc_TypeError, buf);
	    
	    return NULL;
	}
	
	g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

	pyg_value_from_pyobject(&value, (PyObject*)py_value);
	
	gtk_container_child_set_property(container, child, property_name, &value);
    
	g_value_unset(&value);
    }

    gtk_widget_thaw_child_notify(child);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_container_foreach
static void
pygtk_container_foreach_marshal(GtkWidget *widget,
				gpointer data)
{
    PyGtkCustomNotify *cunote = data;
    PyObject *py_widget, *retobj;

    g_assert(cunote->func);

    py_widget = pygobject_new((GObject*)widget);
    if (cunote->data)
	retobj = PyEval_CallFunction(cunote->func, "(NO)",
				     py_widget, cunote->data);
    else
	retobj = PyEval_CallFunction(cunote->func, "(N)",
				     py_widget);

    if (retobj == NULL) {
	PyErr_Print();
	PyErr_Clear();
    }
    
    Py_XDECREF(retobj);
}
static PyObject *
_wrap_gtk_container_foreach(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify cunote;
    
    if(!PyArg_ParseTuple(args, "O|O:GtkContainer.foreach",
			 &pyfunc, &pyarg))
	return NULL;
    
    cunote.func = pyfunc;
    cunote.data = pyarg;
    gtk_container_foreach(GTK_CONTAINER(self->obj),
			  pygtk_container_foreach_marshal,
			  &cunote);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_label_get noargs
static PyObject *
_wrap_gtk_label_get(PyGObject *self)
{
    gchar *text = NULL;

    gtk_label_get(GTK_LABEL(self->obj), &text);
    if (text)
	return PyString_FromString(text);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_label_get_selection_bounds noargs
static PyObject *
_wrap_gtk_label_get_selection_bounds(PyGObject *self)
{
    int start, end;

    if (!gtk_label_get_selection_bounds(GTK_LABEL(self->obj), &start, &end)) {
       return Py_BuildValue ("()");
    }
    
    return Py_BuildValue("(ii)", start, end);
}
%%
override gtk_label_get_layout_offsets noargs
static PyObject *
_wrap_gtk_label_get_layout_offsets(PyGObject *self)
{
    gint x;
    gint y;

    gtk_label_get_layout_offsets(GTK_LABEL(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gtk_spin_button_get_increments noargs
static PyObject *
_wrap_gtk_spin_button_get_increments(PyGObject *self)
{
    gdouble step;
    gdouble page;

    gtk_spin_button_get_increments(GTK_SPIN_BUTTON(self->obj), &step, &page);
    return Py_BuildValue("(dd)", step, page);
}
%%
override gtk_spin_button_get_range noargs
static PyObject *
_wrap_gtk_spin_button_get_range(PyGObject *self)
{
    gdouble min;
    gdouble max;

    gtk_spin_button_get_range(GTK_SPIN_BUTTON(self->obj), &min, &max);
    return Py_BuildValue("(dd)", min, max);
}
%%
override gtk_window_list_toplevels noargs
static PyObject *
_wrap_gtk_window_list_toplevels(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *py_list;
    PyObject *gtk_obj;

    list = gtk_window_list_toplevels();

    if ((py_list = PyList_New(0)) == NULL) {
	g_list_free(list);
	return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
	gtk_obj = pygobject_new(G_OBJECT(tmp->data));
	if (gtk_obj == NULL) {
	    g_list_free(list);
	    Py_DECREF(py_list);
	    return NULL;
	}
	PyList_Append(py_list, gtk_obj);
	Py_DECREF(gtk_obj);
    }
    g_list_free(list);
    return py_list;
}
%%
override gtk_window_set_geometry_hints kwargs
static PyObject *
_wrap_gtk_window_set_geometry_hints(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "geometry_widget", "min_width", "min_height",
			      "max_width", "max_height", "base_width",
			      "base_height", "width_inc", "height_inc",
			      "min_aspect", "max_aspect", NULL };
    PyObject *py_geometry_widget = Py_None;
    GtkWidget *geometry_widget = NULL;
    gint min_width = -1, min_height = -1, max_width = -1, max_height = -1;
    gint base_width = -1, base_height = -1, width_inc = -1, height_inc = -1;
    gdouble min_aspect = -1.0, max_aspect = -1.0;
    GdkGeometry geometry = { 0 };
    GdkWindowHints geom_mask = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
			"|Oiiiiiiiidd:GtkWindow.set_geometry_hints", kwlist,
				     &py_geometry_widget, &min_width,
				     &min_height, &max_width, &max_height,
				     &base_width, &base_height, &width_inc,
				     &height_inc, &min_aspect, &max_aspect))
	return NULL;
    if (pygobject_check(py_geometry_widget, &PyGtkWidget_Type))
	geometry_widget = GTK_WIDGET(pygobject_get(py_geometry_widget));
    else if (py_geometry_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"geometry_widget must be a GtkWidget or None");
	return NULL;
    }
    if (min_width >= 0 || min_height >= 0) {
	geometry.min_width = MAX(min_width, 0);
	geometry.min_height = MAX(min_height, 0);
	geom_mask |= GDK_HINT_MIN_SIZE;
    }
    if (max_width >= 0 || max_height >= 0) {
	geometry.max_width = MAX(max_width, 0);
	geometry.max_height = MAX(max_height, 0);
	geom_mask |= GDK_HINT_MAX_SIZE;
    }
    if (base_width >= 0 || base_height >= 0) {
	geometry.base_width = MAX(base_width, 0);
	geometry.base_height = MAX(base_height, 0);
	geom_mask |= GDK_HINT_BASE_SIZE;
    }
    if (width_inc >= 0 || height_inc >= 0) {
	geometry.width_inc = MAX(width_inc, 0);
	geometry.height_inc = MAX(height_inc, 0);
	geom_mask |= GDK_HINT_RESIZE_INC;
    }
    if (min_aspect >= 0.0 || max_aspect >= 0.0) {
	if (min_aspect <= 0.0 || max_aspect <= 0.0) {
	    PyErr_SetString(PyExc_TypeError, "aspect ratios must be positive");
	    return NULL;
	}
	geometry.min_aspect = min_aspect;
	geometry.max_aspect = max_aspect;
	geom_mask |= GDK_HINT_ASPECT;
    }
    gtk_window_set_geometry_hints(GTK_WINDOW(self->obj), geometry_widget,
				  &geometry, geom_mask);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_window_get_position
static PyObject *
_wrap_gtk_window_get_position(PyGObject *self)
{
    gint root_x, root_y;

    gtk_window_get_position(GTK_WINDOW(self->obj), &root_x, &root_y);
    return Py_BuildValue("(ii)", root_x, root_y);
}
%%
override gtk_window_get_size
static PyObject *
_wrap_gtk_window_get_size(PyGObject *self)
{
    gint width, height;

    gtk_window_get_size(GTK_WINDOW(self->obj), &width, &height);
    return Py_BuildValue("(ii)", width, height);
}
%%
override gtk_window_get_default_size
static PyObject *
_wrap_gtk_window_get_default_size(PyGObject *self)
{
    gint width, height;

    gtk_window_get_default_size(GTK_WINDOW(self->obj), &width, &height);
    return Py_BuildValue("(ii)", width, height);
}
%%
override gtk_box_query_child_packing kwargs
static PyObject *
_wrap_gtk_box_query_child_packing(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *pychild;
    GtkWidget *child;
    GList *children;
    gboolean expand, fill;
    guint padding;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkBox.query_child_packing", kwlist,
				     &PyGtkWidget_Type, &pychild)) {
	return NULL;
    }

    child = GTK_WIDGET(pychild->obj);
    children = gtk_container_get_children(GTK_CONTAINER(self->obj));
    if (g_list_find(children, child) == NULL) {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a child");
	return NULL;	
    }
    gtk_box_query_child_packing(GTK_BOX(self->obj),
				child, &expand, &fill,
				&padding, &pack_type);
    return Py_BuildValue("(iiii)", (int)expand, (int)fill, padding, pack_type);
}
%%
ignore gtk_clist_new
%%
override gtk_clist_new_with_titles kwargs
static int
_wrap_gtk_clist_new_with_titles(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "count", "titles", NULL };
    int count = 1, i;
    PyObject *py_list = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iO:GtkCList.__init__",
				     kwlist, &count, &py_list))
	return -1;
    if (py_list) {
	gchar **list;

	if (!PySequence_Check(py_list)) {
	    PyErr_SetString(PyExc_TypeError,"2nd argument not a sequence");
	    return -1;
	}
	if (PySequence_Length(py_list) < count) {
	    PyErr_SetString(PyExc_TypeError, "sequence not long enough");
	    return -1;
	}
	list = g_new(gchar *, count);
	for (i = 0; i < count; i++) {
	    PyObject *item = PySequence_GetItem(py_list, i);

	    Py_DECREF(item); /* PySequence_GetItem INCREF's */
	    if (!PyString_Check(item) && !PyUnicode_Check(item)) {
		PyErr_SetString(PyExc_TypeError,
				"sequence item not a string or unicode object");
		g_free(list);
		return -1;
	    }
	    list[i] = PyString_AsString(item);
	}
	self->obj = (GObject *)gtk_clist_new_with_titles(count, list);
	g_free(list);
    } else
	self->obj = (GObject *)gtk_clist_new(count);
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError,"could not create GtkCList object");
	return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_clist_get_text kwargs
static PyObject *
_wrap_gtk_clist_get_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    char *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_text",
				     kwlist, &r, &c))
	return NULL;
    if (!gtk_clist_get_text(GTK_CLIST(self->obj), r, c, &text) || text==NULL) {
	PyErr_SetString(PyExc_ValueError, "can't get text value");
	return NULL;
    }
    return PyString_FromString(text);
}
%%
override gtk_clist_get_pixmap kwargs
static PyObject *
_wrap_gtk_clist_get_pixmap(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_pixmap",
				     kwlist, &r, &c))
	return NULL;
    if (!gtk_clist_get_pixmap(GTK_CLIST(self->obj), r, c,
			      &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixmap value");
	return NULL;
    }
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_clist_get_pixtext kwargs
static PyObject *
_wrap_gtk_clist_get_pixtext(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    gchar *text;
    guint8 spacing;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_pixtext",
				     kwlist, &r, &c))
	return NULL;
    if (!gtk_clist_get_pixtext(GTK_CLIST(self->obj), r, c,
			      &text, &spacing, &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixtext value");
	return NULL;
    }
    return Py_BuildValue("(ziNN)", text, (gint)spacing,
			 pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_clist_prepend kwargs
static PyObject *
_wrap_gtk_clist_prepend(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    int col, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCList.prepend",
				     kwlist, &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item) && !PyUnicode_Check(item)) {
	    PyErr_SetString(PyExc_TypeError,
			    "sequence item not a string or unicode object");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_prepend(GTK_CLIST(self->obj), list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_append kwargs
static PyObject *
_wrap_gtk_clist_append(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    int col, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCList.append",
				     kwlist, &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item) && !PyUnicode_Check(item)) {
	    PyErr_SetString(PyExc_TypeError,
			    "sequence item not a string or unicode object");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_append(GTK_CLIST(self->obj), list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_insert kwargs
static PyObject *
_wrap_gtk_clist_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "text", NULL };
    int col, row, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iO:GtkCList.insert",
				     kwlist, &row, &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item) && !PyUnicode_Check(item)) {
	    PyErr_SetString(PyExc_TypeError,
			    "sequence item not a string or unicode object");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_insert(GTK_CLIST(self->obj), row, list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_set_row_data kwargs
static PyObject *
_wrap_gtk_clist_set_row_data(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "row", "data", NULL };
    int row;
    PyObject *data;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iO:GtkCList.set_row_data",
				     kwlist, &row, &data))
	return NULL;
    Py_INCREF(data);
    gtk_clist_set_row_data_full(GTK_CLIST(self->obj), row, data,
				(GtkDestroyNotify)pyg_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clist_get_row_data kwargs
static PyObject *
_wrap_gtk_clist_get_row_data(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "row", NULL };
    PyObject *ret;
    int row;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkCList.get_row_data",
				     kwlist, &row))
        return NULL;
    ret = gtk_clist_get_row_data(GTK_CLIST(self->obj), row);
    if (!ret) ret = Py_None;
    Py_INCREF(ret);
    return ret;
}
%%
override gtk_clist_find_row_from_data kwargs
static PyObject *
_wrap_gtk_clist_find_row_from_data(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "data", NULL };
    PyObject *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkCList.find_row_from_data", kwlist,
				     &data))
        return NULL;
    return PyInt_FromLong(gtk_clist_find_row_from_data(
				GTK_CLIST(self->obj), data));
}
%%
override gtk_clist_get_selection_info kwargs
static PyObject *
_wrap_gtk_clist_get_selection_info(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    gint x, y, row, column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "ii:GtkCList.get_selection_info", kwlist,
				     &x, &y))
	return NULL;
    if (gtk_clist_get_selection_info(GTK_CLIST(self->obj), x, y,
				     &row, &column))
	return Py_BuildValue("(ii)", row, column);
    else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
override-attr GtkCList.selection
static PyObject *
_wrap_gtk_clist__get_selection(PyGObject *self, void *closure)
{
    guint row;
    GList *selection;
    PyObject *py_int, *ret = PyList_New(0);

    if (ret == NULL)
	return NULL;

    for (selection = GTK_CLIST(self->obj)->selection; selection != NULL;
	 selection = selection->next) {
	row = GPOINTER_TO_UINT(selection->data);

	py_int = PyInt_FromLong(row);

	if (!py_int) {
	    Py_DECREF(ret);
	    return NULL;
	}

	PyList_Append(ret, py_int);
	Py_DECREF(py_int);
    }
    return ret;
}
%%
override gtk_combo_set_popdown_strings kwargs
static PyObject *
_wrap_gtk_combo_set_popdown_strings(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "strings", NULL };
    PyObject *list;
    GList *glist = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkCombo.set_popdown_strings", kwlist,
				     &list))
	return NULL;
    if (!PySequence_Check(list)) {
	PyErr_SetString(PyExc_TypeError, "first argument must be a sequence");
	return NULL;
    }
    len = PySequence_Length(list);
    for (i = 0; i < len; i++) {
	PyObject *item = PySequence_GetItem(list, i);

	Py_DECREF(item);
	if (!PyString_Check(item) && !PyUnicode_Check(item)) {
	    PyErr_SetString(PyExc_TypeError,
			    "sequence item not a string or unicode object");
	    g_list_free(glist);
	    return NULL;
	}
	glist = g_list_append(glist, PyString_AsString(item));
    }
    gtk_combo_set_popdown_strings(GTK_COMBO(self->obj), glist);
    g_list_free(glist);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_curve_get_vector kwargs
static PyObject *
_wrap_gtk_curve_get_vector(PyGObject *self, PyObject *args,
			   PyObject *kwargs)
{
    static char *kwlist[] = { "size", NULL };
    int size = -1, i;
    gfloat *vector;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|i:GtkCurve.get_vector", kwlist,
				     &size))
	return NULL;
    if (size < 0) size = GTK_CURVE(self->obj)->num_points;
    vector = g_new(gfloat, size);
    gtk_curve_get_vector(GTK_CURVE(self->obj), size, vector);
    ret = PyTuple_New(size);
    for (i = 0; i < size; i++)
	PyTuple_SetItem(ret, i, PyFloat_FromDouble(vector[i]));
    g_free(vector);
    return ret;
}
%%
override gtk_curve_set_vector kwargs
static PyObject *
_wrap_gtk_curve_set_vector(PyGObject *self, PyObject *args,
			   PyObject *kwargs)
{
    static char *kwlist[] = { "vector", NULL };
    PyObject *seq;
    int size, i;
    gfloat *vector;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCurve.set_vector",
				     kwlist, &seq))
	return NULL;
    if (!PySequence_Check(seq)) {
	PyErr_SetString(PyExc_TypeError, "1st argument is not a sequence");
	return NULL;
    }
    size = PySequence_Length(seq);
    vector = g_new(gfloat, size);
    for (i = 0; i < size; i++) {
	PyObject *item = PySequence_GetItem(seq, i);

	Py_DECREF(item);
	item = PyNumber_Float(item); /* item has a ref now */
	if (item == NULL) {
	    g_free(vector);
	    return NULL;
	}
	vector[i] = PyFloat_AsDouble(item);
	Py_DECREF(item);
    }
    gtk_curve_set_vector(GTK_CURVE(self->obj), size, vector);
    g_free(vector);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_model_get_iter kwargs
static PyObject *
_wrap_gtk_tree_model_get_iter(PyGObject *self, PyObject *args,PyObject *kwargs)
{
    static char *kwlist[] = { "path", NULL };
    PyObject *py_path;
    GtkTreeIter iter;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTreeModel.get_iter",
				     kwlist, &py_path))
	return NULL;

    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
	PyErr_SetString(PyExc_TypeError, "GtkTreeModel.get_iter requires a tree path as its argument");
	return NULL;
    }
    if (gtk_tree_model_get_iter(GTK_TREE_MODEL(self->obj), &iter, path)) {
	gtk_tree_path_free(path);
	return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    } else {
	gtk_tree_path_free(path);
	PyErr_SetString(PyExc_ValueError, "invalid tree path");
	return NULL;
    }
}
%%
override gtk_tree_model_get_iter_from_string kwargs
static PyObject *
_wrap_gtk_tree_model_get_iter_from_string(PyGObject *self, PyObject *args,
					  PyObject *kwargs)
{
    static char *kwlist[] = { "path_string", NULL };
    const gchar *path_string;
    GtkTreeIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:GtkTreeModel.get_iter_from_string",
				     kwlist, &path_string))
	return NULL;

    if (gtk_tree_model_get_iter_from_string(GTK_TREE_MODEL(self->obj), &iter,
					    path_string)) {
	return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    } else {
	PyErr_SetString(PyExc_ValueError, "invalid tree path");
	return NULL;
    }
}
%%
override gtk_tree_model_get_value kwargs
static PyObject *
_wrap_gtk_tree_model_get_value(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    static char *kwlist[] = { "iter", "column", NULL };
    PyObject *iter, *ret;
    gint column;
    GValue value = { 0, };

    if (!PyArg_ParseTupleAndKeywords(args,kwargs, "Oi:GtkTreeModel.get_value",
				     kwlist, &iter, &column))
	return NULL;
    if (column < 0 ||
	column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	PyErr_SetString(PyExc_ValueError, "column number is out of range");
	return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    gtk_tree_model_get_value(GTK_TREE_MODEL(self->obj),
			     pyg_boxed_get(iter, GtkTreeIter), column, &value);
    ret = pyg_value_as_pyobject(&value, TRUE);
    g_value_unset(&value);
    return ret;
}
%%
override-slot GtkTreeModel.tp_as_number
static int
_wrap_gtk_tree_model_tp_nonzero(PyGObject *self)
{
    return TRUE;
}
static PyNumberMethods _wrap_gtk_tree_model_tp_as_number = {
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (ternaryfunc)0,
    (unaryfunc)0,
    (unaryfunc)0,
    (unaryfunc)0,
    (inquiry)_wrap_gtk_tree_model_tp_nonzero,
    (unaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (binaryfunc)0,
    (coercion)0,
    (unaryfunc)0,
    (unaryfunc)0,
    (unaryfunc)0,
    (unaryfunc)0,
    (unaryfunc)0
};
%%
override-slot GtkTreeModel.tp_as_mapping
static int
_wrap_gtk_tree_model_tp_length(PyGObject *self)
{
    return gtk_tree_model_iter_n_children(GTK_TREE_MODEL(self->obj), NULL);
}
static PyObject *
_wrap_gtk_tree_model_tp_getitem(PyGObject *self, PyObject *item)
{
    GtkTreePath *path;
    GtkTreeIter iter;
    PyObject *ret = NULL;

    if (pyg_boxed_check(item, GTK_TYPE_TREE_ITER)) {
	return _pygtk_tree_model_row_new(GTK_TREE_MODEL(self->obj),
					 pyg_boxed_get(item, GtkTreeIter));
    }

    path = pygtk_tree_path_from_pyobject(item);
    if (!path) {
	PyErr_SetString(PyExc_TypeError,
			"could not parse subscript as a tree path");
	return  NULL;
    }
    if (gtk_tree_model_get_iter(GTK_TREE_MODEL(self->obj), &iter, path)) {
	ret = _pygtk_tree_model_row_new(GTK_TREE_MODEL(self->obj), &iter);
    } else {
	PyErr_SetString(PyExc_IndexError, "could not find tree path");
	ret = NULL;
    }
    gtk_tree_path_free(path);
    return ret;
}
static PyMappingMethods _wrap_gtk_tree_model_tp_as_mapping = {
    (inquiry)_wrap_gtk_tree_model_tp_length,
    (binaryfunc)_wrap_gtk_tree_model_tp_getitem,
    (objobjargproc)0
};
%%
override-slot GtkTreeModel.tp_iter
static PyObject *
_wrap_gtk_tree_model_tp_iter(PyGObject *self)
{
    return _pygtk_tree_model_row_iter_new(GTK_TREE_MODEL(self->obj), NULL);
}
%%
override gtk_tree_sortable_get_sort_column_id noargs
static PyObject *
_wrap_gtk_tree_sortable_get_sort_column_id(PyGObject *self)
{
    gboolean ret;
    gint sort_column_id;
    GtkSortType order;
	
    ret = gtk_tree_sortable_get_sort_column_id(GTK_TREE_SORTABLE(self->obj),
					       &sort_column_id, &order);

    /* if we don't have a sort column set, return (None, None) */
    if (ret)
	return Py_BuildValue("(ii)", sort_column_id, order);
    else
	return Py_BuildValue("(OO)", Py_None, Py_None);
}
%%
override gtk_tree_sortable_set_sort_func
static gint
pygtk_tree_sortable_sort_cb(GtkTreeModel *model, GtkTreeIter *iter1,
			    GtkTreeIter *iter2, gpointer user_data)
{
    PyGtkCustomNotify *cunote = user_data;
    PyObject *py_model, *py_iter2, *py_iter1, *retobj;
    gint ret = 0;

    g_assert(cunote->func);

    py_model = pygobject_new((GObject *)model);
    py_iter1 = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter1, TRUE, TRUE);
    py_iter2 = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter2, TRUE, TRUE);

    if (cunote->data) {
	retobj = PyEval_CallFunction(cunote->func, "(NNNO)", py_model,
				     py_iter1, py_iter2, cunote->data);
    } else {
	retobj = PyEval_CallFunction(cunote->func, "(NNN)", py_model,
				     py_iter1, py_iter2);
    }

    if (retobj)
	ret = PyInt_AsLong(retobj);
    if (PyErr_Occurred()) {
	PyErr_Print();
	PyErr_Clear();
	ret = 0;
    }
    Py_XDECREF(retobj);
    return ret;
}
static PyObject *
_wrap_gtk_tree_sortable_set_sort_func(PyGObject *self, PyObject *args)
{
    gint column;
    PyObject *callback, *data = NULL;
    PyGtkCustomNotify *cunote;

    if (!PyArg_ParseTuple(args, "iO|O:GtkTreeSortable.set_sort_func",
			  &column, &callback, &data))
	return NULL;

    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be a callable object");
	return NULL;
    }
    cunote = g_new(PyGtkCustomNotify, 1);
    Py_INCREF(callback);
    cunote->func = callback;
    Py_XINCREF(data);
    cunote->data = data;

    gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(self->obj), column,
				    pygtk_tree_sortable_sort_cb, cunote,
				    pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_sortable_set_default_sort_func
static PyObject *
_wrap_gtk_tree_sortable_set_default_sort_func(PyGObject *self, PyObject *args)
{
    PyObject *callback, *data = NULL;
    PyGtkCustomNotify *cunote;

    if (!PyArg_ParseTuple(args, "O|O:GtkTreeSortable.set_default_sort_func",
			  &callback, &data))
	return NULL;

    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "callback must be a callable object");
	return NULL;
    }
    cunote = g_new(PyGtkCustomNotify, 1);
    Py_INCREF(callback);
    cunote->func = callback;
    Py_XINCREF(data);
    cunote->data = data;

    gtk_tree_sortable_set_default_sort_func(GTK_TREE_SORTABLE(self->obj),
					    pygtk_tree_sortable_sort_cb,
					    cunote,
					    pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_list_store_newv
%%
override gtk_list_store_new
static PyObject *
_wrap_gtk_list_store_new(PyGObject *self, PyObject *args)
{
    guint len, i;
    GType *column_types;

    len = PyTuple_Size(args);
    column_types = g_new(GType, len);
    for (i = 0; i < len; i++) {
	PyObject *item = PyTuple_GetItem(args, i);

	column_types[i] = pyg_type_from_object(item);
	if (column_types[i] == 0) {
	    g_free(column_types);
	    return NULL;
	}
    }
    self->obj = (GObject *)gtk_list_store_newv(len, column_types);
    g_free(column_types);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkListStore object");
        return NULL;
    }
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_list_store_set_valist
%%
override gtk_list_store_set
static PyObject *
_wrap_gtk_list_store_set(PyGObject *self, PyObject *args)
{
    PyObject *iter;
    int len, i;

    iter = PyTuple_GetItem(args, 0);
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    len = PyTuple_Size(args);
    if ((len - 1) % 2) {
	PyErr_SetString(PyExc_TypeError,
			"Argument list must be column, value pairs.  No -1 "
			"termination is needed.");
	return NULL;
    }
    for (i = 1; i < len; i+=2) {
	gint column;
	GValue value = { 0 };
	PyObject *py_column = PyTuple_GetItem(args, i);
	PyObject *py_value = PyTuple_GetItem(args, i + 1);

	if (!PyInt_Check(py_column)) {
	    PyErr_SetString(PyExc_TypeError,
			    "Expected numeric argument for column.");
	    return NULL;
	}
	column = PyInt_AsLong(py_column);
	if (column < 0 ||
	    column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	    PyErr_SetString(PyExc_ValueError, "column number is out of range");
	    return NULL;
	}
	g_value_init(&value,
		     gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),
						    column));
	if (pyg_value_from_pyobject(&value, py_value)) {
	    PyErr_SetString(PyExc_TypeError,
			    "value is of the wrong type for this column");
	    return NULL;
	}
	gtk_list_store_set_value(GTK_LIST_STORE(self->obj),
				 pyg_boxed_get(iter, GtkTreeIter), column, &value);
	g_value_unset(&value);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_store_set_value kwargs
static PyObject *
_wrap_gtk_list_store_set_value(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "column", "value", NULL };
    PyObject *iter, *pyvalue;
    gint column;
    GValue value = { 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OiO:GtkListStore.set_value",
				     kwlist, &iter, &column, &pyvalue))
	return NULL;
    if (column < 0 ||
	column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	PyErr_SetString(PyExc_ValueError, "column number is out of range");
	return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    g_value_init(&value,
		 gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),
						column));
    if (pyg_value_from_pyobject(&value, pyvalue)) {
	PyErr_SetString(PyExc_TypeError,
			"value is of the wrong type for this column");
	return NULL;
    }
    gtk_list_store_set_value(GTK_LIST_STORE(self->obj),
			     pyg_boxed_get(iter, GtkTreeIter), column, &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore
  gtk_list_store_setv
%%
  override gtk_list_store_insert kwargs
static PyObject *
_wrap_gtk_list_store_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", NULL };
    GtkTreeIter iter;
    gint position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkListStore.insert",
				     kwlist, &position))
	return NULL;
    gtk_list_store_insert(GTK_LIST_STORE(self->obj), &iter, position);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_insert_before kwargs
static PyObject *
_wrap_gtk_list_store_insert_before(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "sibling", NULL };
    PyObject *sibling;
    GtkTreeIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkListStore.insert_before",
				     kwlist, &sibling))
	return NULL;
    if (!pyg_boxed_check(sibling, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    gtk_list_store_insert_before(GTK_LIST_STORE(self->obj), &iter,
				 pyg_boxed_get(sibling, GtkTreeIter));
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_insert_after kwargs
static PyObject *
_wrap_gtk_list_store_insert_after(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "sibling", NULL };
    PyObject *sibling;
    GtkTreeIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkListStore.insert_after",
				     kwlist, &sibling))
	return NULL;
    if (!pyg_boxed_check(sibling, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    gtk_list_store_insert_after(GTK_LIST_STORE(self->obj), &iter,
				pyg_boxed_get(sibling, GtkTreeIter));
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_prepend noargs
static PyObject *
_wrap_gtk_list_store_prepend(PyGObject *self)
{
    GtkTreeIter iter;

    gtk_list_store_prepend(GTK_LIST_STORE(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_append noargs
static PyObject *
_wrap_gtk_list_store_append(PyGObject *self)
{
    GtkTreeIter iter;

    gtk_list_store_append(GTK_LIST_STORE(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
ignore gtk_tree_store_newv
%%
override gtk_tree_store_new
static PyObject *
_wrap_gtk_tree_store_new(PyGObject *self, PyObject *args)
{
    guint len, i;
    GType *column_types;

    len = PyTuple_Size(args);
    column_types = g_new(GType, len);
    for (i = 0; i < len; i++) {
	PyObject *item = PyTuple_GetItem(args, i);

	column_types[i] = pyg_type_from_object(item);
	if (column_types[i] == 0) {
	    g_free(column_types);
	    return NULL;
	}
    }
    self->obj = (GObject *)gtk_tree_store_newv(len, column_types);
    g_free(column_types);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkTreeStore object");
        return NULL;
    }
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_tree_store_set_valist
%%
override gtk_tree_store_set
static PyObject *
_wrap_gtk_tree_store_set(PyGObject *self, PyObject *args)
{
    PyObject *iter;
    int len, i;

    iter = PyTuple_GetItem(args, 0);

    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    len = PyTuple_Size(args);
    if ((len - 1) % 2) {
	PyErr_SetString(PyExc_TypeError,
			"Argument list must be column, value pairs.  No -1 "
			"termination is needed.");
	return NULL;
    }
    for (i = 1; i < len; i+=2) {
	gint column;
	GValue value = { 0 };
	PyObject *py_column = PyTuple_GetItem(args, i);
	PyObject *py_value = PyTuple_GetItem(args, i + 1);

	if (!PyInt_Check(py_column)) {
	    PyErr_SetString(PyExc_TypeError,
			    "Expected numeric argument for column.");
	    return NULL;
	}
	column = PyInt_AsLong(py_column);
	if (column < 0 ||
	    column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	    PyErr_SetString(PyExc_ValueError, "column number is out of range");
	    return NULL;
	}
	g_value_init(&value,
		     gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),
						    column));
	if (pyg_value_from_pyobject(&value, py_value)) {
	    PyErr_SetString(PyExc_TypeError,
			    "value is of the wrong type for this column");
	    return NULL;
	}
	gtk_tree_store_set_value(GTK_TREE_STORE(self->obj),
				 pyg_boxed_get(iter, GtkTreeIter), column,
				 &value);
	g_value_unset(&value);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_store_set_value kwargs
static PyObject *
_wrap_gtk_tree_store_set_value(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "column", "value", NULL };
    PyObject *iter, *pyvalue;
    gint column;
    GValue value = { 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OiO:GtkTreeStore.set_value",
				     kwlist, &iter, &column, &pyvalue))
	return NULL;
    if (column < 0 ||
	column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	PyErr_SetString(PyExc_ValueError, "column number is out of range");
	return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    g_value_init(&value,
		 gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),
						column));
    if (pyg_value_from_pyobject(&value, pyvalue)) {
	PyErr_SetString(PyExc_TypeError,
			"value is of the wrong type for this column");
	return NULL;
    }
    gtk_tree_store_set_value(GTK_TREE_STORE(self->obj),
			     pyg_boxed_get(iter, GtkTreeIter), column, &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore
  gtk_tree_store_setv
%%
override gtk_tree_store_insert kwargs
static PyObject *
_wrap_gtk_tree_store_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "position", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;
    gint position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oi:GtkTreeStore.insert",
				     kwlist, &py_parent, &position))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_insert(GTK_TREE_STORE(self->obj), &iter, parent, position);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_insert_before kwargs
static PyObject *
_wrap_gtk_tree_store_insert_before(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", NULL };
    PyObject *py_parent, *py_sibling;
    GtkTreeIter iter, *parent = NULL, *sibling = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkTreeStore.insert_before",
				     kwlist, &py_parent, &py_sibling))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    if (pyg_boxed_check(py_sibling, GTK_TYPE_TREE_ITER))
	sibling = pyg_boxed_get(py_sibling, GtkTreeIter);
    else if (py_sibling != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sibling must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_insert_before(GTK_TREE_STORE(self->obj), &iter, parent,
				 sibling);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_insert_after kwargs
static PyObject *
_wrap_gtk_tree_store_insert_after(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", NULL };
    PyObject *py_parent, *py_sibling;
    GtkTreeIter iter, *parent = NULL, *sibling = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkTreeStore.insert_after",
				     kwlist, &py_parent, &py_sibling))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    if (pyg_boxed_check(py_sibling, GTK_TYPE_TREE_ITER))
	sibling = pyg_boxed_get(py_sibling, GtkTreeIter);
    else if (py_sibling != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sibling must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_insert_after(GTK_TREE_STORE(self->obj), &iter, parent,
				sibling);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_prepend kwargs
static PyObject *
_wrap_gtk_tree_store_prepend(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTreeStore.prepend",
				     kwlist, &py_parent))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_append kwargs
static PyObject *
_wrap_gtk_tree_store_append(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTreeStore.append",
				     kwlist, &py_parent))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_model_get_iter_first noargs
static PyObject *
_wrap_gtk_tree_model_get_iter_first(PyGObject *self)
{
    GtkTreeIter iter;

    if (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->obj), &iter))
	return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
override gtk_tree_model_iter_next kwargs
static PyObject *
_wrap_gtk_tree_model_iter_next(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "iter", NULL };
    PyObject *py_iter;
    GtkTreeIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkTreeModel.iter_next", kwlist,
				     &py_iter))
        return NULL;
    if (pyg_boxed_check(py_iter, GTK_TYPE_TREE_ITER))
        iter = *pyg_boxed_get(py_iter, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "iter should be a GtkTreeIter");
        return NULL;
    }

    if (gtk_tree_model_iter_next(GTK_TREE_MODEL(self->obj), &iter))
	return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
override gtk_tree_model_iter_children kwargs
static PyObject *
_wrap_gtk_tree_model_iter_children(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "parent", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkTreeModel.iter_children", kwlist,
				     &py_parent))
        return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
        parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkTreeIter");
        return NULL;
    }

    if (gtk_tree_model_iter_children(GTK_TREE_MODEL(self->obj),
				     &iter, parent))
	return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
override gtk_tree_model_iter_nth_child kwargs
static PyObject *
_wrap_gtk_tree_model_iter_nth_child(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "n", NULL };
    PyObject *py_parent;
    gint n;
    GtkTreeIter iter, *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oi:GtkTreeModel.iter_nth_child", kwlist,
				     &py_parent, &n))
        return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
        parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkTreeIter");
        return NULL;
    }

    if (gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(self->obj),
				     &iter, parent, n))
	return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
override gtk_tree_model_iter_parent kwargs
static PyObject *
_wrap_gtk_tree_model_iter_parent(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyObject *py_child;
    GtkTreeIter iter, *child = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkTreeModel.iter_parent", kwlist,
				     &py_child))
        return NULL;
    if (pyg_boxed_check(py_child, GTK_TYPE_TREE_ITER))
        child = pyg_boxed_get(py_child, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "child should be a GtkTreeIter");
        return NULL;
    }

    if (gtk_tree_model_iter_parent(GTK_TREE_MODEL(self->obj),
				   &iter, child))
	return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
override gtk_tree_model_foreach
static gboolean
pygtk_tree_foreach_marshal(GtkTreeModel *model,
			   GtkTreePath *path,
			   GtkTreeIter *iter,
			   gpointer data)
{
    PyGtkCustomNotify *cunote = data;
    PyObject *py_model, *py_path, *py_iter, *retobj;
    gboolean ret;

    g_assert(cunote->func);
    
    py_model = pygobject_new((GObject *)model);
    py_path = pygtk_tree_path_to_pyobject(path);
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, TRUE, TRUE);
    if (cunote->data)
	retobj = PyEval_CallFunction(cunote->func, "(NNNO)",
				     py_model, py_path, py_iter,
				     cunote->data);
    else
	retobj = PyEval_CallFunction(cunote->func, "(NNN)",
				     py_model, py_path, py_iter);

    if (retobj != NULL) {
	ret = PyObject_IsTrue(retobj);
	Py_DECREF(retobj);
    } else {
	ret = TRUE;
    }
    return ret;
}
static PyObject *
_wrap_gtk_tree_model_foreach(PyGObject *self, PyObject *args)
{
    static gboolean pygtk_tree_foreach_marshal(GtkTreeModel *model,
					   GtkTreePath *path,
					   GtkTreeIter *iter,
					   gpointer data);
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify cunote;

    if(!PyArg_ParseTuple(args, "O|O:GtkTreeModel.foreach",
			 &pyfunc, &pyarg))
	return NULL;

    cunote.func = pyfunc;
    cunote.data = pyarg;
    gtk_tree_model_foreach(GTK_TREE_MODEL(self->obj),
			   pygtk_tree_foreach_marshal, &cunote);

    if (PyErr_Occurred())
	return NULL;

    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore
  gtk_tree_view_new
%%
override gtk_tree_view_column_new kwargs
static int
_wrap_gtk_tree_view_column_new(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    PyObject *py_cell = NULL, *key, *item;
    GtkTreeViewColumn *tvc;
    gchar *title = NULL;
    GtkCellRenderer *cell = NULL;
    gint i = 0;

    if (!PyArg_ParseTuple(args, "|zO:GtkTreeViewColumn.__init__", &title,
			  &py_cell))
	return -1;
    if (py_cell != NULL) {
	if (pygobject_check(py_cell, &PyGtkCellRenderer_Type))
	    cell = GTK_CELL_RENDERER(pygobject_get(py_cell));
	else if (py_cell != Py_None) {
	    PyErr_SetString(PyExc_TypeError,
			    "cell must be a GtkCellRenderer or None");
	    return -1;
	}
    }
    tvc = gtk_tree_view_column_new();
    if (title)
	gtk_tree_view_column_set_title(tvc, title);
    if (cell)
	gtk_tree_view_column_pack_start(tvc, cell, TRUE);
    if (kwargs) {
	while (PyDict_Next(kwargs, &i, &key, &item)) {
	    gchar *attr = PyString_AsString(key);

	    if (!PyInt_Check(item)) {
		gchar err[128];
		g_snprintf(err, sizeof(err),
			   "%s must be an integer column number", attr);
		PyErr_SetString(PyExc_TypeError, err);
		g_object_unref(G_OBJECT(tvc));
		return -1;
	    }
	    gtk_tree_view_column_add_attribute(tvc, cell, attr,
					       PyInt_AsLong(item));
	}
    }
    self->obj = (GObject *)tvc;
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_tree_view_column_get_cell_renderers noargs
static PyObject *
_wrap_gtk_tree_view_column_get_cell_renderers(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *ret;

    list = gtk_tree_view_column_get_cell_renderers(
			GTK_TREE_VIEW_COLUMN(self->obj));

    ret = PyList_New(0);
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
	GtkWidget *renderer = tmp->data;
	PyObject *item = pygobject_new((GObject *)renderer);

	PyList_Append(ret, item);
	Py_DECREF(item);
    }
    g_list_free(list);
    return ret;
}
%%
override gtk_tree_view_column_set_cell_data_func kwargs
static void
pygtk_cell_data_func_marshal (GtkTreeViewColumn *tree_column,
			      GtkCellRenderer *cell,
			      GtkTreeModel *tree_model,
			      GtkTreeIter *iter, gpointer data)
{
    PyGtkCustomNotify *cunote = data;
    PyObject *retobj;
    PyObject *pytreecolumn, *pycell, *pytreemodel, *pyiter;
    
    g_assert (cunote->func);

    pytreecolumn = pygobject_new((GObject *)tree_column);
    pycell = pygobject_new((GObject *)cell);
    pytreemodel = pygobject_new((GObject *)tree_model);
    pyiter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter,
			   TRUE, TRUE);
    if (cunote->data)
	retobj = PyEval_CallFunction(cunote->func, "(OOOOO)",
				     pytreecolumn, pycell,
				     pytreemodel, pyiter, cunote->data);
    else
	retobj = PyEval_CallFunction(cunote->func, "(OOOO)",
				     pytreecolumn, pycell,
				     pytreemodel, pyiter, cunote->data);

    if (retobj == NULL) {
	PyErr_Print();
	PyErr_Clear();
    } else
	Py_DECREF(retobj);
}

static PyObject *
_wrap_gtk_tree_view_column_set_cell_data_func (PyGObject *self, PyObject *args,
					       PyObject *kwargs)
{
    PyObject *pycell,*pyfunc, *pyarg = NULL;
    GtkCellRenderer *cell;
    PyGtkCustomNotify *cunote;
    
    if (!PyArg_ParseTuple(args, "OO|O:GtkTreeViewColumn.set_cell_data_func",
			  &pycell, &pyfunc, &pyarg))
	return NULL;
    
    if (pygobject_check(pycell, &PyGtkCellRenderer_Type))
	cell = GTK_CELL_RENDERER(pygobject_get(pycell));
    else {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a GtkCellRenderer");
	return NULL;
    }

    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);
    
    gtk_tree_view_column_set_cell_data_func (GTK_TREE_VIEW_COLUMN (self->obj), cell,
					     pygtk_cell_data_func_marshal,
					     cunote,
					     pygtk_custom_destroy_notify);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_view_column_set_attributes kwargs
static PyObject *
_wrap_gtk_tree_view_column_set_attributes(PyGObject *self, PyObject *args,
					  PyObject *kwargs)
{
    PyObject *py_cell, *key, *item;
    GtkCellRenderer *cell;
    gint i = 0;

    if (!PyArg_ParseTuple(args, "O!:GtkTreeViewColumn.set_attributes",
			  &PyGtkCellRenderer_Type, &py_cell))
	return NULL;
    cell = GTK_CELL_RENDERER(pygobject_get(py_cell));
    gtk_tree_view_column_clear_attributes(GTK_TREE_VIEW_COLUMN(self->obj),
					  cell);
    if (kwargs) {
	while (PyDict_Next(kwargs, &i, &key, &item)) {
	    gchar *attr = PyString_AsString(key);

	    if (!PyInt_Check(item)) {
		gchar err[128];
		g_snprintf(err, sizeof(err),
			   "%s must be an integer column number", attr);
		PyErr_SetString(PyExc_TypeError, err);
		return NULL;
	    }
	    gtk_tree_view_column_add_attribute(GTK_TREE_VIEW_COLUMN(self->obj),
					       cell, attr,
					       PyInt_AsLong(item));
	}
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_view_get_path_at_pos kwargs
static PyObject *
_wrap_gtk_tree_view_get_path_at_pos(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    gint x, y;
    GtkTreePath *path;
    GtkTreeViewColumn *column;
    gint cell_x, cell_y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "ii:GtkTreeView.get_path_at_pos",
				     kwlist, &x, &y))
	return NULL;
    if (gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(self->obj), x, y,
				      &path, &column, &cell_x, &cell_y)) {
	PyObject *ret = PyTuple_New(4);

	if (path) {
	    PyTuple_SetItem(ret, 0, pygtk_tree_path_to_pyobject(path));
	    gtk_tree_path_free(path);
	} else {
	    Py_INCREF(Py_None);
	    PyTuple_SetItem(ret, 0, Py_None);
	}
	PyTuple_SetItem(ret, 1, pygobject_new((GObject *)column));
	PyTuple_SetItem(ret, 2, PyInt_FromLong(cell_x));
	PyTuple_SetItem(ret, 3, PyInt_FromLong(cell_y));
	return ret;
    } else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
override gtk_tree_view_insert_column_with_attributes kwargs
static PyObject *
_wrap_gtk_tree_view_insert_column_with_attributes(PyGObject *self, PyObject *args,
						  PyObject *kwargs)
{
    gint position, real_position;
    GtkTreeViewColumn *column;
    GtkCellRenderer *cell;
    PyObject *py_cell, *key, *item;
    const char *title;
    gint i = 0;

    if (!PyArg_ParseTuple(args,
			  "isO!:GtkTreeView.insert_column_with_attributes",
			  &position, &title, &PyGtkCellRenderer_Type, &py_cell))
	return NULL;

    cell = GTK_CELL_RENDERER(pygobject_get(py_cell));

    real_position =
	gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW(self->obj),
						     position, title, cell,
						     NULL);
    column = gtk_tree_view_get_column (GTK_TREE_VIEW(self->obj),
				       real_position);
    if (kwargs) {
	while (PyDict_Next(kwargs, &i, &key, &item)) {
	    gchar *attr = PyString_AsString(key);

	    if (!PyInt_Check(item)) {
		gchar err[128];
		g_snprintf(err, sizeof(err),
			   "%s must be an integer column number", attr);
		PyErr_SetString(PyExc_TypeError, err);
		return NULL;
	    }
	    gtk_tree_view_column_add_attribute(column, cell, attr,
					       PyInt_AsLong(item));
	}
    }
    return pygobject_new ((GObject *) column);
}
%%
override gtk_tree_view_get_visible_rect noargs
static PyObject *
_wrap_gtk_tree_view_get_visible_rect(PyGObject *self)
{
    GdkRectangle visible_rect;

    gtk_tree_view_get_visible_rect(GTK_TREE_VIEW(self->obj), &visible_rect);

    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &visible_rect, TRUE, TRUE);
}
%%
override gtk_tree_view_get_cell_area kwargs
static PyObject *
_wrap_gtk_tree_view_get_cell_area(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "column", NULL };
    PyObject *py_path;
    PyGObject *column;
    GdkRectangle rect;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO!:GtkTreeView.get_cell_area", kwlist, &py_path, &PyGtkTreeViewColumn_Type, &column))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(self->obj), path, GTK_TREE_VIEW_COLUMN(column->obj), &rect);
    if (path)
        gtk_tree_path_free(path);
    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE);
}
%%
override gtk_tree_view_get_background_area kwargs
static PyObject *
_wrap_gtk_tree_view_get_background_area(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "path", "column", NULL };
    PyObject *py_path;
    PyGObject *column;
    GdkRectangle rect;
    GtkTreePath *path;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO!:GtkTreeView.get_background_area", kwlist, &py_path, &PyGtkTreeViewColumn_Type, &column))
        return NULL;
    path = pygtk_tree_path_from_pyobject(py_path);
    if (!path) {
        PyErr_SetString(PyExc_TypeError, "could not convert path to a GtkTreePath");
        return NULL;
    }
    gtk_tree_view_get_background_area(GTK_TREE_VIEW(self->obj), path, GTK_TREE_VIEW_COLUMN(column->obj), &rect);
    if (path)
        gtk_tree_path_free(path);
    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE);
}
%%
override gtk_tree_selection_get_selected noargs
static PyObject *
_wrap_gtk_tree_selection_get_selected(PyGObject *self)
{
    GtkTreeModel *model;
    GtkTreeIter iter;

    if (gtk_tree_selection_get_selected(GTK_TREE_SELECTION(self->obj),
					&model, &iter))
	return Py_BuildValue("(NN)", pygobject_new((GObject *)model),
			     pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter,
					   TRUE, TRUE));
    else
	return Py_BuildValue ("(NN)", pygobject_new((GObject *)model), Py_None);
}
%%
override gtk_tree_selection_selected_foreach
static void
pygtk_tree_selection_foreach_marshal(GtkTreeModel *model,
				     GtkTreePath *path,
				     GtkTreeIter *iter,
				     gpointer data)
{
    PyGtkCustomNotify *cunote = data;
    PyObject *py_model, *py_path, *py_iter, *retobj;

    g_assert(cunote->func);
    
    py_model = pygobject_new((GObject *)model);
    py_path = pygtk_tree_path_to_pyobject(path);
    py_iter = pyg_boxed_new(GTK_TYPE_TREE_ITER, iter, TRUE, TRUE);
    if (cunote->data)
	retobj = PyEval_CallFunction(cunote->func, "(NNNO)",
				     py_model, py_path, py_iter,
				     cunote->data);
    else
	retobj = PyEval_CallFunction(cunote->func, "(NNN)",
				     py_model, py_path, py_iter);

    if (retobj == NULL) {
	PyErr_Print();
	PyErr_Clear();
    }
    
    Py_XDECREF(retobj);
}
static PyObject *
_wrap_gtk_tree_selection_selected_foreach(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify cunote;
    
    if(!PyArg_ParseTuple(args, "O|O:GtkTreeSelection.selected_foreach",
			 &pyfunc, &pyarg))
	return NULL;
    
    cunote.func = pyfunc;
    cunote.data = pyarg;
    gtk_tree_selection_selected_foreach(GTK_TREE_SELECTION(self->obj),
					pygtk_tree_selection_foreach_marshal,
					&cunote);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_selection_set_select_function

static gboolean
pygtk_tree_selection_marshal(GtkTreeSelection *selection,
			     GtkTreeModel *model,
			     GtkTreePath *path,
			     gboolean path_currently_selected,
			     gpointer data)
{
    gboolean retval = FALSE;
    PyGtkCustomNotify *cunote = data;
    PyObject *pypath, *retobj;
    
    pyg_block_threads();

    g_assert(cunote->func);
    
    pypath = pygtk_tree_path_to_pyobject(path);
    if (cunote->data)
	retobj = PyEval_CallFunction(cunote->func, "(OO)", pypath,
				     cunote->data);
    else
	retobj = PyEval_CallFunction(cunote->func, "(O)", pypath);

    if (retobj == NULL) {
	PyErr_Print();
	PyErr_Clear();
    }
    
    Py_DECREF(pypath);
    if (retobj) {
	if(retobj == Py_None);
	else if(PyInt_Check(retobj))
	    retval = PyInt_AsLong(retobj) && TRUE;
	else if(PyLong_Check(retobj))
	    retval = PyLong_AsLongLong(retobj) && TRUE;
	else if(PyString_Check(retobj))
	    retval = PyString_GET_SIZE(retobj) && TRUE;
	
	Py_DECREF(retobj);
    }
    
    pyg_unblock_threads();
    
    return retval;
}
static PyObject *
_wrap_gtk_tree_selection_set_select_function(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
    
    if(!PyArg_ParseTuple(args, "O|O:GtkTreeSelection.set_select_function",
			 &pyfunc, &pyarg))
	return NULL;
    
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);
    gtk_tree_selection_set_select_function(GTK_TREE_SELECTION(self->obj),
					   pygtk_tree_selection_marshal,
					   cunote,
					   pygtk_custom_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_binding_entry_add_signal

static PyObject *
_wrap_gtk_binding_entry_add_signal(PyGObject *self, PyObject *args)
{
    PyObject *first;
    gint len, i;
    PyObject *class;
    guint keyval, modifiers;
    gchar *signal_name;
    GType class_type;
    GtkBindingSet *bset = NULL;
    GSList *slist = NULL;
    gchar *errmsg;

    len = PyTuple_Size(args);
    if (len < 4) {
	PyErr_SetString(PyExc_TypeError, "binding_entry_add_signal requires at"
			" least 4 arguments");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 4);
    if (!PyArg_ParseTuple(first, "Oiis:binding_entry_add_signal", &class,
			  &keyval, &modifiers, &signal_name)) {
	Py_DECREF(first);
	return NULL;
    }
    Py_DECREF(first);

    class_type = pyg_type_from_object(class);
    if (class_type == 0)
	return NULL;

    bset = gtk_binding_set_by_class(gtk_type_class(class_type));

    /* extra args */
    if ((len-4)%2) {
	PyErr_SetString(PyExc_ValueError,
			"GtkBindingSet.add_signal requires an even number"
			" of parameter pairs following the first four args");
	return NULL;
    }
    for (i=4; i < len; i+=2) {
	PyObject *item;
	GType arg_type;
	GtkBindingArg *arg = NULL;

	item = PyTuple_GET_ITEM(args, i);
	arg_type = pyg_type_from_object(item);
	if (!arg_type) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "GtkBindingSet.add_signal parameter types"
			    " must be int");
	    goto arg_error;
	}
	arg = g_new0 (GtkBindingArg, 1);
	slist = g_slist_prepend(slist, arg);
    
	arg->arg_type = arg_type;
	switch (GTK_FUNDAMENTAL_TYPE(arg->arg_type)) {
	case GTK_TYPE_CHAR:
	case GTK_TYPE_UCHAR:
	case GTK_TYPE_INT:
	case GTK_TYPE_UINT:
	case GTK_TYPE_BOOL:
	case GTK_TYPE_ENUM:
	case GTK_TYPE_FLAGS:
	case GTK_TYPE_LONG:
	case GTK_TYPE_ULONG:
	    arg->arg_type = GTK_TYPE_LONG;
	    item = PyTuple_GET_ITEM(args, i+1);
	    if (!PyInt_Check(item)) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal "
					 "arg[%u] must be int", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    arg->d.long_data = (glong)PyInt_AsLong(item);
	    break;
	case GTK_TYPE_FLOAT:
	case GTK_TYPE_DOUBLE:
	    arg->arg_type = GTK_TYPE_DOUBLE;
	    item = PyTuple_GET_ITEM(args, i+1);
	    if (!PyFloat_Check(item)) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal "
					 "arg[%u] must be float", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    arg->d.long_data = (gdouble)PyFloat_AsDouble(item);
	    break;
	case GTK_TYPE_STRING:
	    arg->arg_type = GTK_TYPE_STRING;
	    if (arg->arg_type != GTK_TYPE_IDENTIFIER)
		arg->arg_type = GTK_TYPE_STRING;
	    item = PyTuple_GET_ITEM(args, i+1);
	    if (!PyString_Check(item)) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
					 "must be non-empty string", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    arg->d.string_data = (gchar*)PyString_AsString(item);
	    if (!arg->d.string_data) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
					 "must be non-empty string", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    break;
	default:
	    errmsg = g_strdup_printf("GtkBindingSet.add_signal unsupported "
				     "type %10s for arg[%u]",
				     gtk_type_name(arg->arg_type), i+1);
	    PyErr_SetString(PyExc_TypeError, errmsg);
	    g_free(errmsg);
	    goto arg_error;
	} /* switch */
    }

    slist = g_slist_reverse (slist);
    gtk_binding_entry_add_signall (bset, keyval,modifiers, signal_name, slist);

    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);

    Py_INCREF(Py_None);
    return Py_None;

arg_error:
    if (slist) {
	g_slist_foreach(slist, (GFunc)g_free, NULL);
	g_slist_free(slist);
    }
    return NULL;
}

/* -------------- haven't updated stuff below this line -------------- */
%%
ignore-glob
  _*
  *_get_type
  gtk_accelerator_*
  gtk_arg_*
  gtk_args_*
  gtk_draw_*
  gtk_gc_*
  gtk_idle_add*
  gtk_idle_remove
  gtk_init_add_*
  gtk_input_add*
  gtk_input_remove
  gtk_marshal_*
  gtk_pattern_*
  gtk_quit_add_*
  gtk_signal_*
  gtk_signal_add_emission_hook*
  gtk_signal_connect*
  gtk_signal_new*
  gtk_target_list_*
  gtk_timeout_add*
  gtk_timeout_remove
  gtk_tree_path_*
%%
ignore
  gtk_binding_set_new
  gtk_binding_set_by_class
  gtk_binding_set_find
  gtk_binding_set_clear
  gtk_init
  gtk_init_check
  gtk_init_abi_check
  gtk_init_check_abi_check
  gtk_exit
  gtk_set_locale
  gtk_accel_group_ref
  gtk_accel_group_unref
  gtk_accel_groups_activate
  gtk_accel_group_activate
  gtk_accel_group_get_entry
  gtk_accel_group_lock_entry
  gtk_accel_group_unlock_entry
  gtk_accel_group_add
  gtk_accel_group_remove
  gtk_accel_group_handle_add
  gtk_accel_group_handle_remove
  gtk_accel_group_create_add
  gtk_accel_group_create_remove
  gtk_accel_groups_from_object
  gtk_accel_group_entries_from_object
  gtk_signal_set_funcs
  gtk_signal_lookup
  gtk_signal_disconnect_by_func
  gtk_signal_disconnect_by_data
  gtk_signal_handler_block_by_func
  gtk_signal_handler_block_by_data
  gtk_signal_handler_unblock_by_func
  gtk_signal_handler_unblock_by_data
  gtk_signal_handler_pending_by_func
  gtk_signal_n_emissions
  gtk_signal_n_emissions_by_name
  gtk_signal_name
  gtk_signal_remove_emission_hook
  gtk_signal_query
  gtk_signal_emit
  gtk_signal_emit_by_name
  gtk_signal_emitv
  gtk_signal_emitv_by_name
  gtk_quit_remove_by_data
  gtk_idle_remove_by_data
  gtk_object_ref
  gtk_object_unref
  gtk_object_sink
  gtk_object_weakref
  gtk_object_weakunref
  gtk_object_get
  gtk_object_getv
  gtk_object_set
  gtk_object_setv
  gtk_object_set_data
  gtk_object_set_data_full
  gtk_object_get_data
  gtk_object_set_user_data
  gtk_object_get_user_data
  gtk_object_set_data_by_id
  gtk_object_set_data_by_id_full
  gtk_object_get_data_by_id
  gtk_object_remove_data_by_id
  gtk_object_remove_no_notify_by_id
  gtk_object_arg_set
  gtk_object_arg_get
  gtk_trace_referencing
  gtk_widget_ref
  gtk_widget_unref
  gtk_widget_get
  gtk_widget_getv
  gtk_widget_set
  gtk_widget_setv
  gtk_widget_style_get_valist
  gtk_widget_destroyed
  gtk_container_get_toplevels
  gtk_container_add_child_arg_type
  gtk_container_query_child_args
  gtk_container_child_args_collect
  gtk_container_child_arg_get_info
  gtk_container_foreach_full
  gtk_container_forall
  gtk_container_add_with_args
  gtk_container_addv
  gtk_container_child_set_valist
  gtk_container_child_get_valist
  gtk_clist_set_row_data_full
  gtk_window_add_embedded_xid
  gtk_window_remove_embedded_xid
  gtk_range_trough_click
  gtk_range_default_htrough_click
  gtk_range_default_vtrough_click
  gtk_tooltips_data_get
  gtk_type_check_object_cast
  gtk_type_check_class_cast
  gtk_type_register_enum
  gtk_type_register_flags
  gtk_preview_uninit
  gtk_item_factory_create_item
  gtk_item_factory_delete_entry
  gtk_item_factory_delete_entries
  gtk_item_factory_popup_with_data
  gtk_item_factory_popup_data
  gtk_item_factory_set_translate_func
  gtk_item_factory_create_items_ac
  gtk_item_factory_create_menu_entries
  gtk_menu_bar_append
  gtk_menu_bar_insert
  gtk_menu_bar_prepend
  gtk_menu_append
  gtk_menu_insert
  gtk_menu_prepend
  gtk_radio_menu_item_group
  gtk_radio_menu_item_set_group
  gtk_radio_button_group
  gtk_radio_button_set_group
  gtk_entry_new
  gtk_entry_select_region
%%
ignore gtk_object_new gtk_object_newv gtk_object_query_args
  gtk_object_add_arg_type gtk_object_args_collect gtk_object_arg_get_info
  gtk_widget_new gtk_widget_newv
%%
ignore gtk_true gtk_false gtk_key_snooper_install gtk_key_snooper_remove
  gtk_get_current_event gtk_get_event_widget gtk_propagate_event
%%
override gtk_main noargs
static PyObject *
_wrap_gtk_main(PyObject *self)
{
    pyg_unblock_threads();
    gtk_main();
    pyg_block_threads();
    if (PyErr_Occurred())
	return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_main_iteration kwargs
static PyObject *
_wrap_gtk_main_iteration(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"block", NULL};
    int block = 1, ret;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:main_iteration", kwlist,
				    &block)) 
        return NULL;
    pyg_unblock_threads();
    ret = gtk_main_iteration_do(block);
    pyg_block_threads();
    return PyInt_FromLong(ret);
}
%%
override gtk_quit_add
static gboolean
quit_handler_marshal(gpointer user_data)
{
    PyObject *tuple, *ret;
    gboolean res;

    g_return_val_if_fail(user_data != NULL, FALSE);

    pyg_block_threads();

    tuple = (PyObject *)user_data;
    ret = PyObject_CallObject(PyTuple_GetItem(tuple, 0),
			      PyTuple_GetItem(tuple, 1));
    if (!ret) {
	PyErr_Print();
	res = FALSE;
    } else {
	res = PyObject_IsTrue(ret);
	Py_DECREF(ret);
    }
    pyg_unblock_threads();

    return res;
}

static PyObject *
_wrap_gtk_quit_add(PyObject *self, PyObject *args)
{
    gint main_level;
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 2) {
	PyErr_SetString(PyExc_TypeError,
			"quit_add requires at least 2 args");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "iO:quit_add", &main_level, &callback)) {
	Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "second argument not callable");
        return NULL;
    }

    cbargs = PySequence_GetSlice(args, 2, len);
    if (cbargs == NULL)
      return NULL;

    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_quit_add_full(main_level, quit_handler_marshal,
					    NULL, data, pyg_destroy_notify));
}
%%
override gtk_editable_insert_text kwargs
static PyObject *
_wrap_gtk_editable_insert_text(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "text", "position", NULL };
    char *text;
    int len, position=0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s#|i:GtkEditable.insert_text",
				     kwlist, &text, &len, &position))
        return NULL;
    gtk_editable_insert_text(GTK_EDITABLE(self->obj), text, len, &position);
    return PyInt_FromLong(position);
}
%%
override gtk_editable_get_selection_bounds noargs
static PyObject *
_wrap_gtk_editable_get_selection_bounds(PyGObject *self, PyObject *args)
{
    int start, end;

    if (!gtk_editable_get_selection_bounds(GTK_EDITABLE(self->obj), &start, &end)) {
	    return Py_BuildValue ("()");
    }
    
    return Py_BuildValue ("(ii)", start, end);
}
%%
override gtk_entry_get_layout_offsets noargs
static PyObject *
_wrap_gtk_entry_get_layout_offsets(PyGObject *self, PyObject *args)
{
    int x, y;

    gtk_entry_get_layout_offsets(GTK_ENTRY(self->obj), &x, &y);
    
    return Py_BuildValue ("(ii)", x, y);
}
%%
override gtk_item_factory_create_items kwargs
static void
pygtk_item_factory_cb(PyGtkCustomNotify *cunote,
		      guint action, GtkWidget *widget)
{
    PyObject *ret;

    pyg_block_threads();
    if (cunote->data)
	ret = PyObject_CallFunction(cunote->func, "OiO", cunote->data, action,
				    pygobject_new((GObject *)widget));
    else
	ret = PyObject_CallFunction(cunote->func, "iO", action,
				    pygobject_new((GObject *)widget));
    if (ret == NULL) {
	PyErr_Print();
	PyErr_Clear();
    } else
	Py_DECREF(ret);
    pyg_unblock_threads();
}
static PyObject *
_wrap_gtk_item_factory_create_items(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "callback_data", NULL };
    PyObject *list, *cb, *cbdata = NULL;
    GtkItemFactoryEntry ent;
    PyObject *extra_data = NULL;
    GtkItemFactory *ifact;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O|O:GtkItemFactory.create_items", kwlist,
				     &list, &cbdata))
	return NULL;

    if (!PySequence_Check(list)) {
	PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
	return NULL;
    }

    ifact = GTK_ITEM_FACTORY(self->obj);
    len = PySequence_Size(list);
    for (i = 0; i < len; i++) {
	PyGtkCustomNotify *cunote = NULL;
	PyObject *item = PySequence_GetItem(list, i);
	Py_DECREF(item);

	memset(&ent, 0, sizeof(ent));
	cb = Py_None;
	
	if (!PyArg_ParseTuple(item, "s|zOizO", &(ent.path), &(ent.accelerator),
			      &cb, &(ent.callback_action), &(ent.item_type),
			      &extra_data)) {
	    return NULL;
	}
	
	if (cb == Py_None) {
	    ent.callback = NULL;
	} else {
	    ent.callback = (GtkItemFactoryCallback)pygtk_item_factory_cb;
	    cunote = g_new0(PyGtkCustomNotify, 1);
	    cunote->func = cb;
	    cunote->data = cbdata;
	    Py_XINCREF(cunote->func);
	    Py_XINCREF(cunote->data);
	}
	
	if (extra_data != NULL) {
	    if (PyString_Check(extra_data)) {
		ent.extra_data = PyString_AsString(extra_data);
	    } else if (pygobject_check(extra_data, &PyGdkPixbuf_Type)) {
		ent.extra_data = GDK_PIXBUF(pygobject_get(extra_data));
	    } else {
		PyErr_SetString(PyExc_TypeError, 
				"last argument must be a GdkPixBuf or a string");
		return NULL;
	    }
	}
	if (cunote != NULL)
	    g_object_weak_ref(G_OBJECT(ifact),
			      (GWeakNotify) pygtk_custom_destroy_notify,
			      cunote);
			     
	gtk_item_factory_create_item(ifact, &ent, cunote, 1);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_menu_popup kwargs
static void
pygtk_menu_position(GtkMenu *menu, int *x, int *y, gboolean *push_in,
		    PyObject *func)
{
    PyObject *ret;

    pyg_block_threads();
    ret = PyObject_CallFunction(func, "O", pygobject_new((GObject *)menu));
    if (ret == NULL || !PyArg_ParseTuple(ret, "iii", x, y, push_in)) {
	PyErr_Print();
	PyErr_Clear();
	Py_XDECREF(ret);
    } else {
        Py_DECREF(ret);
    }
    pyg_unblock_threads();
}
static PyObject *
_wrap_gtk_menu_popup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent_menu_shell", "parent_menu_item", "func",
		       "button", "activate_time", NULL };
    PyGObject *py_pms, *py_pmi;
    GtkWidget *pms = NULL, *pmi = NULL;
    PyObject *func;
    int button, time;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,  "OOOii:GtkMenu.popup",
				     kwlist, &py_pms, &py_pmi, &func,
				     &button, &time))
        return NULL;
    if (pygobject_check(py_pms, &PyGtkWidget_Type))
        pms = GTK_WIDGET(py_pms->obj);
    else if ((PyObject *)py_pms != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_pmi, &PyGtkWidget_Type))
        pmi = GTK_WIDGET(py_pmi->obj);
    else if ((PyObject *)py_pmi != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (!PyCallable_Check(func) && func != Py_None) {
        PyErr_SetString(PyExc_TypeError, "third argument not callable");
        return NULL;
    }
    if (func != Py_None) {
	Py_INCREF(func);
	gtk_menu_popup(GTK_MENU(self->obj), pms, pmi,
		       (GtkMenuPositionFunc)pygtk_menu_position,
		       func, button, time);
    } else
	gtk_menu_popup(GTK_MENU(self->obj), pms, pmi, NULL,NULL, button,time);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_pixmap_get noargs
static PyObject *
_wrap_gtk_pixmap_get(PyGObject *self)
{
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    gtk_pixmap_get(GTK_PIXMAP(self->obj), &pixmap, &mask);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}

%%
ignore gtk_button_new_with_label gtk_button_new_from_stock gtk_button_new_with_mnemonic
%%
override gtk_button_new kwargs
static int
_wrap_gtk_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", "stock", NULL };
    gchar *text = NULL, *stock = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|zz:GtkButton.__init__",
				     kwlist, &text, &stock))
	return -1;
    if (stock)
	self->obj = (GObject *)gtk_button_new_from_stock(stock);
    else if (text)
	self->obj = (GObject *)gtk_button_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkButton object");
	return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_button_box_get_child_size noargs
static PyObject *
_wrap_gtk_button_box_get_child_size(PyGObject *self)
{
    gint min_width;
    gint min_height;

    gtk_button_box_get_child_size(GTK_BUTTON_BOX(self->obj), &min_width, &min_height);
    return Py_BuildValue("(ii)", min_width, min_height);
}
%%
override gtk_button_box_get_child_ipadding noargs
static PyObject *
_wrap_gtk_button_box_get_child_ipadding(PyGObject *self)
{
    gint ipad_x;
    gint ipad_y;

    gtk_button_box_get_child_ipadding(GTK_BUTTON_BOX(self->obj), &ipad_x, &ipad_y);
    return Py_BuildValue("(ii)", ipad_x, ipad_y);
}
%%
ignore gtk_toggle_button_new_with_label gtk_toggle_button_new_with_mnemonic
%%
override gtk_toggle_button_new kwargs
static int
_wrap_gtk_toggle_button_new(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|z:GtkToggleButton.__init__", kwlist,
				     &text))
	return -1;
    if (text)
	self->obj = (GObject *)gtk_toggle_button_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_toggle_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkToggleButton object");
	return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
ignore gtk_check_button_new_with_label gtk_check_button_new_with_mnemonic
%%
override gtk_check_button_new kwargs
static int
_wrap_gtk_check_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|z:GtkCheckButton.__init__",
				     kwlist, &text))
	return -1;
    if (text)
	self->obj = (GObject *)gtk_check_button_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_check_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkCheckButton object");
	return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
ignore-glob gtk_radio_button_new_*
%%
override gtk_radio_button_new kwargs
static int
_wrap_gtk_radio_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "group", "label", NULL };
    PyObject *py_group = Py_None;
    gchar *label = NULL;
    GtkRadioButton *group;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,"|Oz:GtkRadioButton.__init__",
				     kwlist, &py_group, &label))
	return -1;
    if (py_group == Py_None)
	group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioButton_Type))
	group = GTK_RADIO_BUTTON(pygobject_get(py_group));
    else {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a GtkRadioButton or None");
	return -1;
    }
    /* various configs for create radio buttons ... */
    if (label == NULL) {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_button_new(NULL);
	else
	    self->obj = (GObject *)gtk_radio_button_new_from_widget(group);
    } else {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_button_new_with_mnemonic(NULL,label);
	else
	    self->obj = (GObject *)gtk_radio_button_new_with_mnemonic_from_widget
		(group, label);
    }
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioButton object");
	return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_radio_button_get_group noargs
static PyObject *
_wrap_gtk_radio_button_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;
    
    list = gtk_radio_button_get_group(GTK_RADIO_BUTTON(self->obj));
    
    if ((py_list = PyList_New(0)) == NULL) {
	return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
	gtk_obj = pygobject_new(G_OBJECT(tmp->data));
	if (gtk_obj == NULL) {
	    Py_DECREF(py_list);
	    return NULL;
	}
	PyList_Append(py_list, gtk_obj);
	Py_DECREF(gtk_obj);
    }
    return py_list;
}
%%
ignore gtk_list_item_new_with_label
%%
override gtk_list_item_new kwargs
static int
_wrap_gtk_list_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkListItem.__init__",
				     kwlist, &text))
	return -1;
    if (text)
	self->obj = (GObject *)gtk_list_item_new_with_label(text);
    else
	self->obj = (GObject *)gtk_list_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkListItem object");
	return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
ignore gtk_menu_item_new_with_label gtk_menu_item_new_with_mnemonic
%%
override gtk_menu_item_new kwargs
static int
_wrap_gtk_menu_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkMenuItem.__init__",
				     kwlist, &text))
	return -1;
    if (text)
	self->obj = (GObject *)gtk_menu_item_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_menu_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkMenuItem object");
	return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_menu_attach_to_widget kwargs
static void
pygtk_menu_detach (GtkWidget *attach_widget, GtkMenu *menu)
{
    PyObject *func;
    PyObject *ret;

    func = g_object_get_data (G_OBJECT (menu), "pygtk_menu_detach_func");

    if (!func)
	return;

    pyg_block_threads ();
    ret = PyObject_CallFunction (func, "OO",
				 pygobject_new ((GObject *) menu),
				 pygobject_new ((GObject *) attach_widget));
    pyg_unblock_threads ();

    if (ret == NULL) {
	PyErr_Print ();
	PyErr_Clear ();
	Py_XDECREF (ret);
    }
    else
	Py_DECREF (ret);
}
static PyObject *
_wrap_gtk_menu_attach_to_widget (PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "attach_widget", "detach_func", NULL };
    PyGObject *py_attach_widget;
    PyObject *detach_func;
    GtkWidget *attach_widget;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
				      "O!O:GtkMenu.attach_to_widget",
				      kwlist, &PyGtkWidget_Type,
				      &py_attach_widget, &detach_func))
	return NULL;

    attach_widget = GTK_WIDGET (py_attach_widget->obj);

    if (!PyCallable_Check (detach_func) && detach_func != Py_None) {
	PyErr_SetString (PyExc_TypeError, "second argument not callable");
	return NULL;
    }

    if (detach_func != Py_None) {
	Py_INCREF (detach_func);
	g_object_set_data_full (self->obj,
				"pygtk_menu_detach_func",
				detach_func,
				pyg_destroy_notify);
    }
    else
	g_object_set_data (self->obj, "pygtk_menu_detach_func", NULL);

    gtk_menu_attach_to_widget (GTK_MENU (self->obj), attach_widget,
			       (GtkMenuDetachFunc) pygtk_menu_detach);

    Py_INCREF (Py_None);
    return Py_None;
}
%%
ignore gtk_check_menu_item_new_with_label gtk_check_menu_item_new_with_mnemonic
%%
override gtk_check_menu_item_new kwargs
static int
_wrap_gtk_check_menu_item_new(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|z:GtkCheckMenuItem.__init__", kwlist,
				     &text))
	return -1;
    if (text)
	self->obj = (GObject *)gtk_check_menu_item_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_check_menu_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkCheckMenuItem object");
	return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
ignore gtk_radio_menu_item_new_with_label gtk_radio_menu_item_new_with_mnemonic
%%
override gtk_radio_menu_item_new kwargs
static int
_wrap_gtk_radio_menu_item_new(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "group", "label", NULL };
    gchar *text = NULL;
    PyObject *py_group = Py_None;
    GtkRadioMenuItem *group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|Oz:GtkRadioMenuItem.__init__", kwlist,
				     &py_group, &text))
	return -1;
    if (py_group == Py_None)
	group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioMenuItem_Type))
	group = GTK_RADIO_MENU_ITEM(pygobject_get(py_group));
    else {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a GtkRadioMenuItem or None");
	return -1;
    }
    /* various configs for create radio buttons ... */
    if (text == NULL) {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_menu_item_new(NULL);
	else
	    self->obj = (GObject *)gtk_radio_menu_item_new(group->group);
    } else {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_menu_item_new_with_mnemonic(NULL,
									 text);
	else
	    self->obj = (GObject *)gtk_radio_menu_item_new_with_mnemonic
		(group->group, text);
    }
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioMenuItem object");
	return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
ignore
  gtk_image_item_menu_new_with_label
  gtk_image_menu_item_new_from_stock
  gtk_image_menu_item_new_with_mnemonic
%%
override gtk_image_menu_item_new kwargs
static int
_wrap_gtk_image_menu_item_new(PyGObject *self, PyObject *args,PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "accel_group", NULL };
    gchar *stock_id = NULL;
    PyObject *py_accel_group = Py_None;
    GtkAccelGroup *accel_group= NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|zO:GtkImageMenuItem.__init__",kwlist,
				     &stock_id, &py_accel_group))
	return -1;
    if (pygobject_check(py_accel_group, &PyGtkAccelGroup_Type))
	accel_group = GTK_ACCEL_GROUP(pygobject_get(py_accel_group));

    if (stock_id)
	self->obj = (GObject *)gtk_image_menu_item_new_from_stock(stock_id,
								  accel_group);
    else
	self->obj = (GObject *)gtk_image_menu_item_new();

    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkImageMenuItem object");
	return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
ignore gtk_ctree_construct
  gtk_ctree_insert_gnode
  gtk_ctree_export_to_gnode
  gtk_ctree_post_recursive
  gtk_ctree_post_recursive_to_depth
  gtk_ctree_pre_recursive
  gtk_ctree_pre_recursive_to_depth
  gtk_ctree_find_node_ptr
%%
ignore gtk_ctree_new
%%
override-attr GtkCTree.selection
static PyObject *
_wrap_gtk_ctree__get_selection(PyGObject *self, void *closure)
{
    GList *selection;
    GtkCTreeNode *node;
    PyObject *ret, *py_node;
    if ((ret = PyList_New(0)) == NULL)
	return NULL;

    for (selection = GTK_CLIST(self->obj)->selection; selection != NULL;
	 selection = selection->next) {
	node = selection->data;
	if ((py_node = pyg_pointer_new(GTK_TYPE_CTREE_NODE, node)) == NULL) {
	    Py_DECREF(ret);
	    return NULL;
	}
	PyList_Append(ret, py_node);
	Py_DECREF(py_node);
    }
    return ret;
}
%%
override gtk_ctree_new_with_titles kwargs
static int
_wrap_gtk_ctree_new_with_titles(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "columns", "tree_column", "titles", NULL };
    int columns = 1, tree_column = 0;
    PyObject *py_titles = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iiO:GtkCTree.__init__",
				     kwlist, &columns, &tree_column,
				     &py_titles))
	return -1;
    if (py_titles) {
	gchar **titles;
	gint i;

	if (!PySequence_Check(py_titles)) {
	    PyErr_SetString(PyExc_TypeError, "titles must be a sequence");
	    return -1;
	}
	if (PySequence_Length(py_titles) < columns) {
	    PyErr_SetString(PyExc_TypeError, "titles too short");
	    return -1;
	}
	titles = g_new(gchar *, columns);
	for (i = 0; i < columns; i++) {
	    PyObject *item = PySequence_GetItem(py_titles, i);

	    Py_DECREF(item);
	    if (!PyString_Check(item) && !PyUnicode_Check(item)) {
		PyErr_SetString(PyExc_TypeError,
				"sequence item not a string or unicode object");
		g_free(titles);
		return -1;
	    }
	    titles[i] = PyString_AsString(item);
	}
	self->obj = (GObject *)gtk_ctree_new_with_titles(columns,
						tree_column, titles);
	g_free(titles);
    } else
	self->obj = (GObject *)gtk_ctree_new(columns, tree_column);
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError,"could not create GtkCTree object");
	return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_ctree_base_nodes
static PyObject*
_wrap_gtk_ctree_base_nodes(PyGObject *self, PyObject *args)
{
    PyObject *ret;
    GtkCTreeNode *node;
    
    /* the first row is always a base node */
    node = GTK_CTREE_NODE(GTK_CLIST(self->obj)->row_list);
    if ((ret = PyList_New(0)) == NULL)
	return NULL;
    while (node) {
	PyObject *obj = pyg_pointer_new(GTK_TYPE_CTREE_NODE, node);
	if (obj == NULL) {
	    Py_DECREF(ret);
	    return NULL;
	}
	PyList_Append(ret, obj);
	Py_DECREF(obj);
	node = GTK_CTREE_ROW(node)->sibling;
    }
    return ret;
}
%%
override gtk_ctree_insert_node kwargs
static PyObject *
_wrap_gtk_ctree_insert_node(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", "text", "spacing",
			      "pixmap_closed", "mask_closed", "pixmap_opened",
			      "mask_opened", "is_leaf", "expanded", NULL };
    PyObject *py_text;
    PyGPointer *py_parent, *py_sibling;
    PyGObject *py_pixmap_closed = (PyGObject *) Py_None;
    PyGObject *py_mask_closed = (PyGObject *) Py_None;
    PyGObject *py_pixmap_opened = (PyGObject *) Py_None;
    PyGObject *py_mask_opened = (PyGObject *) Py_None;
    GtkCTreeNode *parent = NULL, *sibling = NULL, *ret;
    gchar **text = NULL;
    GdkPixmap *pixmap_closed = NULL, *pixmap_opened = NULL;
    GdkBitmap *mask_closed = NULL, *mask_opened = NULL;
    gint spacing = 5, is_leaf = 1, expanded = 0, columns, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOO|iOOOOii:GtkCTree.insert_node",
				     kwlist,
				     &py_parent, &py_sibling, &py_text,
				     &spacing, &py_pixmap_closed,
				     &py_mask_closed, &py_pixmap_opened,
				     &py_mask_opened, &is_leaf, &expanded))
	return NULL;
    if (pyg_pointer_check(py_parent, GTK_TYPE_CTREE_NODE))
	parent = pyg_pointer_get(py_parent, GtkCTreeNode);
    else if ((PyObject *)py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError, "parent must be a CTreeNode or None");
	return NULL;
    }
    if (pyg_pointer_check(py_sibling, GTK_TYPE_CTREE_NODE))
	sibling = pyg_pointer_get(py_sibling, GtkCTreeNode);
    else if ((PyObject *)py_sibling != Py_None) {
	PyErr_SetString(PyExc_TypeError,"sibling must be a CTreeNode or None");
	return NULL;
    }
    if (pygobject_check(py_pixmap_closed, &PyGdkPixmap_Type))
	pixmap_closed = GDK_PIXMAP(py_pixmap_closed->obj);
    else if ((PyObject *)py_pixmap_closed != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"pixmap_closed must be a GdkPixmap or None");
	return NULL;
    }
    if (pygobject_check(py_mask_closed, &PyGdkPixmap_Type))
	mask_closed = GDK_PIXMAP(py_mask_closed->obj);
    else if ((PyObject *)py_mask_closed != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"mask_closed must be a GdkBitmap or None");
	return NULL;
    }
    if (pygobject_check(py_pixmap_opened, &PyGdkPixmap_Type))
	pixmap_opened = GDK_PIXMAP(py_pixmap_opened->obj);
    else if ((PyObject *)py_pixmap_opened != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"pixmap_opened must be a GdkPixmap or None");
	return NULL;
    }
    if (pygobject_check(py_mask_opened, &PyGdkPixmap_Type))
	mask_opened = GDK_PIXMAP(py_mask_opened->obj);
    else if ((PyObject *)py_mask_opened != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"mask_opened must be a GdkBitmap or None");
	return NULL;
    }
    if (!PySequence_Check(py_text)) {
	PyErr_SetString(PyExc_TypeError, "text must be a sequence");
	return NULL;
    }
    columns = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_text) < columns) {
	PyErr_SetString(PyExc_TypeError, "text is too short");
	return NULL;
    }
    text = g_new(gchar *, columns);
    for (i = 0; i < columns; i++) {
	PyObject *item = PySequence_GetItem(py_text, i);

	Py_DECREF(item);
	if (!PyString_Check(item) && !PyUnicode_Check(item)) {
	    PyErr_SetString(PyExc_TypeError,
			    "sequence item not a string or unicode object");
	    g_free(text);
	    return NULL;
	}
	text[i] = PyString_AsString(item);
    }
    ret = gtk_ctree_insert_node(GTK_CTREE(self->obj), parent, sibling, text,
				spacing, pixmap_closed, mask_closed,
				pixmap_opened, mask_opened, is_leaf, expanded);
    g_free(text);
    return pyg_pointer_new(GTK_TYPE_CTREE_NODE, ret);
}
%%
ignore gtk_ctree_find_by_row_data_custom gtk_ctree_find_all_by_row_data_custom
%%
override gtk_ctree_find_by_row_data kwargs
static PyObject *
_wrap_gtk_ctree_find_by_row_data(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyObject *data;
    PyGPointer *py_node;
    GtkCTreeNode *node = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "OO:GtkCTree.find_by_row_data", kwlist,
                                    &py_node, &data))
       return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
	node = pyg_pointer_get(py_node, GtkCTreeNode);
    else if ((PyObject *)py_node != Py_None) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode or None");
	return NULL;
    }
    ret = gtk_ctree_find_by_row_data(GTK_CTREE(self->obj), node, data);
    if (ret)
	return pyg_pointer_new(GTK_TYPE_CTREE_NODE, ret);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_ctree_find_all_by_row_data kwargs
static PyObject *
_wrap_gtk_ctree_find_all_by_row_data(PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyGPointer *py_node;
    PyObject *data, *list;
    GtkCTreeNode *node = NULL;
    GList *ret, *tmp;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkCTree.find_all_by_row_data",kwlist,
				     &py_node, &data))
	return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
	node = pyg_pointer_get(py_node, GtkCTreeNode);
    else if ((PyObject *)py_node != Py_None) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode or None");
	return NULL;
    }
    ret = gtk_ctree_find_all_by_row_data(GTK_CTREE(self->obj), node, data);
    if ((list = PyList_New(0)) == NULL)
	return NULL;
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *item = pyg_pointer_new(GTK_TYPE_CTREE_NODE,
					 (GtkCTreeNode *) tmp->data);
	if (item == NULL) {
	    Py_DECREF(list);
	    return NULL;
	}
	PyList_Append(list, item);
	Py_DECREF(item);
    }
    g_list_free(ret);
    return list;
}
%%
override gtk_ctree_node_get_text kwargs
static PyObject *
_wrap_gtk_ctree_node_get_text(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyGPointer *node;
    int column;
    char *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oi:GtkCTree.node_get_text", kwlist,
				     &node, &column))
	return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
	return NULL;
    }
    
    if (!gtk_ctree_node_get_text(GTK_CTREE(self->obj),
				 pyg_pointer_get(node, GtkCTreeNode), column,
				 &text)) {
	PyErr_SetString(PyExc_ValueError, "can't get text value");
	return NULL;
    }
    return PyString_FromString(text);
}
%%
override gtk_ctree_node_get_pixmap kwargs
static PyObject *
_wrap_gtk_ctree_node_get_pixmap(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyObject *node;
    int column;
    GdkPixmap *pixmap = NULL;
    GdkBitmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oi:GtkCTree.node_get_pixmap", kwlist,
				     &node, &column))
	return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
	return NULL;
    }
    
    if (!gtk_ctree_node_get_pixmap(GTK_CTREE(self->obj),
				   pyg_pointer_get(node, GtkCTreeNode), column,
				   &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixmap value");
	return NULL;
    }
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_ctree_node_get_pixtext kwargs
static PyObject *
_wrap_gtk_ctree_node_get_pixtext(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyObject *node;
    int column;
    gchar *text = NULL;
    guint8 spacing;
    GdkPixmap *pixmap = NULL;
    GdkBitmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oi:GtkCTree.node_get_pixtext", kwlist,
				     &node, &column))
	return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
	return NULL;
    }
    
    if (!gtk_ctree_node_get_pixtext(GTK_CTREE(self->obj),
				    pyg_pointer_get(node, GtkCTreeNode), column,
				    &text, &spacing, &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixtext value");
	return NULL;
    }
    return Py_BuildValue("(siNN)", text, (int)spacing,
			 pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_ctree_get_node_info kwargs
static PyObject *
_wrap_gtk_ctree_get_node_info(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *node;
    gchar *text;
    guint8 spacing;
    GdkPixmap *pixmap_closed, *pixmap_opened;
    GdkBitmap *mask_closed, *mask_opened;
    gboolean is_leaf, expanded;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCTree.get_node_info",
				     kwlist, &node))
	return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
	return NULL;
    }
    
    if (!gtk_ctree_get_node_info(GTK_CTREE(self->obj), pyg_pointer_get(node, GtkCTreeNode),
				 &text, &spacing, &pixmap_closed, &mask_closed,
				 &pixmap_opened, &mask_opened,
				 &is_leaf, &expanded)) {
	PyErr_SetString(PyExc_ValueError, "can't get node info");
	return NULL;
    }
    return Py_BuildValue("(siNNNNii)", text, (int)spacing,
			 pygobject_new((GObject *)pixmap_opened),
			 pygobject_new((GObject *)mask_closed),
			 pygobject_new((GObject *)pixmap_opened),
			 pygobject_new((GObject *)mask_opened),
			 (int)is_leaf, (int)expanded);
}
%%
ignore gtk_ctree_node_set_row_data_full
%%
override gtk_ctree_node_set_row_data kwargs
static PyObject *
_wrap_gtk_ctree_node_set_row_data(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyObject *node, *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkCTree.node_set_row_data", kwlist,
				     &node, &data))
	return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
	return NULL;
    }
    
    Py_INCREF(data);
    gtk_ctree_node_set_row_data_full(GTK_CTREE(self->obj),
				     pyg_pointer_get(node, GtkCTreeNode), data,
				     (GDestroyNotify)pyg_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_ctree_node_get_row_data kwargs
static PyObject *
_wrap_gtk_ctree_node_get_row_data(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *node, *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkCTree.node_get_row_data", kwlist,
				     &node))
	return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
	return NULL;
    }
    
    data = gtk_ctree_node_get_row_data(GTK_CTREE(self->obj),
				       pyg_pointer_get(node, GtkCTreeNode));
    if (!data) data = Py_None;
    Py_INCREF(data);
    return data;
}
%%
override-slot GtkCTreeNode.tp_getattr
static PyObject *
_wrap_gtk_ctree_node_tp_getattr(PyGPointer *self, char *attr)
{
    if (!strcmp(attr, "__members__"))
	return Py_BuildValue("[ssssss]", "children", "expanded", "is_leaf",
			     "level", "parent", "sibling");
    if (!strcmp(attr, "parent")) {
	GtkCTreeNode *node = GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->parent;
	if (node)
	    return pyg_pointer_new(GTK_TYPE_CTREE_NODE, node);
	Py_INCREF(Py_None);
	return Py_None;
    } else if (!strcmp(attr, "sibling")) {
	GtkCTreeNode *node = GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->sibling;
	if (node)
	    return pyg_pointer_new(GTK_TYPE_CTREE_NODE, node);
	Py_INCREF(Py_None);
	return Py_None;
    } else if (!strcmp(attr, "children")) {
	GtkCTreeNode *node = GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->children;
	PyObject *ret = PyList_New(0);
	if (ret == NULL)
	    return NULL;
	while (node) {
	    PyObject *py_node = pyg_pointer_new(GTK_TYPE_CTREE_NODE, node);
	    if (py_node == NULL) {
		Py_DECREF(ret);
		return NULL;
	    }
	    PyList_Append(ret, py_node);
	    Py_DECREF(py_node);
	    node = GTK_CTREE_ROW(node)->sibling;
	}
	return ret;
    } else if (!strcmp(attr, "level"))
	return PyInt_FromLong(GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->level);
    else if (!strcmp(attr, "is_leaf"))
	return PyInt_FromLong(GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->is_leaf);
    else if (!strcmp(attr, "expanded"))
	return PyInt_FromLong(GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->expanded);
    PyErr_SetString(PyExc_AttributeError, attr);
    return NULL;
}
%%
override-slot GtkRequisition.tp_as_sequence
static int
_wrap_gtk_requisition_length(PyGBoxed *self)
{
    return 2;
}
static PyObject *
_wrap_gtk_requisition_getitem(PyGBoxed *self, int pos)
{
    GtkRequisition *requisition;

    if (pos < 0) pos += 2;
    if (pos < 0 || pos >= 2) {
	PyErr_SetString(PyExc_IndexError, "index out of range");
	return NULL;
    }
    requisition = pyg_boxed_get(self, GtkRequisition);
    switch (pos) {
    case 0: return PyInt_FromLong(requisition->width);
    case 1: return PyInt_FromLong(requisition->height);
    default:
	g_assert_not_reached();
	return NULL;
    }
}
static int
_wrap_gtk_requisition_setitem(PyGBoxed *self, int pos, PyObject *value)
{
    GtkRequisition *requisition;
    gint val;

    if (pos < 0) pos += 2;
    if (pos < 0 || pos >= 2) {
	PyErr_SetString(PyExc_IndexError, "index out of range");
	return -1;
    }
    requisition = pyg_boxed_get(self, GtkRequisition);
    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
	return -1;
    switch(pos) {
    case 0: requisition->width      = val; break;
    case 1: requisition->height     = val; break;
    default:
	g_assert_not_reached();
	return -1;
    }
    return 0;
}
static PySequenceMethods _wrap_gtk_requisition_tp_as_sequence = {
    (inquiry)_wrap_gtk_requisition_length,
    (binaryfunc)0,
    (intargfunc)0,
    (intargfunc)_wrap_gtk_requisition_getitem,
    (intintargfunc)0,
    (intobjargproc)_wrap_gtk_requisition_setitem,
    (intintobjargproc)0
};
%%
override-attr GtkRequisition.width
static int
_wrap_gtk_requisition__set_width(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
	return -1;
    pyg_boxed_get(self, GtkRequisition)->width = val;
    return 0;
}
%%
override-attr GtkRequisition.height
static int
_wrap_gtk_requisition__set_height(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
	return -1;
    pyg_boxed_get(self, GtkRequisition)->height = val;
    return 0;
}
%%
ignore gtk_tree_remove_items
%%
override gtk_toolbar_append_item kwargs
static PyObject *
_wrap_gtk_toolbar_append_item(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
			      "icon", "callback", "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param = NULL, *py_ret;
    GtkWidget *icon = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "zzzOO|O:GtkToolbar.append_item", kwlist,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"forth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_append_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
				  tooltip_private_text, icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
	GClosure *closure;

	closure = pyg_closure_new(callback, param, NULL);
	g_signal_connect_closure(ret, "clicked", closure, FALSE);
	pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_prepend_item kwargs
static PyObject *
_wrap_gtk_toolbar_prepend_item(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
			      "icon", "callback", "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param, *py_ret;
    GtkWidget *icon = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "zzzOOO:GtkToolbar.prepend_item", kwlist,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"forth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_prepend_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
				  tooltip_private_text, icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
	GClosure *closure;

	closure = pyg_closure_new(callback, param, NULL);
	g_signal_connect_closure(ret, "clicked", closure, FALSE);
	pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_insert_item kwargs
static PyObject *
_wrap_gtk_toolbar_insert_item(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
			      "icon", "callback", "user_data", "position",
			      NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param, *py_ret;
    GtkWidget *icon = NULL, *ret;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "zzzOOOi:GtkToolbar.insert_item", kwlist,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param, &position))
	return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"forth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_insert_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
				  tooltip_private_text, icon, NULL, NULL,
				  position);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
	GClosure *closure;

	closure = pyg_closure_new(callback, param, NULL);
	g_signal_connect_closure(ret, "clicked", closure, FALSE);
	pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_insert_stock kwargs
static PyObject *
_wrap_gtk_toolbar_insert_stock(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "tooltip_text", "tooltip_private_text",
			      "callback", "user_data", "position",
			      NULL };
    char *stock_id, *tooltip_text, *tooltip_private_text;
    PyObject *callback, *param, *py_ret;
    GtkWidget *ret;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "zzzOOi:GtkToolbar.insert_stock", kwlist,
				     &stock_id, &tooltip_text,
				     &tooltip_private_text,
				     &callback, &param, &position))
	return NULL;

    ret = gtk_toolbar_insert_stock(GTK_TOOLBAR(self->obj), stock_id, tooltip_text,
				  tooltip_private_text, NULL, NULL,
				  position);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
	GClosure *closure;

	closure = pyg_closure_new(callback, param, NULL);
	g_signal_connect_closure(ret, "clicked", closure, FALSE);
	pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_append_element kwargs
static PyObject *
_wrap_gtk_toolbar_append_element(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
			      "tooltip_private_text", "icon", "callback",
			      "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param, *py_ret;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOzzzOOO:GtkToolbar.append_element",
				     kwlist,
				     &py_type, &py_widget,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
			   py_type, (gint *)&type))
	return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
	widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"second argument must be a GtkWidget or None");
	return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sixth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_append_element(GTK_TOOLBAR(self->obj), type, widget,
				     text, tooltip_text, tooltip_private_text,
				     icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback) &&
	(type == GTK_TOOLBAR_CHILD_BUTTON ||
	 type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	 type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
	GClosure *closure;

	closure = pyg_closure_new(callback, param, NULL);
	g_signal_connect_closure(ret, "clicked", closure, FALSE);
	pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_prepend_element kwargs
static PyObject *
_wrap_gtk_toolbar_prepend_element(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
			      "tooltip_private_text", "icon", "callback",
			      "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param, *py_ret;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOzzzOOO:GtkToolbar.prepend_element",
				     kwlist,
				     &py_type, &py_widget,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
			   py_type, (gint *)&type))
	return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
	widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"second argument must be a GtkWidget or None");
	return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sixth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_prepend_element(GTK_TOOLBAR(self->obj), type, widget,
				      text, tooltip_text, tooltip_private_text,
				      icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback) &&
	(type == GTK_TOOLBAR_CHILD_BUTTON ||
	 type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	 type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
	GClosure *closure;

	closure = pyg_closure_new(callback, param, NULL);
	g_signal_connect_closure(ret, "clicked", closure, FALSE);
	pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_insert_element kwargs
static PyObject *
_wrap_gtk_toolbar_insert_element(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
			      "tooltip_private_text", "icon", "callback",
			      "user_data", "position", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param, *py_ret;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOzzzOOOi:GtkToolbar.insert_element",
				     kwlist,
				     &py_type, &py_widget,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param, &position))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
			   py_type, (gint *)&type))
	return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
	widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"second argument must be a GtkWidget or None");
	return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sixth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_insert_element(GTK_TOOLBAR(self->obj), type, widget,
				     text, tooltip_text, tooltip_private_text,
				     icon, NULL, NULL, position);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback) &&
	(type == GTK_TOOLBAR_CHILD_BUTTON ||
	 type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	 type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
	GClosure *closure;

	closure = pyg_closure_new(callback, param, NULL);
	g_signal_connect_closure(ret, "clicked", closure, FALSE);
	pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_notebook_query_tab_label_packing kwargs
static PyObject *
_wrap_gtk_notebook_query_tab_label_packing(PyGObject *self, PyObject *args,
					   PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    gboolean expand, fill;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkNotebook.query_tab_label_packing",
				     kwlist, &child))
	return NULL;
    if (!pygobject_check(child, &PyGtkWidget_Type)) {
	PyErr_SetString(PyExc_TypeError, "child must be a GtkWidget");
	return NULL;
    }
    gtk_notebook_query_tab_label_packing(GTK_NOTEBOOK(self->obj),
					 GTK_WIDGET(child->obj),
					 &expand, &fill, &pack_type);
    return Py_BuildValue("(iii)", expand, fill, pack_type);
}
%%
override gtk_list_insert_items kwargs
static PyObject *
_wrap_gtk_list_insert_items(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "items", "position", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int position, len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!i:GtkList.insert_items",
				     kwlist, &PyList_Type, &py_items,
				     &position))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_insert_items(GTK_LIST(self->obj), items, position);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_append_items kwargs
static PyObject *
_wrap_gtk_list_append_items(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.append_items",
				     kwlist, &PyList_Type, &py_items))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_append_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_prepend_items kwargs
static PyObject *
_wrap_gtk_list_prepend_items(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.preppend_items",
				     kwlist, &PyList_Type, &py_items))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_prepend_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_remove_items kwargs
static PyObject *
_wrap_gtk_list_remove_items(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.remove_items",
				     kwlist, &PyList_Type, &py_items))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_remove_items(GTK_LIST(self->obj), items);
    g_list_free(items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_list_remove_items_no_unref
%%
override-attr GtkList.selection
static PyObject *
_wrap_gtk_list__get_selection(PyGObject *self, void *closure)
{
    GList *selection;
    PyObject *item, *ret = PyList_New(0);

    if (ret == NULL)
	return NULL;

    for (selection = GTK_LIST(self->obj)->selection; selection != NULL;
	 selection = selection->next) {
	item = pygobject_new((GObject *) GTK_LIST_ITEM(selection->data));

	if (!item) {
	    Py_DECREF(ret);
	    return NULL;
	}

	PyList_Append(ret, item);
	Py_DECREF(item);
    }
    return ret;
}
%%
override gtk_list_get_selection noargs
static PyObject *
_wrap_gtk_list__get_selection(PyGObject *self, void *closure);
static PyObject *
_wrap_gtk_list_get_selection(PyGObject *self)
{
    return _wrap_gtk_list__get_selection(self, NULL);
}
%%
override gtk_color_selection_get_current_color noargs
static PyObject *
_wrap_gtk_color_selection_get_current_color(PyGObject *self)
{
    GdkColor colour = { 0, };

    gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(self->obj),
					  &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gtk_color_selection_get_previous_color noargs
static PyObject *
_wrap_gtk_color_selection_get_previous_color(PyGObject *self)
{
    GdkColor colour = { 0, };

    gtk_color_selection_get_previous_color(GTK_COLOR_SELECTION(self->obj),
					   &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gtk_calendar_get_date noargs
static PyObject *
_wrap_gtk_calendar_get_date(PyGObject *self)
{
    guint year, month, day;

    gtk_calendar_get_date(GTK_CALENDAR(self->obj), &year, &month, &day);
    return Py_BuildValue("(iii)", year, month, day);
}
%%
override gtk_drag_dest_set kwargs
static PyObject *
_wrap_gtk_drag_dest_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "flags", "targets", "actions", NULL };
    PyObject *py_flags, *py_targets, *py_actions;
    GtkDestDefaults flags;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOO:GtkWidget.drag_dest_set", kwlist,
				     &py_flags, &py_targets, &py_actions))
	return NULL;
    if (pyg_flags_get_value(GTK_TYPE_DEST_DEFAULTS, py_flags, (gint *)&flags))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
			     py_actions, (gint *)&actions))
	return NULL;
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
			      &targets[i].flags, &targets[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(targets);
	    return NULL;
	}
    }
    gtk_drag_dest_set(GTK_WIDGET(self->obj), flags, targets, n_targets,
		      actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_dest_find_target kwargs
static PyObject *
_wrap_gtk_drag_dest_find_target(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "context", "target_list", NULL };
    PyObject *context, *py_target_list;
    gint i, n_targets;
    GtkTargetEntry *targets;
    GtkTargetList *target_list;
    GdkAtom atom;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!O:GtkWidget.drag_dest_find_target",
				     kwlist, &PyGdkDragContext_Type, &context,
				     &py_target_list))
	return NULL;
    if (!PySequence_Check(py_target_list)) {
	PyErr_SetString(PyExc_TypeError, "target_list must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_target_list);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_target_list, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
			      &targets[i].flags, &targets[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(targets);
	    return NULL;
	}
    }
    target_list = gtk_target_list_new(targets, n_targets);
    g_free(targets);

    atom = gtk_drag_dest_find_target(GTK_WIDGET(self->obj),
				     GDK_DRAG_CONTEXT(pygobject_get(context)),
				     target_list);
    gtk_target_list_unref(target_list);

    return PyGdkAtom_New(atom);
}
%%
override gtk_drag_dest_get_target_list noargs
static PyObject *
_wrap_gtk_drag_dest_get_target_list(PyGObject *self)
{
    GtkTargetList *target_list;
    PyObject *ret;
    GList *tmp;

    target_list = gtk_drag_dest_get_target_list(GTK_WIDGET(self->obj));

    if (!target_list) {
	Py_INCREF(Py_None);
	return Py_None;
    }

    ret = PyList_New(0);
    for (tmp = target_list->list; tmp != NULL; tmp = tmp->next) {
	GtkTargetPair *pair = tmp->data;
	PyObject *item;

	item = Py_BuildValue("(Nii)", PyGdkAtom_New(pair->target),
			     pair->flags, pair->info);
	PyList_Append(ret, item);
	Py_DECREF(item);
    }
    gtk_target_list_unref(target_list);
    return ret;
}
%%
override gtk_drag_dest_set_target_list kwargs
static PyObject *
_wrap_gtk_drag_dest_set_target_list(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "target_list", NULL };
    PyObject *py_target_list;
    gint i, n_targets;
    GtkTargetEntry *targets;
    GtkTargetList *target_list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkWidget.drag_dest_set_target_list",
				     kwlist, &py_target_list))
	return NULL;
    if (!PySequence_Check(py_target_list)) {
	PyErr_SetString(PyExc_TypeError, "target_list must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_target_list);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_target_list, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
			      &targets[i].flags, &targets[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(targets);
	    return NULL;
	}
    }
    target_list = gtk_target_list_new(targets, n_targets);
    g_free(targets);

    gtk_drag_dest_set_target_list(GTK_WIDGET(self->obj), target_list);
    gtk_target_list_unref(target_list);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_source_set kwargs
static PyObject *
_wrap_gtk_drag_source_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start_button_mask", "targets", "actions", NULL };
    PyObject *py_sbmask, *py_targets, *py_actions;
    GdkModifierType sbmask;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOO:GtkWidget.drag_source_set", kwlist,
				     &py_sbmask, &py_targets, &py_actions))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,
			     py_sbmask, (gint *)&sbmask))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
			     py_actions, (gint *)&actions))
	return NULL;
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
			      &targets[i].flags, &targets[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(targets);
	    return NULL;
	}
    }
    gtk_drag_source_set(GTK_WIDGET(self->obj), sbmask, targets, n_targets,
			actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_begin kwargs
static PyObject *
_wrap_gtk_drag_begin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "actions", "button", "event", NULL };
    PyObject *py_targets, *py_actions, *event;
    GtkTargetEntry *tents;
    GtkTargetList *targets;
    GdkDragAction actions;
    gint button, n_targets, i;
    GdkDragContext *context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOiO:GtkWidget.drag_begin", kwlist,
				     &py_targets, &py_actions, &button,
				     &event))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
			     py_actions, (gint *)&actions))
	return NULL;
    if (!pyg_boxed_check(event, GDK_TYPE_EVENT)) {
	PyErr_SetString(PyExc_TypeError, "event must be a GdkEvent");
	return NULL;
    }
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    tents = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &tents[i].target,
			      &tents[i].flags, &tents[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(tents);
	    return NULL;
	}
    }
    targets = gtk_target_list_new(tents, n_targets);
    g_free(tents);
    context = gtk_drag_begin(GTK_WIDGET(self->obj), targets, actions, button,
			     pyg_boxed_get(event, GdkEvent));
    gtk_target_list_unref(targets);
    return pygobject_new((GObject *)context);
}
%%
ignore
  gtk_drag_source_handle_event gtk_drag_dest_handle_event
  gtk_selection_clear
  gtk_selection_request gtk_selection_notify gtk_selection_property_notify
  gtk_selection_incr_event
%%
override gtk_selection_add_targets kwargs
static PyObject *
_wrap_gtk_selection_add_targets(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "selection", "targets", NULL };
    PyObject *py_targets, *py_selection;
    GtkTargetEntry *targets;
    GdkAtom selection;
    int n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkWidget.selection_add_targets",
				     kwlist, &py_selection, &py_targets))
	return NULL;
    selection = pygdk_atom_from_pyobject(py_selection);
    if (PyErr_Occurred())
	return NULL;
    
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
			      &targets[i].flags, &targets[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "sequence items should be of form (string,int,int)");
	    g_free(targets);
	    return NULL;
	}
    }
    gtk_selection_add_targets(GTK_WIDGET(self->obj), selection,
			      targets, n_targets);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_text_iter_free
%%
override gtk_text_iter_copy noargs
static PyObject *
_wrap_gtk_text_iter_copy(PyGBoxed *self)
{
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, pyg_boxed_get(self, GtkTextIter),
			 TRUE, TRUE);
}
%%
override gtk_text_iter_get_slice kwargs
static PyObject *
_wrap_gtk_text_iter_get_slice(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextIter.get_slice",
				     kwlist, &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_slice(pyg_boxed_get(self, GtkTextIter),
				   pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_text kwargs
static PyObject *
_wrap_gtk_text_iter_get_text(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextIter.get_text",
				     kwlist, &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_text(pyg_boxed_get(self, GtkTextIter),
				   pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_visible_slice kwargs
static PyObject *
_wrap_gtk_text_iter_get_visible_slice(PyGBoxed *self, PyObject *args,
				      PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkTextIter.get_visible_slice", kwlist,
				     &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_visible_slice(pyg_boxed_get(self, GtkTextIter),
					   pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_visible_text kwargs
static PyObject *
_wrap_gtk_text_iter_get_visible_text(PyGBoxed *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkTextIter.get_visible_text", kwlist,
				     &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_visible_text(pyg_boxed_get(self, GtkTextIter),
					  pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_marks noargs
static PyObject *
_wrap_gtk_text_iter_get_marks(PyGBoxed *self)
{
    GSList *ret, *tmp;
    PyObject *pyret;

    ret = gtk_text_iter_get_marks(pyg_boxed_get(self, GtkTextIter));
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *mark = pygobject_new((GObject *)tmp->data);
	PyList_Append(pyret, mark);
	Py_DECREF(mark);
    }
    g_slist_free(ret);
    return pyret;
}
%%
override gtk_text_iter_get_toggled_tags kwargs
static PyObject *
_wrap_gtk_text_iter_get_toggled_tags(PyGBoxed *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "toggled_on", NULL };
    GSList *ret, *tmp;
    int toggled_on;
    PyObject *pyret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "i:GtkTextIter.get_toggled_tags", kwlist,
				     &toggled_on))
	return NULL;
    ret = gtk_text_iter_get_toggled_tags(pyg_boxed_get(self, GtkTextIter),
					 toggled_on);
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *tag = pygobject_new((GObject *)tmp->data);
	PyList_Append(pyret, tag);
	Py_DECREF(tag);
    }
    g_slist_free(ret);
    return pyret;
}
%%
override gtk_text_iter_get_tags noargs
static PyObject *
_wrap_gtk_text_iter_get_tags(PyGBoxed *self)
{
    GSList *ret, *tmp;
    PyObject *pyret;

    ret = gtk_text_iter_get_tags(pyg_boxed_get(self, GtkTextIter));
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *tag = pygobject_new((GObject *)tmp->data);
	PyList_Append(pyret, tag);
	Py_DECREF(tag);
    }
    g_slist_free(ret);
    return pyret;
}
%%
override gtk_text_iter_forward_search kwargs
static PyObject *
_wrap_gtk_text_iter_forward_search(PyGBoxed *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "str", "flags", "limit", NULL };
    gchar *str;
    PyObject *py_limit = Py_None;
    GtkTextIter match_start, match_end, *limit = NULL;
    GtkTextSearchFlags flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "si|O:GtkTextIter.forward_search",
				     kwlist, &str, &flags, &py_limit))
	return NULL;
    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
	limit = pyg_boxed_get(py_limit, GtkTextIter);
    else if (py_limit != Py_None) {
	PyErr_SetString(PyExc_TypeError,"limit must be a GtkTextIter or None");
	return NULL;
    }
    if (gtk_text_iter_forward_search(pyg_boxed_get(self, GtkTextIter), str,
				     flags, &match_start, &match_end, limit))
	return Py_BuildValue("(NN)",
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_start,
					   TRUE, TRUE),
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_end,
					   TRUE, TRUE));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_text_iter_backward_search kwargs
static PyObject *
_wrap_gtk_text_iter_backward_search(PyGBoxed *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "str", "flags", "limit", NULL };
    gchar *str;
    PyObject *py_limit = Py_None;
    GtkTextIter match_start, match_end, *limit = NULL;
    GtkTextSearchFlags flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "si|O:GtkTextIter.backward_search",
				     kwlist, &str, &flags, &py_limit))
	return NULL;
    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
	limit = pyg_boxed_get(py_limit, GtkTextIter);
    else if (py_limit != Py_None) {
	PyErr_SetString(PyExc_TypeError,"limit must be a GtkTextIter or None");
	return NULL;
    }
    if (gtk_text_iter_backward_search(pyg_boxed_get(self, GtkTextIter), str,
				      flags, &match_start, &match_end, limit))
	return Py_BuildValue("(NN)",
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_start,
					   TRUE, TRUE),
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_end,
					   TRUE, TRUE));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_text_buffer_insert_with_tags
static PyObject *
_wrap_gtk_text_buffer_insert_with_tags(PyGObject *self, PyObject *args)
{
    PyObject *first, *py_iter;
    gint len, i, text_len, start_offset;
    gchar *text;
    GtkTextIter *iter, start;

    len = PyTuple_Size(args);
    if (len < 2) {
	PyErr_SetString(PyExc_TypeError,
	    "GtkTextBuffer.insert_with_tags requires at least 2 arguments");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "Os#:GtkTextBuffer.insert_with_tags",
			  &py_iter, &text, &text_len)) {
	Py_DECREF(first);
	return NULL;
    }
    Py_DECREF(first);
    if (!pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTextIter");
	return NULL;
    }
    iter = pyg_boxed_get(py_iter, GtkTextIter);

    /* check types */
    for (i = 2; i < len; i++) {
	PyObject *item = PyTuple_GetItem(args, i);

	if (!pygobject_check(item, &PyGtkTextTag_Type)) {
	    PyErr_SetString(PyExc_TypeError,
			    "additional argument must be a GtkTextTag");
	    return NULL;
	}
    }

    start_offset = gtk_text_iter_get_offset(iter);
    gtk_text_buffer_insert(GTK_TEXT_BUFFER(self->obj), iter, text, text_len);
    gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj),
				       &start, start_offset);

    for (i = 2; i < len; i++) {
	PyObject *item = PyTuple_GetItem(args, i);
	GtkTextTag *tag = GTK_TEXT_TAG(pygobject_get(item));

	gtk_text_buffer_apply_tag(GTK_TEXT_BUFFER(self->obj), tag,&start,iter);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_text_buffer_insert_with_tags_by_name
static PyObject *
_wrap_gtk_text_buffer_insert_with_tags_by_name(PyGObject *self, PyObject *args)
{
    PyObject *first, *py_iter;
    gint len, i, text_len, start_offset;
    gchar *text;
    GtkTextIter *iter, start;

    len = PyTuple_Size(args);
    if (len < 2) {
	PyErr_SetString(PyExc_TypeError,
			"GtkTextBuffer.insert_with_tags_by_name "
			"requires at least 2 arguments");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "Os#:GtkTextBuffer.insert_with_tags_by_name",
			  &py_iter, &text, &text_len)) {
	Py_DECREF(first);
	return NULL;
    }
    Py_DECREF(first);
    if (!pyg_boxed_check(py_iter, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTextIter");
	return NULL;
    }
    iter = pyg_boxed_get(py_iter, GtkTextIter);

    /* check types */
    for (i = 2; i < len; i++) {
	PyObject *item = PyTuple_GetItem(args, i);

	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError,
			    "additional argument must be a string");
	    return NULL;
	}
    }

    start_offset = gtk_text_iter_get_offset(iter);
    gtk_text_buffer_insert(GTK_TEXT_BUFFER(self->obj), iter, text, text_len);
    gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj),
				       &start, start_offset);

    for (i = 2; i < len; i++) {
	PyObject *item = PyTuple_GetItem(args, i);
	const gchar *tagname = PyString_AsString(item);

	gtk_text_buffer_apply_tag_by_name(GTK_TEXT_BUFFER(self->obj),
					  tagname, &start, iter);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_text_buffer_create_tag kwargs
static PyObject *
_wrap_gtk_text_buffer_create_tag(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tag_name", NULL };
    gchar *tag_name;
    GtkTextTag *tag;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:GtkTextBuffer.create_tag", kwlist,
				     &tag_name))
	return NULL;
    tag = gtk_text_buffer_create_tag(GTK_TEXT_BUFFER(self->obj),
				     tag_name, NULL);
    return pygobject_new((GObject *)tag);
}
%%
override gtk_text_buffer_get_iter_at_line_offset kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line_offset(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "line_number", "char_offset", NULL };
    GtkTextIter iter;
    int line_number, char_offset;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkTextBuffer.get_iter_at_line_offset", kwlist, &line_number, &char_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_line_offset(GTK_TEXT_BUFFER(self->obj), &iter,
					    line_number, char_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_iter_at_line_index kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line_index(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "line_number", "byte_offset", NULL };
    GtkTextIter iter;
    int line_number, byte_offset;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkTextBuffer.get_iter_at_line_index", kwlist, &line_number, &byte_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_line_index(GTK_TEXT_BUFFER(self->obj), &iter,
					   line_number, byte_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_iter_at_offset kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_offset(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    int char_offset;
    static char *kwlist[] = { "char_offset", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkTextBuffer.get_iter_at_offset", kwlist, &char_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj),
				       &iter, char_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_iter_at_line kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    int line_number;
    static char *kwlist[] = { "line_number", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkTextBuffer.get_iter_at_line", kwlist, &line_number))
        return NULL;

    gtk_text_buffer_get_iter_at_line(GTK_TEXT_BUFFER(self->obj),
				     &iter, line_number);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_start_iter noargs
static PyObject *
_wrap_gtk_text_buffer_get_start_iter(PyGObject *self)
{
    GtkTextIter iter;

    gtk_text_buffer_get_start_iter(GTK_TEXT_BUFFER(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_end_iter noargs
static PyObject *
_wrap_gtk_text_buffer_get_end_iter(PyGObject *self)
{
    GtkTextIter iter;

    gtk_text_buffer_get_end_iter(GTK_TEXT_BUFFER(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_bounds noargs
static PyObject *
_wrap_gtk_text_buffer_get_bounds(PyGObject *self)
{
    GtkTextIter start, end;

    gtk_text_buffer_get_bounds(GTK_TEXT_BUFFER(self->obj), &start, &end);
    return Py_BuildValue("(NN)",
			 pyg_boxed_new(GTK_TYPE_TEXT_ITER, &start, TRUE, TRUE),
			 pyg_boxed_new(GTK_TYPE_TEXT_ITER, &end, TRUE, TRUE));
}
%%
override gtk_text_buffer_get_iter_at_mark kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_mark(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyGObject *mark;
    static char *kwlist[] = { "mark", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextBuffer.get_iter_at_mark", kwlist, &mark))
        return NULL;
    if (!pygobject_check(mark, &PyGtkTextMark_Type)) {
        PyErr_SetString(PyExc_TypeError, "mark should be a GtkTextMark");
        return NULL;
    }

    gtk_text_buffer_get_iter_at_mark(GTK_TEXT_BUFFER(self->obj), &iter,
				     GTK_TEXT_MARK(mark->obj));
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_set_text kwargs
static PyObject *
_wrap_gtk_text_buffer_set_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    char *text;
    static char *kwlist[] = { "text", "len", NULL };
    int len;

    /* tricky, allows user to override calculated text length. */
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s#|i:GtkTextBuffer.set_text", kwlist,
				     &text, &len, &len))
        return NULL;

    gtk_text_buffer_set_text(GTK_TEXT_BUFFER(self->obj), text, len);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_text_child_anchor_get_widgets noargs
static PyObject *
_wrap_gtk_text_child_anchor_get_widgets(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *ret;

    list = gtk_text_child_anchor_get_widgets(GTK_TEXT_CHILD_ANCHOR(self->obj));

    ret = PyList_New(0);
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
	GtkWidget *widget = tmp->data;
	PyObject *item = pygobject_new((GObject *)widget);

	PyList_Append(ret, item);
	Py_DECREF(item);
    }
    g_list_free(list);
    return ret;
}
%%
override gtk_text_view_buffer_to_window_coords kwargs
static PyObject *
_wrap_gtk_text_view_buffer_to_window_coords(PyGObject *self, PyObject *args,
					    PyObject *kwargs)
{
    static char *kwlist[] = { "win", "buffer_x", "buffer_y", NULL };
    GtkTextWindowType win;
    gint buffer_x, buffer_y, window_x = 0, window_y = 0;
    PyObject *py_win;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oii:GtkTextView.buffer_to_window_coords",
				     kwlist, &py_win, &buffer_x, &buffer_y))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, py_win, (gint *)&win))
	return NULL;
    gtk_text_view_buffer_to_window_coords(GTK_TEXT_VIEW(self->obj), win,
					  buffer_x, buffer_y,
					  &window_x, &window_y);
    return Py_BuildValue("(ii)", window_x, window_y);
}
%%
override gtk_text_view_window_to_buffer_coords kwargs
static PyObject *
_wrap_gtk_text_view_window_to_buffer_coords(PyGObject *self, PyObject *args,
					    PyObject *kwargs)
{
    static char *kwlist[] = { "win", "window_x", "window_y", NULL };
    GtkTextWindowType win;
    gint window_x, window_y, buffer_x = 0, buffer_y = 0;
    PyObject *py_win;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oii:GtkTextView.window_to_buffer_coords",
				     kwlist, &py_win, &window_x, &window_y))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, py_win, (gint *)&win))
	return NULL;
    gtk_text_view_window_to_buffer_coords(GTK_TEXT_VIEW(self->obj), win,
					  window_x, window_y,
					  &buffer_x, &buffer_y);
    return Py_BuildValue("(ii)", buffer_x, buffer_y);
}
%%
ignore gtk_dialog_new
%%
override gtk_dialog_new_with_buttons kwargs
static int
_wrap_gtk_dialog_new_with_buttons(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    gchar *title = NULL;
    PyGObject *py_window = NULL;
    PyObject *py_buttons = Py_None;
    GtkDialogFlags flags = 0;
    int len, i;
    
    static char *kwlist[] = { "title", "parent", "flags", "buttons", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|sOiO!:GtkDialog.__init__", kwlist,
				     &title, &py_window, &flags,
				     &PyTuple_Type, &py_buttons))
        return -1;

    if (py_window != NULL && py_window != (PyGObject *) Py_None
	&& !pygobject_check(py_window, &PyGtkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "window must be a GtkWindow or None");
	return -1;
    }

    if (py_buttons != Py_None)
	len = PyTuple_Size(py_buttons);
    else
	len = 0;
    
    if (len % 2) {
	PyErr_SetString(PyExc_RuntimeError,
			"buttons tuple must contain text/response id pairs");
	return -1;
    }

    self->obj = (GObject *)
	gtk_dialog_new_with_buttons(title,
				    (py_window && py_window != (PyGObject *) Py_None) ? GTK_WINDOW(py_window->obj) : NULL,
				    flags, NULL);
    
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkDialog object");
        return -1;
    }

    for (i = 0; i < len; i += 2) {
	PyObject *text = PyTuple_GetItem(py_buttons, i);
	PyObject *id = PyTuple_GetItem(py_buttons, i + 1);
	if (!PyString_Check(text)) {
	    gtk_object_destroy(GTK_OBJECT(self->obj));
	    self->obj = NULL;
	    PyErr_SetString(PyExc_RuntimeError,
			    "first member of each text/response id pair "
			    "must be a string");
	    return -1;
	}
	if (!PyInt_Check(id)) {
	    gtk_object_destroy(GTK_OBJECT(self->obj));
	    self->obj = NULL;
	    PyErr_SetString(PyExc_RuntimeError,
			    "second member of each text/response id pair "
			    "must be a number");
	    return -1;
	}
	gtk_dialog_add_button(GTK_DIALOG(self->obj), PyString_AsString(text),
			      PyInt_AsLong(id));
    }
    g_object_ref(self->obj); /* we don't own the first reference of windows */
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_dialog_run noargs
static PyObject *
_wrap_gtk_dialog_run(PyGObject *self)
{
    gint retval;

    pyg_unblock_threads();
    retval = gtk_dialog_run(GTK_DIALOG(self->obj));
    pyg_block_threads();

    return PyInt_FromLong(retval);
}
%%
override gtk_message_dialog_new kwargs
static int
_wrap_gtk_message_dialog_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GtkButtonsType buttons = GTK_BUTTONS_NONE;
    static char *kwlist[] = { "parent", "flags", "type", "buttons", "message_format", NULL };
    PyObject *py_flags = NULL, *py_type = NULL, *py_buttons = NULL;
    GtkDialogFlags flags = 0;
    GtkWindow *parent = NULL;
    GtkMessageType type = GTK_MESSAGE_INFO;
    PyGObject *py_parent = NULL;
    char *message_format = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OOOOz:GtkMessageDialog.__init__", kwlist, &py_parent, &py_flags, &py_type, &py_buttons, &message_format))
        return -1;
    if ((PyObject *)py_parent == Py_None)
        parent = NULL;
    else if (py_parent && pygobject_check(py_parent, &PyGtkWindow_Type))
        parent = GTK_WINDOW(py_parent->obj);
    else if (py_parent) {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkWindow or None");
        return -1;
    }
    if (pyg_enum_get_value(GTK_TYPE_DIALOG_FLAGS, py_flags, (gint *)&flags))
        return -1;
    if (pyg_enum_get_value(GTK_TYPE_MESSAGE_TYPE, py_type, (gint *)&type))
        return -1;
    if (pyg_enum_get_value(GTK_TYPE_BUTTONS_TYPE, py_buttons, (gint *)&buttons))
        return -1;

    self->obj = (GObject *)gtk_message_dialog_new(parent, flags, type, buttons, "%s", message_format);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkMessageDialog object");
        return -1;
    }
    g_object_ref(self->obj); /* we don't own the first reference of windows */
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
ignore gtk_progress_bar_new
%%
override gtk_progress_bar_new_with_adjustment kwargs
static PyObject *
_wrap_gtk_progress_bar_new_with_adjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GtkAdjustment *adjustment = NULL;
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *py_adjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkProgressBar.__init__", kwlist, &py_adjustment))
        return NULL;
    if ((PyObject *)py_adjustment == Py_None)
        adjustment = NULL;
    else if (py_adjustment && pygobject_check(py_adjustment, &PyGtkAdjustment_Type))
        adjustment = GTK_ADJUSTMENT(py_adjustment->obj);
    else if (py_adjustment) {
        PyErr_SetString(PyExc_TypeError, "adjustment should be a GtkAdjustment or None");
        return NULL;
    }

    if (adjustment)
	self->obj = (GObject *)gtk_progress_bar_new_with_adjustment(adjustment);
    else
	self->obj = (GObject *)gtk_progress_bar_new();

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkProgressBar object");
        return NULL;
    }
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_rc_set_default_files kwargs
static PyObject *
_wrap_gtk_rc_set_default_files(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    gchar **filenames = NULL;
    static char *kwlist[] = { "filenames", NULL };
    PyObject *py_filenames = NULL;
    int i, n_files;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:rc_set_default_files",
				     kwlist, &py_filenames))
        return NULL;

    if (!PySequence_Check(py_filenames)) {
	PyErr_SetString(PyExc_TypeError, "filenames must be a sequence");
	return NULL;
    }

    n_files = PySequence_Length(py_filenames);
    filenames = g_new(gchar *, n_files + 1);
    for (i = 0; i < n_files; i++) {
	PyObject *item = PySequence_GetItem(py_filenames, i);
	Py_DECREF(item); /* PySequence_GetItem INCREF's */
	filenames[i] = PyString_AsString(item);
    }
    filenames[n_files] = NULL;

    gtk_rc_set_default_files(filenames);

    g_free(filenames);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_rc_get_default_files noargs
static PyObject *
_wrap_gtk_rc_get_default_files(PyGObject *self)
{
    gchar **filenames = NULL, **tmp;
    int i = 0, j;
    PyObject *ret;

    filenames = gtk_rc_get_default_files();

    tmp = filenames;
    while (*tmp)
	tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
	PyTuple_SetItem(ret, j, PyString_FromString(filenames[j]));
    
    return ret;
}
%%
override gtk_icon_set_new_from_pixbuf kwargs
static int
_wrap_gtk_icon_set_new_from_pixbuf(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *pixbuf = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkIconSet.__init__", kwlist, &pixbuf))
        return -1;
    if (pixbuf && !pygobject_check(pixbuf, &PyGdkPixbuf_Type)) {
        PyErr_SetString(PyExc_TypeError, "pixbuf should be a GdkPixbuf");
        return -1;
    }
    self->gtype = GTK_TYPE_ICON_SET;
    self->free_on_dealloc = FALSE;
    if (pixbuf)
	self->boxed = gtk_icon_set_new_from_pixbuf(GDK_PIXBUF(pixbuf->obj));
    else
	self->boxed = gtk_icon_set_new();

    if (!self->boxed) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkIconSet object");
        return -1;
    }
    self->free_on_dealloc = TRUE;
    return 0;
}
%%
override gtk_icon_set_get_sizes noargs
static PyObject *
_wrap_gtk_icon_set_get_sizes(PyGObject *self)
{
    GtkIconSize *sizes;
    int i, n_sizes;
    PyObject *ret;

    gtk_icon_set_get_sizes(pyg_boxed_get(self, GtkIconSet), &sizes, &n_sizes);

    ret = PyTuple_New(n_sizes);
    for (i = 0; i < n_sizes; i++)
	PyTuple_SetItem(ret, i, PyInt_FromLong(sizes[i]));
    g_free(sizes);
    
    return ret;
}
%%
override gtk_cell_renderer_get_size kwargs
static PyObject *
_wrap_gtk_cell_renderer_get_size(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "widget", "cell_area", NULL };
    gint x_offset = 0, y_offset = 0, width = 0, height = 0;
    GdkRectangle cell_area;
    PyObject *py_widget, *py_cell_area = Py_None;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O|O:GtkCellRenderer.get_size", kwlist,
				     &py_widget, &py_cell_area))
        return NULL;

    if (!pygobject_check(py_widget, &PyGtkWidget_Type)) {
	PyErr_SetString(PyExc_TypeError, "widget must be a GtkWidget");
	return NULL;
    }
    if (py_cell_area != Py_None) {
	if (!pygdk_rectangle_from_pyobject(py_cell_area, &cell_area))
	    return NULL;
    }

    gtk_cell_renderer_get_size(GTK_CELL_RENDERER(self->obj),
			       GTK_WIDGET(pygobject_get(py_widget)),
			       (py_cell_area == Py_None) ? NULL : &cell_area,
			       &x_offset, &y_offset, &width, &height);

    return Py_BuildValue("(iiii)", x_offset, y_offset, width, height);
}
%%
override gtk_cell_renderer_get_fixed_size noargs
static PyObject *
_wrap_gtk_cell_renderer_get_fixed_size(PyGObject *self)
{
    gint width, height;

    gtk_cell_renderer_get_fixed_size(GTK_CELL_RENDERER(self->obj),
				     &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
%%
override gtk_stock_add kwargs
static PyObject *
_wrap_gtk_stock_add(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    PyObject *py_item;
    GtkStockItem *items = NULL;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:stock_add", kwlist,
				     &py_items))
        return NULL;

    if (!PySequence_Check(py_items)) {
	PyErr_SetString(PyExc_TypeError,
			"items must be a sequence of five-element tuples");
	return NULL;
    }

    len = PySequence_Length(py_items);
    items = g_new(GtkStockItem, len);
    if (items) {
	for (i = 0; i < len; i++) {
	    py_item = PySequence_GetItem(py_items, i);
	    if (!py_item) goto error;
	    if (!PyArg_ParseTuple(py_item, "zziiz",
				  &items[i].stock_id, &items[i].label,
				  &items[i].modifier, &items[i].keyval,
				  &items[i].translation_domain)) {
		PyErr_Clear();
		PyErr_SetString(PyExc_TypeError, "items sequence members "
				"must be of form (stock_id, label, modifiers, "
				"keyval, domain)");
		goto error;
	    }
	}
	gtk_stock_add(items, PySequence_Length(py_items));
	g_free(items);
	Py_INCREF(Py_None);
	return Py_None;
    }
 error:
    g_free(items);
    return NULL;
}
%%
override gtk_layout_get_size noargs
static PyObject *
_wrap_gtk_layout_get_size(PyGObject *self)
{
    guint width, height;
    gtk_layout_get_size(GTK_LAYOUT(self->obj), &width, &height);
    
    return Py_BuildValue("(ii)", width, height);
}
%%
override gtk_frame_get_label_align noargs
static PyObject *
_wrap_gtk_frame_get_label_align(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_frame_get_label_align(GTK_FRAME(self->obj), &xalign, &yalign);
    return Py_BuildValue("(ff)", xalign, yalign);
}
%%
override gtk_misc_get_alignment noargs
static PyObject *
_wrap_gtk_misc_get_alignment(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_misc_get_alignment(GTK_MISC(self->obj), &xalign, &yalign);
    return 
Py_BuildValue("(ff)", xalign, yalign);
}
%%
override gtk_misc_get_padding noargs
static PyObject *
_wrap_gtk_misc_get_padding(PyGObject *self)
{
    gint xpad, ypad;

    gtk_misc_get_padding(GTK_MISC(self->obj), &xpad, &ypad);
    return 
Py_BuildValue("(dd)", xpad, ypad);
}
%%
override gtk_ruler_get_range noargs
static PyObject *
_wrap_gtk_ruler_get_range(PyGObject *self)
{
    gdouble lower, upper, position, max_size;

    gtk_ruler_get_range(GTK_RULER(self->obj), &lower, &upper, &position,
			&max_size);
    return Py_BuildValue("(dddd)", lower, upper, position, max_size);
}
%%
override gtk_im_context_get_preedit_string noargs
static PyObject *
_wrap_gtk_im_context_get_preedit_string(PyGObject *self)
{
    gchar *str;
    PangoAttrList *attrs;
    gint cursor_pos;
    PyObject *ret;

    gtk_im_context_get_preedit_string(GTK_IM_CONTEXT(self->obj),
				      &str, &attrs, &cursor_pos);

    ret = Py_BuildValue("(sNi)", str,
			pyg_boxed_new(PANGO_TYPE_ATTR_LIST, attrs, FALSE,TRUE),
			cursor_pos);
    g_free(str);

    return ret;
}
%%
override gtk_im_context_filter_keypress kwargs
static PyObject *
_wrap_gtk_im_context_filter_keypress(PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    PyObject *key;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkIMContext.filter_keypress", kwlist,
				     &key))
	return NULL;

    if (!pyg_boxed_check(key, GDK_TYPE_EVENT)) {
	PyErr_SetString(PyExc_TypeError, "key must be a GdkEvent");
	return NULL;
    }

    return PyInt_FromLong(gtk_im_context_filter_keypress
			    (GTK_IM_CONTEXT(self->obj),
			     pyg_boxed_get(key, GdkEventKey)));
}
%%
override gtk_im_context_get_surrounding noargs
static PyObject *
_wrap_gtk_im_context_get_surrounding(PyGObject *self)
{
    gchar *text;
    gint cursor_index;

    if (gtk_im_context_get_surrounding(GTK_IM_CONTEXT(self->obj),
				       &text, &cursor_index)) {
	PyObject *ret = Py_BuildValue("(si)", text, cursor_index);

	g_free(text);
	return ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override-attr GtkTooltips.active_tips_data
static PyObject *
_wrap_gtk_tooltips__get_active_tips_data(PyGObject *self, void *closure)
{
    GtkTooltips *tips = GTK_TOOLTIPS(self->obj);
    GtkTooltipsData *data = tips->active_tips_data;
    
    if (data == NULL) {
	Py_INCREF(Py_None);
	return Py_None;
    }
    
    return Py_BuildValue("OOss",
			 pygobject_new((GObject *)data->tooltips),
			 pygobject_new((GObject *)data->widget),
			 data->tip_text,
			 data->tip_private);
}
%%
override-attr GtkTooltips.tips_data_list
static PyObject *
_wrap_gtk_tooltips__get_tips_data_list(PyGObject *self, void *closure)
{
    GList *list = GTK_TOOLTIPS(self->obj)->tips_data_list;
    gint         i, length;
    PyObject    *pylist;
    GList *iter;
    
    length = g_list_length(list);
    pylist = PyList_New(length);

    i = 0;
    for (iter = list; iter; iter = iter->next) {
	GtkTooltipsData *data = (GtkTooltipsData*)iter->data;
	PyObject *item = Py_BuildValue("OOss",
			       pygobject_new((GObject *)data->tooltips),
			       pygobject_new((GObject *)data->widget),
			       data->tip_text,
			       data->tip_private);
	PyList_SetItem(pylist, i, item);
	Py_INCREF(item);
    }
    return pylist;
}
%%
override-attr GtkAdjustment.value
static int
_wrap_gtk_adjustment__set_value(PyGObject *self, PyObject *value,
				void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
    
    if (!PyFloat_Check(value)) {
	PyErr_SetString(PyExc_TypeError, "value must be a double");
	return -1;
    }
    adjustment->value = PyFloat_AsDouble(value);
    gtk_adjustment_value_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.lower
static int
_wrap_gtk_adjustment__set_lower(PyGObject *self, PyObject *value,
				void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
    
    if (!PyFloat_Check(value)) {
	PyErr_SetString(PyExc_TypeError, "lower must be a double");
	return -1;
    }
    adjustment->lower = PyFloat_AsDouble(value);
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.upper
static int
_wrap_gtk_adjustment__set_upper(PyGObject *self, PyObject *value,
				void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
    
    if (!PyFloat_Check(value)) {
	PyErr_SetString(PyExc_TypeError, "upper must be a double");
	return -1;
    }
    adjustment->upper = PyFloat_AsDouble(value);
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.step_increment
static int
_wrap_gtk_adjustment__set_step_increment(PyGObject *self, PyObject *value,
					 void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
    
    if (!PyFloat_Check(value)) {
	PyErr_SetString(PyExc_TypeError, "step_increment must be a double");
	return -1;
    }
    adjustment->step_increment = PyFloat_AsDouble(value);
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.page_increment
static int
_wrap_gtk_adjustment__set_page_increment(PyGObject *self, PyObject *value,
					 void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
    
    if (!PyFloat_Check(value)) {
	PyErr_SetString(PyExc_TypeError, "page_increment must be a double");
	return -1;
    }
    adjustment->page_increment = PyFloat_AsDouble(value);
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.page_size
static int
_wrap_gtk_adjustment__set_page_size(PyGObject *self, PyObject *value,
					 void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
    
    if (!PyFloat_Check(value)) {
	PyErr_SetString(PyExc_TypeError, "page_increment must be a double");
	return -1;
    }
    adjustment->page_size = PyFloat_AsDouble(value);
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override gtk_adjustment_set_all kwargs
static PyObject *
_wrap_gtk_adjustment_set_all(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    GtkAdjustment *adj = GTK_ADJUSTMENT(self->obj);
    double *value = &adj->value, *lower = &adj->lower, *upper = &adj->upper;
    double *step_increment = &adj->step_increment;
    double *page_increment = &adj->page_increment;
    double *page_size = &adj->page_size;
    double old_value = *value, old_lower = *lower, old_upper = *upper;
    double old_step_increment = *step_increment;
    double old_page_increment = *page_increment;
    double old_page_size = *page_size;
    
    if (PyErr_Warn(PyExc_DeprecationWarning, "use individual setters") < 0)
        return NULL;
    if (!PyArg_ParseTuple(args, "|dddddd:gtk_adjustment_set_all",
                          value, lower, upper, step_increment,
                          page_increment, page_size)) {
	adj->value = old_value;
	adj->lower = old_lower;
	adj->upper = old_upper;
	adj->step_increment = old_step_increment;
	adj->page_increment = old_page_increment;
	adj->page_size = old_page_size;
        return NULL;
    }
    if (PyTuple_Size(args) > 0)
	gtk_adjustment_value_changed(adj);
    if (PyTuple_Size(args) > 1)
	gtk_adjustment_changed(adj);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore-win32 
	GTK_TYPE_PLUG
	GTK_TYPE_SOCKET
	gtk_socket_new
	gtk_socket_steal
	gtk_socket_add_id
	gtk_socket_get_id
	gtk_plug_new
	gtk_plug_construct
	gtk_plug_get_id
%%
