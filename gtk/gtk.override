/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include <gtk/gtk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include "pygtk-private.h"
#include "pygtktreemodel.h"

/* from the gdk portion ... */
extern PyTypeObject PyGdkColormap_Type;
extern PyTypeObject PyGdkGC_Type;
extern PyTypeObject PyGdkWindow_Type;
extern PyTypeObject PyGdkPixmap_Type;
extern PyTypeObject PyGdkImage_Type;
extern PyTypeObject PyGdkPixbuf_Type;
extern PyTypeObject PyGdkPixbufAnimation_Type;
extern PyTypeObject PyGdkDragContext_Type;

%%
import gobject.GObject as PyGObject_Type
import atk.Object as PyAtkObject_Type
import pango.Context as PyPangoContext_Type
import pango.Font as PyPangoFont_Type
import pango.Layout as PyPangoLayout_Type
%%
ignore gtk_selection_data_copy gtk_selection_data_free
%%
override-attr GtkSelectionData.data
static PyObject *
_wrap_gtk_selection_data__get_data(PyGObject *self, void *closure)
{
    if (pyg_boxed_get(self, GtkSelectionData)->length >= 0) {
	return PyString_FromStringAndSize(
			pyg_boxed_get(self, GtkSelectionData)->data,
			pyg_boxed_get(self, GtkSelectionData)->length);
    } else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
override gtk_selection_data_set kwargs
static PyObject *
_wrap_gtk_selection_data_set(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", "format", "data", NULL };
    PyObject *py_type;
    GdkAtom type;
    int format, length;
    guchar *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Ois#:GtkSelectionData.set", kwlist,
				     &py_type, &format, &data, &length))
	return NULL;
    type = pygdk_atom_from_pyobject(py_type);
    if (PyErr_Occurred())
	return NULL;
    
    gtk_selection_data_set(pyg_boxed_get(self, GtkSelectionData),
			   type, format, data, length);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_widget_draw kwargs
static PyObject *
_wrap_gtk_widget_draw(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "rect", NULL };
    GdkRectangle rect;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "(hhhh):GtkWidget.draw",
				     kwlist, &(rect.x), &(rect.y),
				     &(rect.width), &(rect.height)))
        return NULL;
    gtk_widget_draw(GTK_WIDGET(self->obj), &rect);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_widget_translate_coordinates kwargs
static PyObject *
_wrap_gtk_widget_translate_coordinates(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "dest_widget", "src_x", "src_y", NULL };
    PyObject *py_dest_widget;
    int src_x, src_y;
    GtkWidget *dest_widget = NULL;
    int dest_x, dest_y;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oii:GtkWidget.translate_coordinates",
				     kwlist, &py_dest_widget, &src_x, &src_y)) {
        return NULL;
    }
	
    if (pygobject_check(py_dest_widget, &PyGtkWidget_Type)) {
        dest_widget = GTK_WIDGET(pygobject_get(py_dest_widget));
    } else if (py_dest_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"dest_widget must be a GtkWidget or None");
	return NULL;
    }
    
    if (!gtk_widget_translate_coordinates(GTK_WIDGET(self->obj), 
                                          dest_widget,
					  src_x,
					  src_y,
					  &dest_x,
					  &dest_y)) {
       return Py_BuildValue ("()");
   }
   
   return Py_BuildValue ("(ii)", &dest_x, &dest_y);   
}
%%
override gtk_widget_size_request noargs
static PyObject *
_wrap_gtk_widget_size_request(PyGObject *self)
{
    GtkRequisition requisition;

    gtk_widget_size_request(GTK_WIDGET(self->obj), &requisition);
    return Py_BuildValue("(ii)", requisition.width, requisition.height);
}
%%
override gtk_widget_size_allocate kwargs
static PyObject *
_wrap_gtk_widget_size_allocate(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "allocation", NULL };
    GtkAllocation allocation;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs,
				    "(hhhh):GtkWidget.size_allocate", kwlist,
				    &(allocation.x), &(allocation.y),
				    &(allocation.width), &(allocation.height)))
        return NULL;
    gtk_widget_size_allocate(GTK_WIDGET(self->obj), &allocation);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_widget_get_child_requisition noargs
static PyObject *
_wrap_gtk_widget_get_child_requisition(PyGObject *self)
{
    GtkRequisition requisition;

    gtk_widget_get_child_requisition(GTK_WIDGET(self->obj), &requisition);
    return Py_BuildValue("(ii)", requisition.width, requisition.height);
}
%%
override gtk_widget_get_allocation noargs
static PyObject *
_wrap_gtk_widget_get_allocation(PyGObject *self)
{
    GtkAllocation allocation;

    allocation = GTK_WIDGET(self->obj)->allocation;
    return Py_BuildValue("(iiii)", (int)allocation.x, (int)allocation.y,
			 (int)allocation.width, (int)allocation.height);
}
%%
override gtk_widget_intersect kwargs
static PyObject *
_wrap_gtk_widget_intersect(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "area", NULL };
    GdkRectangle area;
    GdkRectangle intersect;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "(hhhh):GtkWidget.intersect",
				    kwlist, &(area.x), &(area.y),
				    &(area.width), &(area.height))) 
        return NULL;
    if (gtk_widget_intersect(GTK_WIDGET(self->obj), &area, &intersect))
        return Py_BuildValue("(iiii)", (int)intersect.x, (int)intersect.y,
                             (int)intersect.width, (int)intersect.height);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gtk_widget_get_pointer noargs
static PyObject *
_wrap_gtk_widget_get_pointer(PyGObject *self)
{
    int x, y;

    gtk_widget_get_pointer(GTK_WIDGET(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gtk_widget_path noargs
static PyObject *
_wrap_gtk_widget_path(PyGObject *self)
{
    guint length;
    gchar *path;
    gchar *path_reversed;
    PyObject *result;

    gtk_widget_path(GTK_WIDGET(self->obj), &length, &path, &path_reversed);
    result = PyString_FromString(path);
    g_free(path);
    g_free(path_reversed);

    return result;
}
%%
override gtk_widget_class_path noargs
static PyObject *
_wrap_gtk_widget_class_path(PyGObject *self)
{
    guint length;
    gchar *path;
    gchar *path_reversed;
    PyObject *result;

    gtk_widget_class_path(GTK_WIDGET(self->obj), &length, &path,
			  &path_reversed);
    result = PyString_FromString(path);
    g_free(path);
    g_free(path_reversed);

    return result;
}
%%
override gtk_container_children noargs
static PyObject *
_wrap_gtk_container_children(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *py_list;
    PyObject *gtk_obj;

    list = gtk_container_children(GTK_CONTAINER(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
	g_list_free(list);
	return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
	gtk_obj = pygobject_new(G_OBJECT(tmp->data));
	if (gtk_obj == NULL) {
	    g_list_free(list);
	    Py_DECREF(py_list);
	    return NULL;
	}
	PyList_Append(py_list, gtk_obj);
	Py_DECREF(gtk_obj);
    }
    g_list_free(list);
    return py_list;
}
%%
override gtk_label_get noargs
static PyObject *
_wrap_gtk_label_get(PyGObject *self)
{
    gchar *text = NULL;

    gtk_label_get(GTK_LABEL(self->obj), &text);
    if (text)
	return PyString_FromString(text);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_label_get_selection_bounds noargs
static PyObject *
_wrap_gtk_label_get_selection_bounds(PyGObject *self)
{
    int start, end;

    if (!gtk_label_get_selection_bounds(GTK_LABEL(self->obj), &start, &end)) {
       return Py_BuildValue ("()");
    }
    
    return Py_BuildValue("(ii)", start, end);
}
%%
override gtk_label_get_layout_offsets noargs
static PyObject *
_wrap_gtk_label_get_layout_offsets(PyGObject *self)
{
    gint x;
    gint y;

    gtk_label_get_layout_offsets(GTK_LABEL(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gtk_spin_button_get_increments noargs
static PyObject *
_wrap_gtk_spin_button_get_increments(PyGObject *self)
{
    gdouble step;
    gdouble page;

    gtk_spin_button_get_increments(GTK_SPIN_BUTTON(self->obj), &step, &page);
    return Py_BuildValue("(dd)", step, page);
}
%%
override gtk_spin_button_get_range noargs
static PyObject *
_wrap_gtk_spin_button_get_range(PyGObject *self)
{
    gdouble min;
    gdouble max;

    gtk_spin_button_get_range(GTK_SPIN_BUTTON(self->obj), &min, &max);
    return Py_BuildValue("(dd)", min, max);
}
%%
override gtk_window_list_toplevels noargs
static PyObject *
_wrap_gtk_window_list_toplevels(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *py_list;
    PyObject *gtk_obj;

    list = gtk_window_list_toplevels();

    if ((py_list = PyList_New(0)) == NULL) {
	g_list_free(list);
	return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
	gtk_obj = pygobject_new(G_OBJECT(tmp->data));
	if (gtk_obj == NULL) {
	    g_list_free(list);
	    Py_DECREF(py_list);
	    return NULL;
	}
	PyList_Append(py_list, gtk_obj);
	Py_DECREF(gtk_obj);
    }
    g_list_free(list);
    return py_list;
}
%%
override gtk_window_set_geometry_hints kwargs
static PyObject *
_wrap_gtk_window_set_geometry_hints(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "geometry_widget", "min_width", "min_height",
			      "max_width", "max_height", "base_width",
			      "base_height", "width_inc", "height_inc",
			      "min_aspect", "max_aspect", NULL };
    PyObject *py_geometry_widget = Py_None;
    GtkWidget *geometry_widget = NULL;
    gint min_width = -1, min_height = -1, max_width = -1, max_height = -1;
    gint base_width = -1, base_height = -1, width_inc = -1, height_inc = -1;
    gdouble min_aspect = -1.0, max_aspect = -1.0;
    GdkGeometry geometry = { 0 };
    GdkWindowHints geom_mask = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
			"|Oiiiiiiiidd:GtkWindow.set_geometry_hints", kwlist,
				     &py_geometry_widget, &min_width,
				     &min_height, &max_width, &max_height,
				     &base_width, &base_height, &width_inc,
				     &height_inc, &min_aspect, &max_aspect))
	return NULL;
    if (pygobject_check(py_geometry_widget, &PyGtkWidget_Type))
	geometry_widget = GTK_WIDGET(pygobject_get(py_geometry_widget));
    else if (py_geometry_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"geometry_widget must be a GtkWidget or None");
	return NULL;
    }
    if (min_width >= 0 || min_height >= 0) {
	geometry.min_width = MAX(min_width, 0);
	geometry.min_height = MAX(min_height, 0);
	geom_mask |= GDK_HINT_MIN_SIZE;
    }
    if (max_width >= 0 || max_height >= 0) {
	geometry.max_width = MAX(max_width, 0);
	geometry.max_height = MAX(max_height, 0);
	geom_mask |= GDK_HINT_MAX_SIZE;
    }
    if (base_width >= 0 || base_height >= 0) {
	geometry.base_width = MAX(base_width, 0);
	geometry.base_height = MAX(base_height, 0);
	geom_mask |= GDK_HINT_BASE_SIZE;
    }
    if (width_inc >= 0 || height_inc >= 0) {
	geometry.width_inc = MAX(width_inc, 0);
	geometry.height_inc = MAX(height_inc, 0);
	geom_mask |= GDK_HINT_RESIZE_INC;
    }
    if (min_aspect >= 0.0 || max_aspect >= 0.0) {
	if (min_aspect <= 0.0 || max_aspect <= 0.0) {
	    PyErr_SetString(PyExc_TypeError, "aspect ratios must be positive");
	    return NULL;
	}
	geometry.min_aspect = min_aspect;
	geometry.max_aspect = max_aspect;
	geom_mask |= GDK_HINT_ASPECT;
    }
    gtk_window_set_geometry_hints(GTK_WINDOW(self->obj), geometry_widget,
				  &geometry, geom_mask);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_window_get_position
static PyObject *
_wrap_gtk_window_get_position(PyGObject *self)
{
    gint root_x, root_y;

    gtk_window_get_position(GTK_WINDOW(self->obj), &root_x, &root_y);
    return Py_BuildValue("(ii)", root_x, root_y);
}
%%
override gtk_window_get_size
static PyObject *
_wrap_gtk_window_get_size(PyGObject *self)
{
    gint width, height;

    gtk_window_get_size(GTK_WINDOW(self->obj), &width, &height);
    return Py_BuildValue("(ii)", width, height);
}
%%
override gtk_window_get_default_size
static PyObject *
_wrap_gtk_window_get_default_size(PyGObject *self)
{
    gint width, height;

    gtk_window_get_default_size(GTK_WINDOW(self->obj), &width, &height);
    return Py_BuildValue("(ii)", width, height);
}
%%
override gtk_box_query_child_packing kwargs
static PyObject *
_wrap_gtk_box_query_child_packing(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    gboolean expand, fill;
    guint padding;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkBox.query_child_packing", kwlist,
				     &child))
	return NULL;
    if (!pygobject_check(child, &PyGtkWidget_Type)) {
	PyErr_SetString(PyExc_TypeError, "first arg should be a GtkWidget");
	return NULL;
    }
    gtk_box_query_child_packing(GTK_BOX(self->obj),
				GTK_WIDGET(child->obj), &expand, &fill,
				&padding, &pack_type);
    return Py_BuildValue("(iiii)", (int)expand, (int)fill, padding, pack_type);
}
%%
ignore gtk_clist_new
%%
override gtk_clist_new_with_titles kwargs
static int
_wrap_gtk_clist_new_with_titles(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "count", "titles", NULL };
    int count = 1, i;
    PyObject *py_list = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iO:GtkCList.__init__",
				     kwlist, &count, &py_list))
	return -1;
    if (py_list) {
	gchar **list;

	if (!PySequence_Check(py_list)) {
	    PyErr_SetString(PyExc_TypeError,"2nd argument not a sequence");
	    return -1;
	}
	if (PySequence_Length(py_list) < count) {
	    PyErr_SetString(PyExc_TypeError, "sequence not long enough");
	    return -1;
	}
	list = g_new(gchar *, count);
	for (i = 0; i < count; i++) {
	    PyObject *item = PySequence_GetItem(py_list, i);

	    Py_DECREF(item); /* PySequence_GetItem INCREF's */
	    if (!PyString_Check(item) && !PyUnicode_Check(item)) {
		PyErr_SetString(PyExc_TypeError,
				"sequence item not a string or unicode object");
		g_free(list);
		return -1;
	    }
	    list[i] = PyString_AsString(item);
	}
	self->obj = (GObject *)gtk_clist_new_with_titles(count, list);
	g_free(list);
    } else
	self->obj = (GObject *)gtk_clist_new(count);
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError,"could not create GtkCList object");
	return -1;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_clist_get_text kwargs
static PyObject *
_wrap_gtk_clist_get_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    char *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_text",
				     kwlist, &r, &c))
	return NULL;
    if (!gtk_clist_get_text(GTK_CLIST(self->obj), r, c, &text) || text==NULL) {
	PyErr_SetString(PyExc_ValueError, "can't get text value");
	return NULL;
    }
    return PyString_FromString(text);
}
%%
override gtk_clist_get_pixmap kwargs
static PyObject *
_wrap_gtk_clist_get_pixmap(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_pixmap",
				     kwlist, &r, &c))
	return NULL;
    if (!gtk_clist_get_pixmap(GTK_CLIST(self->obj), r, c,
			      &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixmap value");
	return NULL;
    }
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_clist_get_pixtext kwargs
static PyObject *
_wrap_gtk_clist_get_pixtext(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    gchar *text;
    guint8 spacing;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_pixtext",
				     kwlist, &r, &c))
	return NULL;
    if (!gtk_clist_get_pixtext(GTK_CLIST(self->obj), r, c,
			      &text, &spacing, &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixtext value");
	return NULL;
    }
    return Py_BuildValue("(ziNN)", text, (gint)spacing,
			 pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_clist_prepend kwargs
static PyObject *
_wrap_gtk_clist_prepend(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    int col, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCList.prepend",
				     kwlist, &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item) && !PyUnicode_Check(item)) {
	    PyErr_SetString(PyExc_TypeError,
			    "sequence item not a string or unicode object");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_prepend(GTK_CLIST(self->obj), list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_append kwargs
static PyObject *
_wrap_gtk_clist_append(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    int col, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCList.append",
				     kwlist, &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item) && !PyUnicode_Check(item)) {
	    PyErr_SetString(PyExc_TypeError,
			    "sequence item not a string or unicode object");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_append(GTK_CLIST(self->obj), list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_insert kwargs
static PyObject *
_wrap_gtk_clist_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "text", NULL };
    int col, row, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iO:GtkCList.insert",
				     kwlist, &row, &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item) && !PyUnicode_Check(item)) {
	    PyErr_SetString(PyExc_TypeError,
			    "sequence item not a string or unicode object");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_insert(GTK_CLIST(self->obj), row, list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_set_row_data kwargs
static PyObject *
_wrap_gtk_clist_set_row_data(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "row", "data", NULL };
    int row;
    PyObject *data;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iO:GtkCList.set_row_data",
				     kwlist, &row, &data))
	return NULL;
    Py_INCREF(data);
    gtk_clist_set_row_data_full(GTK_CLIST(self->obj), row, data,
				(GtkDestroyNotify)pyg_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clist_get_row_data kwargs
static PyObject *
_wrap_gtk_clist_get_row_data(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "row", NULL };
    PyObject *ret;
    int row;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkCList.get_row_data",
				     kwlist, &row))
        return NULL;
    ret = gtk_clist_get_row_data(GTK_CLIST(self->obj), row);
    if (!ret) ret = Py_None;
    Py_INCREF(ret);
    return ret;
}
%%
override gtk_clist_find_row_from_data kwargs
static PyObject *
_wrap_gtk_clist_find_row_from_data(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "data", NULL };
    PyObject *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkCList.find_row_from_data", kwlist,
				     &data))
        return NULL;
    return PyInt_FromLong(gtk_clist_find_row_from_data(
				GTK_CLIST(self->obj), data));
}
%%
override gtk_clist_get_selection_info kwargs
static PyObject *
_wrap_gtk_clist_get_selection_info(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    gint x, y, row, column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "ii:GtkCList.get_selection_info", kwlist,
				     &x, &y))
	return NULL;
    if (gtk_clist_get_selection_info(GTK_CLIST(self->obj), x, y,
				     &row, &column))
	return Py_BuildValue("(ii)", row, column);
    else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
override-attr GtkCList.selection
static PyObject *
_wrap_gtk_clist__get_selection(PyGObject *self, void *closure)
{
    guint row;
    GList *selection;
    PyObject *py_int, *ret = PyList_New(0);

    if (ret == NULL)
	return NULL;

    for (selection = GTK_CLIST(self->obj)->selection; selection != NULL;
	 selection = selection->next) {
	row = GPOINTER_TO_UINT(selection->data);

	py_int = PyInt_FromLong(row);

	if (!py_int) {
	    Py_DECREF(ret);
	    return NULL;
	}

	PyList_Append(ret, py_int);
	Py_DECREF(py_int);
    }
    return ret;
}
%%
override gtk_combo_set_popdown_strings kwargs
static PyObject *
_wrap_gtk_combo_set_popdown_strings(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "strings", NULL };
    PyObject *list;
    GList *glist = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkCombo.set_popdown_strings", kwlist,
				     &list))
	return NULL;
    if (!PySequence_Check(list)) {
	PyErr_SetString(PyExc_TypeError, "first argument must be a sequence");
	return NULL;
    }
    len = PySequence_Length(list);
    for (i = 0; i < len; i++) {
	PyObject *item = PySequence_GetItem(list, i);

	Py_DECREF(item);
	if (!PyString_Check(item) && !PyUnicode_Check(item)) {
	    PyErr_SetString(PyExc_TypeError,
			    "sequence item not a string or unicode object");
	    g_list_free(glist);
	    return NULL;
	}
	glist = g_list_append(glist, PyString_AsString(item));
    }
    gtk_combo_set_popdown_strings(GTK_COMBO(self->obj), glist);
    g_list_free(glist);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_curve_get_vector kwargs
static PyObject *
_wrap_gtk_curve_get_vector(PyGObject *self, PyObject *args,
			   PyObject *kwargs)
{
    static char *kwlist[] = { "size", NULL };
    int size = -1, i;
    gfloat *vector;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|i:GtkCurve.get_vector", kwlist,
				     &size))
	return NULL;
    if (size < 0) size = GTK_CURVE(self->obj)->num_points;
    vector = g_new(gfloat, size);
    gtk_curve_get_vector(GTK_CURVE(self->obj), size, vector);
    ret = PyTuple_New(size);
    for (i = 0; i < size; i++)
	PyTuple_SetItem(ret, i, PyFloat_FromDouble(vector[i]));
    g_free(vector);
    return ret;
}
%%
override gtk_curve_set_vector kwargs
static PyObject *
_wrap_gtk_curve_set_vector(PyGObject *self, PyObject *args,
			   PyObject *kwargs)
{
    static char *kwlist[] = { "vector", NULL };
    PyObject *seq;
    int size, i;
    gfloat *vector;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCurve.set_vector",
				     kwlist, &seq))
	return NULL;
    if (!PySequence_Check(seq)) {
	PyErr_SetString(PyExc_TypeError, "1st argument is not a sequence");
	return NULL;
    }
    size = PySequence_Length(seq);
    vector = g_new(gfloat, size);
    for (i = 0; i < size; i++) {
	PyObject *item = PySequence_GetItem(seq, i);

	Py_DECREF(item);
	item = PyNumber_Float(item); /* item has a ref now */
	if (item == NULL) {
	    g_free(vector);
	    return NULL;
	}
	vector[i] = PyFloat_AsDouble(item);
	Py_DECREF(item);
    }
    gtk_curve_set_vector(GTK_CURVE(self->obj), size, vector);
    g_free(vector);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_model_get_iter
static PyObject *
_wrap_gtk_tree_model_get_iter(PyGObject *self, PyObject *args) {
    GtkTreeIter iter;
    GtkTreePath *path;

    path = pygtk_tree_path_from_pyobject(args);
    if (!path) {
	PyErr_SetString(PyExc_TypeError, "GtkTreeModel.get_iter requires at least one integer argument");
	return NULL;
    }
    if (gtk_tree_model_get_iter(GTK_TREE_MODEL(self->obj), &iter, path)) {
	gtk_tree_path_free(path);
	return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    } else {
	gtk_tree_path_free(path);
	PyErr_SetString(PyExc_ValueError, "invalid tree path");
	return NULL;
    }
}
%%
override gtk_tree_model_get_value kwargs
static PyObject *
_wrap_gtk_tree_model_get_value(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    static char *kwlist[] = { "iter", "column", NULL };
    PyObject *iter, *ret;
    gint column;
    GValue value = { 0, };

    if (!PyArg_ParseTupleAndKeywords(args,kwargs, "Oi:GtkTreeModel.get_value",
				     kwlist, &iter, &column))
	return NULL;
    if (column < 0 ||
	column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	PyErr_SetString(PyExc_ValueError, "column number is out of range");
	return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    gtk_tree_model_get_value(GTK_TREE_MODEL(self->obj),
			     pyg_boxed_get(iter, GtkTreeIter), column, &value);
    ret = pyg_value_as_pyobject(&value);
    g_value_unset(&value);
    return ret;
}
%%
ignore gtk_list_store_newv
%%
override gtk_list_store_new
static PyObject *
_wrap_gtk_list_store_new(PyGObject *self, PyObject *args)
{
    guint len, i;
    GType *column_types;

    len = PyTuple_Size(args);
    column_types = g_new(GType, len);
    for (i = 0; i < len; i++) {
	PyObject *item = PyTuple_GetItem(args, i);

	column_types[i] = pyg_type_from_object(item);
	if (column_types[i] == 0) {
	    g_free(column_types);
	    return NULL;
	}
    }
    self->obj = (GObject *)gtk_list_store_newv(len, column_types);
    g_free(column_types);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkListStore object");
        return NULL;
    }
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_store_set
static PyObject *
_wrap_gtk_list_store_set(PyGObject *self, PyObject *args)
{
    PyObject *iter;
    int len, i;

    iter = PyTuple_GetItem(args, 0);
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    len = PyTuple_Size(args);
    if ((len - 1) % 2) {
	PyErr_SetString(PyExc_TypeError,
			"Argument list must be column, value pairs.  No -1 "
			"termination is needed.");
	return NULL;
    }
    for (i = 1; i < len; i+=2) {
	gint column;
	GValue value = { 0 };
	PyObject *py_column = PyTuple_GetItem(args, i);
	PyObject *py_value = PyTuple_GetItem(args, i + 1);

	if (!PyInt_Check(py_column)) {
	    PyErr_SetString(PyExc_TypeError,
			    "Expected numeric argument for column.");
	    return NULL;
	}
	column = PyInt_AsLong(py_column);
	if (column < 0 ||
	    column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	    PyErr_SetString(PyExc_ValueError, "column number is out of range");
	    return NULL;
	}
	g_value_init(&value,
		     gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),
						    column));
	if (pyg_value_from_pyobject(&value, py_value)) {
	    PyErr_SetString(PyExc_TypeError,
			    "value is of the wrong type for this column");
	    return NULL;
	}
	gtk_list_store_set_value(GTK_LIST_STORE(self->obj),
				 pyg_boxed_get(iter, GtkTreeIter), column, &value);
	g_value_unset(&value);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_store_set_value kwargs
static PyObject *
_wrap_gtk_list_store_set_value(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "column", "value", NULL };
    PyObject *iter, *pyvalue;
    gint column;
    GValue value = { 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OiO:GtkListStore.set_value",
				     kwlist, &iter, &column, &pyvalue))
	return NULL;
    if (column < 0 ||
	column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	PyErr_SetString(PyExc_ValueError, "column number is out of range");
	return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    g_value_init(&value,
		 gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),
						column));
    if (pyg_value_from_pyobject(&value, pyvalue)) {
	PyErr_SetString(PyExc_TypeError,
			"value is of the wrong type for this column");
	return NULL;
    }
    gtk_list_store_set_value(GTK_LIST_STORE(self->obj),
			     pyg_boxed_get(iter, GtkTreeIter), column, &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore
  gtk_list_store_setv
%%
  override gtk_list_store_insert kwargs
static PyObject *
_wrap_gtk_list_store_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", NULL };
    GtkTreeIter iter;
    gint position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkListStore.insert",
				     kwlist, &position))
	return NULL;
    gtk_list_store_insert(GTK_LIST_STORE(self->obj), &iter, position);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_insert_before kwargs
static PyObject *
_wrap_gtk_list_store_insert_before(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "sibling", NULL };
    PyObject *sibling;
    GtkTreeIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkListStore.insert_before",
				     kwlist, &sibling))
	return NULL;
    if (!pyg_boxed_check(sibling, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    gtk_list_store_insert_before(GTK_LIST_STORE(self->obj), &iter,
				 pyg_boxed_get(sibling, GtkTreeIter));
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_insert_after kwargs
static PyObject *
_wrap_gtk_list_store_insert_after(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "sibling", NULL };
    PyObject *sibling;
    GtkTreeIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkListStore.insert_after",
				     kwlist, &sibling))
	return NULL;
    if (!pyg_boxed_check(sibling, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    gtk_list_store_insert_after(GTK_LIST_STORE(self->obj), &iter,
				pyg_boxed_get(sibling, GtkTreeIter));
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_prepend noargs
static PyObject *
_wrap_gtk_list_store_prepend(PyGObject *self)
{
    GtkTreeIter iter;

    gtk_list_store_prepend(GTK_LIST_STORE(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_append noargs
static PyObject *
_wrap_gtk_list_store_append(PyGObject *self)
{
    GtkTreeIter iter;

    gtk_list_store_append(GTK_LIST_STORE(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
ignore gtk_tree_store_newv
%%
override gtk_tree_store_new
static PyObject *
_wrap_gtk_tree_store_new(PyGObject *self, PyObject *args)
{
    guint len, i;
    GType *column_types;

    len = PyTuple_Size(args);
    column_types = g_new(GType, len);
    for (i = 0; i < len; i++) {
	PyObject *item = PyTuple_GetItem(args, i);

	column_types[i] = pyg_type_from_object(item);
	if (column_types[i] == 0) {
	    g_free(column_types);
	    return NULL;
	}
    }
    self->obj = (GObject *)gtk_tree_store_newv(len, column_types);
    g_free(column_types);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkTreeStore object");
        return NULL;
    }
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_store_set
static PyObject *
_wrap_gtk_tree_store_set(PyGObject *self, PyObject *args)
{
    PyObject *iter;
    int len, i;

    iter = PyTuple_GetItem(args, 0);

    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    len = PyTuple_Size(args);
    if ((len - 1) % 2) {
	PyErr_SetString(PyExc_TypeError,
			"Argument list must be column, value pairs.  No -1 "
			"termination is needed.");
	return NULL;
    }
    for (i = 1; i < len; i+=2) {
	gint column;
	GValue value = { 0 };
	PyObject *py_column = PyTuple_GetItem(args, i);
	PyObject *py_value = PyTuple_GetItem(args, i + 1);

	if (!PyInt_Check(py_column)) {
	    PyErr_SetString(PyExc_TypeError,
			    "Expected numeric argument for column.");
	    return NULL;
	}
	column = PyInt_AsLong(py_column);
	if (column < 0 ||
	    column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	    PyErr_SetString(PyExc_ValueError, "column number is out of range");
	    return NULL;
	}
	g_value_init(&value,
		     gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),
						    column));
	if (pyg_value_from_pyobject(&value, py_value)) {
	    PyErr_SetString(PyExc_TypeError,
			    "value is of the wrong type for this column");
	    return NULL;
	}
	gtk_tree_store_set_value(GTK_TREE_STORE(self->obj),
				 pyg_boxed_get(iter, GtkTreeIter), column,
				 &value);
	g_value_unset(&value);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_store_set_value kwargs
static PyObject *
_wrap_gtk_tree_store_set_value(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "column", "value", NULL };
    PyObject *iter, *pyvalue;
    gint column;
    GValue value = { 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OiO:GtkTreeStore.set_value",
				     kwlist, &iter, &column, &pyvalue))
	return NULL;
    if (column < 0 ||
	column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	PyErr_SetString(PyExc_ValueError, "column number is out of range");
	return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    g_value_init(&value,
		 gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),
						column));
    if (pyg_value_from_pyobject(&value, pyvalue)) {
	PyErr_SetString(PyExc_TypeError,
			"value is of the wrong type for this column");
	return NULL;
    }
    gtk_tree_store_set_value(GTK_TREE_STORE(self->obj),
			     pyg_boxed_get(iter, GtkTreeIter), column, &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore
  gtk_tree_store_setv
%%
override gtk_tree_store_insert kwargs
static PyObject *
_wrap_gtk_tree_store_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "position", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;
    gint position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oi:GtkTreeStore.insert",
				     kwlist, &py_parent, &position))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_insert(GTK_TREE_STORE(self->obj), &iter, parent, position);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_insert_before kwargs
static PyObject *
_wrap_gtk_tree_store_insert_before(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", NULL };
    PyObject *py_parent, *py_sibling;
    GtkTreeIter iter, *parent = NULL, *sibling = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkTreeStore.insert_before",
				     kwlist, &py_parent, &py_sibling))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    if (pyg_boxed_check(py_sibling, GTK_TYPE_TREE_ITER))
	sibling = pyg_boxed_get(py_sibling, GtkTreeIter);
    else if (py_sibling != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sibling must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_insert_before(GTK_TREE_STORE(self->obj), &iter, parent,
				 sibling);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_insert_after kwargs
static PyObject *
_wrap_gtk_tree_store_insert_after(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", NULL };
    PyObject *py_parent, *py_sibling;
    GtkTreeIter iter, *parent = NULL, *sibling = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkTreeStore.insert_after",
				     kwlist, &py_parent, &py_sibling))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    if (pyg_boxed_check(py_sibling, GTK_TYPE_TREE_ITER))
	sibling = pyg_boxed_get(py_sibling, GtkTreeIter);
    else if (py_sibling != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sibling must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_insert_after(GTK_TREE_STORE(self->obj), &iter, parent,
				sibling);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_prepend kwargs
static PyObject *
_wrap_gtk_tree_store_prepend(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTreeStore.prepend",
				     kwlist, &py_parent))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_append kwargs
static PyObject *
_wrap_gtk_tree_store_append(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTreeStore.append",
				     kwlist, &py_parent))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_model_get_iter_root noargs
static PyObject *
_wrap_gtk_tree_model_get_iter_root(PyGObject *self)
{
    GtkTreeIter iter;

    gtk_tree_model_get_iter_root(GTK_TREE_MODEL(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_model_iter_children kwargs
static PyObject *
_wrap_gtk_tree_model_iter_children(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    PyObject *py_parent;
    static char *kwlist[] = { "parent", NULL };
    GtkTreeIter iter, *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkTreeModel.iter_children", kwlist,
				     &py_parent))
        return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
        parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkTreeIter");
        return NULL;
    }

    if (gtk_tree_model_iter_children(GTK_TREE_MODEL(self->obj),
				     &iter, parent))
	return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
ignore
  gtk_tree_view_new
  gtk_tree_view_column_new_with_attributes
%%
override gtk_tree_view_column_new kwargs
static int
_wrap_gtk_tree_view_column_new(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    PyObject *py_cell = NULL, *key, *item;
    GtkTreeViewColumn *tvc;
    gchar *title = NULL;
    GtkCellRenderer *cell = NULL;
    gint i = 0;

    if (!PyArg_ParseTuple(args, "|zO:GtkTreeViewColumn.__init__", &title,
			  &py_cell))
	return -1;
    if (py_cell != NULL) {
	if (pygobject_check(py_cell, &PyGtkCellRenderer_Type))
	    cell = GTK_CELL_RENDERER(pygobject_get(py_cell));
	else if (py_cell != Py_None) {
	    PyErr_SetString(PyExc_TypeError,
			    "cell must be a GtkCellRenderer or None");
	    return -1;
	}
    }
    tvc = gtk_tree_view_column_new();
    if (title)
	gtk_tree_view_column_set_title(tvc, title);
    if (cell)
	gtk_tree_view_column_pack_start(tvc, cell, TRUE);
    if (kwargs) {
	while (PyDict_Next(kwargs, &i, &key, &item)) {
	    gchar *attr = PyString_AsString(key);

	    if (!PyInt_Check(item)) {
		gchar err[128];
		g_snprintf(err, sizeof(err),
			   "%s must be an integer column number", attr);
		PyErr_SetString(PyExc_TypeError, err);
		g_object_unref(G_OBJECT(tvc));
		return -1;
	    }
	    gtk_tree_view_column_add_attribute(tvc, cell, attr,
					       PyInt_AsLong(item));
	}
    }
    self->obj = (GObject *)tvc;
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_tree_view_get_path_at_pos kwargs
static PyObject *
_wrap_gtk_tree_view_get_path_at_pos(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    gint x, y;
    GtkTreePath *path;
    GtkTreeViewColumn *column;
    gint cell_x, cell_y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "ii:GtkTreeView.get_path_at_pos",
				     kwlist, &x, &y))
	return NULL;
    if (gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(self->obj), x, y,
				      &path, &column, &cell_x, &cell_y)) {
	PyObject *ret = PyTuple_New(4);

	if (path) {
	    PyTuple_SetItem(ret, 0, pygtk_tree_path_to_pyobject(path));
	    gtk_tree_path_free(path);
	} else {
	    Py_INCREF(Py_None);
	    PyTuple_SetItem(ret, 0, Py_None);
	}
	PyTuple_SetItem(ret, 1, pygobject_new((GObject *)column));
	PyTuple_SetItem(ret, 2, PyInt_FromLong(cell_x));
	PyTuple_SetItem(ret, 3, PyInt_FromLong(cell_y));
	return ret;
    } else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
override gtk_tree_selection_get_selected noargs
static PyObject *
_wrap_gtk_tree_selection_get_selected(PyGObject *self)
{
    GtkTreeModel *model;
    GtkTreeIter iter;

    if (gtk_tree_selection_get_selected(GTK_TREE_SELECTION(self->obj),
					&model, &iter))
	return Py_BuildValue("(NN)", pygobject_new((GObject *)model),
			     pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter,
					   TRUE, TRUE));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_selection_selected_foreach
static void
pygtk_tree_foreach_marshal(GtkTreeModel *model,
			   GtkTreePath *path,
			   GtkTreeIter *iter,
			   gpointer data)
{
    PyGtkCustomNotify *cunote = data;
    PyObject *pypath, *retobj;

    g_assert(cunote->func);
    
    pypath = pygtk_tree_path_to_pyobject(path);
    if (cunote->data)
	retobj = PyEval_CallFunction(cunote->func, "(OO)", pypath,
				     cunote->data);
    else
	retobj = PyEval_CallFunction(cunote->func, "(O)", pypath);

    if (retobj == NULL) {
	PyErr_Print();
	PyErr_Clear();
    }
    
    Py_DECREF(pypath);
    Py_XDECREF(retobj);
}
static PyObject *
_wrap_gtk_tree_selection_selected_foreach(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify cunote;
    
    if(!PyArg_ParseTuple(args, "O|O:GtkTreeSelection.selected_foreach",
			 &pyfunc, &pyarg))
	return NULL;
    
    cunote.func = pyfunc;
    cunote.data = pyarg;
    gtk_tree_selection_selected_foreach(GTK_TREE_SELECTION(self->obj),
					pygtk_tree_foreach_marshal, &cunote);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_selection_set_select_function

static gboolean
pygtk_tree_selection_marshal(GtkTreeSelection *selection,
			     GtkTreeModel *model,
			     GtkTreePath *path,
			     gboolean path_currently_selected,
			     gpointer data)
{
    gboolean retval = FALSE;
    PyGtkCustomNotify *cunote = data;
    PyObject *pypath, *retobj;
    
    pyg_block_threads();

    g_assert(cunote->func);
    
    pypath = pygtk_tree_path_to_pyobject(path);
    if (cunote->data)
	retobj = PyEval_CallFunction(cunote->func, "(OO)", pypath,
				     cunote->data);
    else
	retobj = PyEval_CallFunction(cunote->func, "(O)", pypath);

    if (retobj == NULL) {
	PyErr_Print();
	PyErr_Clear();
    }
    
    Py_DECREF(pypath);
    if (retobj) {
	if(retobj == Py_None);
	else if(PyInt_Check(retobj))
	    retval = PyInt_AsLong(retobj) && TRUE;
	else if(PyLong_Check(retobj))
	    retval = PyLong_AsLongLong(retobj) && TRUE;
	else if(PyString_Check(retobj))
	    retval = PyString_GET_SIZE(retobj) && TRUE;
	
	Py_DECREF(retobj);
    }
    
    pyg_unblock_threads();
    
    return retval;
}
static PyObject *
_wrap_gtk_tree_selection_set_select_function(PyGObject *self, PyObject *args)
{
    PyObject *pyfunc, *pyarg = NULL;
    PyGtkCustomNotify *cunote;
    
    if(!PyArg_ParseTuple(args, "O|O:GtkTreeSelection.set_select_function",
			 &pyfunc, &pyarg))
	return NULL;
    
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pyarg;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);
    gtk_tree_selection_set_select_function(GTK_TREE_SELECTION(self->obj),
					   pygtk_tree_selection_marshal,
					   cunote,
					   pygtk_custom_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_binding_entry_add_signal

static PyObject *
_wrap_gtk_binding_entry_add_signal(PyGObject *self, PyObject *args)
{
    PyObject *first;
    gint len, i;
    PyObject *class;
    guint keyval, modifiers;
    gchar *signal_name;
    GType class_type;
    GtkBindingSet *bset = NULL;
    GSList *slist = NULL;
    gchar *errmsg;

    len = PyTuple_Size(args);
    if (len < 4) {
	PyErr_SetString(PyExc_TypeError, "binding_entry_add_signal requires at"
			" least 4 arguments");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 4);
    if (!PyArg_ParseTuple(first, "Oiis:binding_entry_add_signal", &class,
			  &keyval, &modifiers, &signal_name)) {
	Py_DECREF(first);
	return NULL;
    }
    Py_DECREF(first);

    class_type = pyg_type_from_object(class);
    if (class_type == 0)
	return NULL;

    bset = gtk_binding_set_by_class(gtk_type_class(class_type));

    /* extra args */
    if ((len-4)%2) {
	PyErr_SetString(PyExc_ValueError,
			"GtkBindingSet.add_signal requires an even number"
			" of parameter pairs following the first four args");
	return NULL;
    }
    for (i=4; i < len; i+=2) {
	PyObject *item;
	GType arg_type;
	GtkBindingArg *arg = NULL;

	item = PyTuple_GET_ITEM(args, i);
	arg_type = pyg_type_from_object(item);
	if (!arg_type) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "GtkBindingSet.add_signal parameter types"
			    " must be int");
	    goto arg_error;
	}
	arg = g_new0 (GtkBindingArg, 1);
	slist = g_slist_prepend(slist, arg);
    
	arg->arg_type = arg_type;
	switch (GTK_FUNDAMENTAL_TYPE(arg->arg_type)) {
	case GTK_TYPE_CHAR:
	case GTK_TYPE_UCHAR:
	case GTK_TYPE_INT:
	case GTK_TYPE_UINT:
	case GTK_TYPE_BOOL:
	case GTK_TYPE_ENUM:
	case GTK_TYPE_FLAGS:
	case GTK_TYPE_LONG:
	case GTK_TYPE_ULONG:
	    arg->arg_type = GTK_TYPE_LONG;
	    item = PyTuple_GET_ITEM(args, i+1);
	    if (!PyInt_Check(item)) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal "
					 "arg[%u] must be int", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    arg->d.long_data = (glong)PyInt_AsLong(item);
	    break;
	case GTK_TYPE_FLOAT:
	case GTK_TYPE_DOUBLE:
	    arg->arg_type = GTK_TYPE_DOUBLE;
	    item = PyTuple_GET_ITEM(args, i+1);
	    if (!PyFloat_Check(item)) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal "
					 "arg[%u] must be float", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    arg->d.long_data = (gdouble)PyFloat_AsDouble(item);
	    break;
	case GTK_TYPE_STRING:
	    arg->arg_type = GTK_TYPE_STRING;
	    if (arg->arg_type != GTK_TYPE_IDENTIFIER)
		arg->arg_type = GTK_TYPE_STRING;
	    item = PyTuple_GET_ITEM(args, i+1);
	    if (!PyString_Check(item)) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
					 "must be non-empty string", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    arg->d.string_data = (gchar*)PyString_AsString(item);
	    if (!arg->d.string_data) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
					 "must be non-empty string", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    break;
	default:
	    errmsg = g_strdup_printf("GtkBindingSet.add_signal unsupported "
				     "type %10s for arg[%u]",
				     gtk_type_name(arg->arg_type), i+1);
	    PyErr_SetString(PyExc_TypeError, errmsg);
	    g_free(errmsg);
	    goto arg_error;
	} /* switch */
    }

    slist = g_slist_reverse (slist);
    gtk_binding_entry_add_signall (bset, keyval,modifiers, signal_name, slist);

    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);

    Py_INCREF(Py_None);
    return Py_None;

arg_error:
    if (slist) {
	g_slist_foreach(slist, (GFunc)g_free, NULL);
	g_slist_free(slist);
    }
    return NULL;
}

/* -------------- haven't updated stuff below this line -------------- */
%%
ignore-glob
  _*
  *_get_type
  gtk_marshal_*
  gtk_arg_*
  gtk_args_*
  gtk_signal_connect*
  gtk_signal_add_emission_hook*
  gtk_signal_new*
  gtk_draw_*
  gtk_init_add_*
  gtk_quit_add_*
  gtk_timeout_add_*
  gtk_idle_add_*
  gtk_accelerator_*
  gtk_target_list_*
  gtk_pattern_*
  gtk_gc_*
  gtk_signal_*
  gtk_tree_path_*
%%
ignore
  gtk_binding_set_new
  gtk_binding_set_by_class
  gtk_binding_set_find
  gtk_binding_set_clear
  gtk_init
  gtk_init_check
  gtk_exit
  gtk_set_locale
  gtk_accel_group_ref
  gtk_accel_group_unref
  gtk_accel_groups_activate
  gtk_accel_group_activate
  gtk_accel_group_get_entry
  gtk_accel_group_lock_entry
  gtk_accel_group_unlock_entry
  gtk_accel_group_add
  gtk_accel_group_remove
  gtk_accel_group_handle_add
  gtk_accel_group_handle_remove
  gtk_accel_group_create_add
  gtk_accel_group_create_remove
  gtk_accel_groups_from_object
  gtk_accel_group_entries_from_object
  gtk_signal_set_funcs
  gtk_signal_lookup
  gtk_signal_disconnect_by_func
  gtk_signal_disconnect_by_data
  gtk_signal_handler_block_by_func
  gtk_signal_handler_block_by_data
  gtk_signal_handler_unblock_by_func
  gtk_signal_handler_unblock_by_data
  gtk_signal_handler_pending_by_func
  gtk_signal_n_emissions
  gtk_signal_n_emissions_by_name
  gtk_signal_name
  gtk_signal_remove_emission_hook
  gtk_signal_query
  gtk_signal_emit
  gtk_signal_emit_by_name
  gtk_signal_emitv
  gtk_signal_emitv_by_name
  gtk_quit_remove_by_data
  gtk_idle_remove_by_data
  gtk_object_ref
  gtk_object_unref
  gtk_object_sink
  gtk_object_weakref
  gtk_object_weakunref
  gtk_object_get
  gtk_object_getv
  gtk_object_set
  gtk_object_setv
  gtk_object_set_data
  gtk_object_set_data_full
  gtk_object_get_data
  gtk_object_set_user_data
  gtk_object_get_user_data
  gtk_object_set_data_by_id
  gtk_object_set_data_by_id_full
  gtk_object_get_data_by_id
  gtk_object_remove_data_by_id
  gtk_object_remove_no_notify_by_id
  gtk_object_arg_set
  gtk_object_arg_get
  gtk_trace_referencing
  gtk_widget_ref
  gtk_widget_unref
  gtk_widget_get
  gtk_widget_getv
  gtk_widget_set
  gtk_widget_setv
  gtk_container_get_toplevels
  gtk_container_add_child_arg_type
  gtk_container_query_child_args
  gtk_container_child_args_collect
  gtk_container_child_arg_get_info
  gtk_container_foreach
  gtk_container_foreach_full
  gtk_container_forall
  gtk_container_child_getv
  gtk_container_child_setv
  gtk_container_add_with_args
  gtk_container_addv
  gtk_container_child_set
  gtk_container_arg_set
  gtk_container_arg_get
  gtk_clist_set_row_data_full
  gtk_window_add_embedded_xid
  gtk_window_remove_embedded_xid
  gtk_range_trough_click
  gtk_range_default_htrough_click
  gtk_range_default_vtrough_click
  gtk_tooltips_data_get
  gtk_type_check_object_cast
  gtk_type_check_class_cast
  gtk_type_register_enum
  gtk_type_register_flags
  gtk_preview_uninit
  gtk_item_factory_create_item
  gtk_item_factory_delete_entry
  gtk_item_factory_delete_entries
  gtk_item_factory_popup_with_data
  gtk_item_factory_popup_data
  gtk_item_factory_set_translate_func
  gtk_item_factory_create_items_ac
  gtk_item_factory_create_menu_entries
  gtk_menu_attach_to_widget
  gtk_menu_bar_append
  gtk_menu_bar_insert
  gtk_menu_bar_prepend
  gtk_radio_menu_item_group
  gtk_radio_menu_item_set_group
  gtk_radio_button_group
  gtk_radio_button_set_group
  gtk_entry_new
%%
ignore gtk_object_new gtk_object_newv gtk_object_query_args
  gtk_object_add_arg_type gtk_object_args_collect gtk_object_arg_get_info
  gtk_widget_new gtk_widget_newv
%%
ignore gtk_true gtk_false gtk_key_snooper_install gtk_key_snooper_remove
  gtk_get_current_event gtk_get_event_widget gtk_propagate_event
%%
override gtk_main noargs
static PyObject *
_wrap_gtk_main(PyObject *self)
{
    pyg_unblock_threads();
    gtk_main();
    pyg_block_threads();
    if (PyErr_Occurred())
	return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_main_iteration kwargs
static PyObject *
_wrap_gtk_main_iteration(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"block", NULL};
    int block = 1, ret;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:main_iteration", kwlist,
				    &block)) 
        return NULL;
    pyg_unblock_threads();
    ret = gtk_main_iteration_do(block);
    pyg_block_threads();
    return PyInt_FromLong(ret);
}
%%
override gtk_timeout_add
static PyObject *
_wrap_gtk_timeout_add(PyObject *self, PyObject *args)
{
    guint32 interval;
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 2) {
	PyErr_SetString(PyExc_TypeError,
			"timeout_add requires at least 2 args");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "iO:timeout_add", &interval, &callback)) {
	Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "second arg not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 2, len);

    if (cbargs == NULL)
      return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_timeout_add_full(interval, NULL,
				(GtkCallbackMarshal)pygtk_handler_marshal,
				data, (GtkDestroyNotify)pyg_destroy_notify));
}
%%
override gtk_idle_add
static PyObject *
_wrap_gtk_idle_add(PyObject *self, PyObject *args)
{
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 1) {
	PyErr_SetString(PyExc_TypeError,
			"idle_add requires at least 1 arg");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 1);
    if (!PyArg_ParseTuple(first, "O:idle_add", &callback)) {
	Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "first arg not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 1, len);

    if (cbargs == NULL)
      return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_idle_add_full(GTK_PRIORITY_DEFAULT, NULL,
        (GtkCallbackMarshal)pygtk_handler_marshal,
        data, (GtkDestroyNotify)pyg_destroy_notify));
}
%%
override gtk_quit_add
static PyObject *
_wrap_gtk_quit_add(PyObject *self, PyObject *args)
{
    gint main_level;
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 2) {
	PyErr_SetString(PyExc_TypeError,
			"quit_add requires at least 2 args");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "iO:quit_add", &main_level, &callback)) {
	Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "second arg not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 2, len);

    if (cbargs == NULL)
      return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_quit_add_full(main_level, NULL,
        (GtkCallbackMarshal)pygtk_handler_marshal,
        data, (GtkDestroyNotify)pyg_destroy_notify));
}
%%
override gtk_input_add_full kwargs
static PyObject *
_wrap_gtk_input_add_full(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "source", "condition", "callback", NULL };
    PyObject *py_source, *callback;
    int source;
    GdkInputCondition condition;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:input_add_full",
				     kwlist, &py_source, &condition,
				     &callback))
        return NULL;
    source = PyObject_AsFileDescriptor(py_source);
    if (PyErr_Occurred()) {
	PyErr_Clear();
	PyErr_SetString(PyExc_TypeError, "1st arg not a file descriptor");
	return NULL;
    }
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "3rd arg not callable.");
        return NULL;
    }
    Py_INCREF(callback);
    return PyInt_FromLong(gtk_input_add_full(source, condition, NULL,
			(GtkCallbackMarshal)pygtk_input_marshal, callback,
			(GtkDestroyNotify)pyg_destroy_notify));
}
%%
override gtk_editable_insert_text kwargs
static PyObject *
_wrap_gtk_editable_insert_text(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;
    int len, pos=0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s#|i:GtkEditable.insert_text",
				     kwlist, &text, &len, &pos))
        return NULL;
    gtk_editable_insert_text(GTK_EDITABLE(self->obj), text, len, &pos);
    return PyInt_FromLong(pos);
}
%%
override gtk_editable_get_selection_bounds noargs
static PyObject *
_wrap_gtk_editable_get_selection_bounds(PyGObject *self, PyObject *args)
{
    int start, end;

    if (!gtk_editable_get_selection_bounds(GTK_EDITABLE(self->obj), &start, &end)) {
	    return Py_BuildValue ("()");
    }
    
    return Py_BuildValue ("(ii)", start, end);
}
%%
override gtk_entry_get_layout_offsets noargs
static PyObject *
_wrap_gtk_entry_get_layout_offsets(PyGObject *self, PyObject *args)
{
    int x, y;

    gtk_entry_get_layout_offsets(GTK_ENTRY(self->obj), &x, &y);
    
    return Py_BuildValue ("(ii)", x, y);
}
%%
override gtk_item_factory_create_items kwargs
static void
pygtk_item_factory_cb(PyGtkCustomNotify *cunote,
		      guint action, GtkWidget *widget)
{
    PyObject *ret;

    pyg_block_threads();
    if (cunote->data)
	ret = PyObject_CallFunction(cunote->func, "OiO", cunote->data, action,
				    pygobject_new((GObject *)widget));
    else
	ret = PyObject_CallFunction(cunote->func, "iO", action,
				    pygobject_new((GObject *)widget));
    if (ret == NULL) {
	PyErr_Print();
	PyErr_Clear();
    } else
	Py_DECREF(ret);
    pyg_unblock_threads();
}
static PyObject *
_wrap_gtk_item_factory_create_items(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "callback_data", NULL };
    PyObject *list, *cb, *cbdata = NULL;
    GtkItemFactoryEntry ent;
    PyObject *extra_data = NULL;
    GtkItemFactory *ifact;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O|O:GtkItemFactory.create_items", kwlist,
				     &list, &cbdata))
	return NULL;

    if (!PySequence_Check(list)) {
	PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
	return NULL;
    }

    ifact = GTK_ITEM_FACTORY(self->obj);
    len = PySequence_Size(list);
    for (i = 0; i < len; i++) {
	PyGtkCustomNotify *cunote = NULL;
	PyObject *item = PySequence_GetItem(list, i);
	Py_DECREF(item);

	memset(&ent, 0, sizeof(ent));
	cb = Py_None;
	
	if (!PyArg_ParseTuple(item, "s|zOizO", &(ent.path), &(ent.accelerator),
			      &cb, &(ent.callback_action), &(ent.item_type),
			      &extra_data)) {
	    return NULL;
	}
	
	if (cb == Py_None) {
	    ent.callback = NULL;
	} else {
	    ent.callback = (GtkItemFactoryCallback)pygtk_item_factory_cb;
	    cunote = g_new0(PyGtkCustomNotify, 1);
	    cunote->func = cb;
	    cunote->data = cbdata;
	    Py_XINCREF(cunote->func);
	    Py_XINCREF(cunote->data);
	}
	
	if (extra_data != NULL) {
	    if (PyString_Check(extra_data)) {
		ent.extra_data = PyString_AsString(extra_data);
	    } else if (pygobject_check(extra_data, &PyGdkPixbuf_Type)) {
		ent.extra_data = GDK_PIXBUF(pygobject_get(extra_data));
	    } else {
		PyErr_SetString(PyExc_TypeError, 
				"last argument must be a GdkPixBuf or a string");
		return NULL;
	    }
	}
	if (cunote != NULL)
	    g_object_weak_ref(G_OBJECT(ifact),
			      (GWeakNotify) pygtk_custom_destroy_notify,
			      cunote);
			     
	gtk_item_factory_create_item(ifact, &ent, cunote, 1);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_menu_popup kwargs
static void
pygtk_menu_position(GtkMenu *menu, int *x, int *y, PyObject *func)
{
    PyObject *ret;

    pyg_block_threads();
    ret = PyObject_CallFunction(func, "Oii", pygobject_new((GObject *)menu),
                                *x, *y);
    if (ret == NULL || !PyArg_ParseTuple(ret, "ii", x, y)) {
	PyErr_Print();
	PyErr_Clear();
        if (ret) {
          Py_DECREF(ret);
        }
    } else {
        Py_DECREF(ret);
    }
    pyg_unblock_threads();
}
static PyObject *
_wrap_gtk_menu_popup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent_menu_shell", "parent_menu_item", "func",
		       "button", "activate_time", NULL };
    PyGObject *py_pms, *py_pmi;
    GtkWidget *pms = NULL, *pmi = NULL;
    PyObject *func;
    int button, time;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,  "OOOii:GtkMenu.popup",
				     kwlist, &py_pms, &py_pmi, &func,
				     &button, &time))
        return NULL;
    if (pygobject_check(py_pms, &PyGtkWidget_Type))
        pms = GTK_WIDGET(py_pms->obj);
    else if ((PyObject *)py_pms != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_pmi, &PyGtkWidget_Type))
        pmi = GTK_WIDGET(py_pmi->obj);
    else if ((PyObject *)py_pmi != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (!PyCallable_Check(func) && func != Py_None) {
        PyErr_SetString(PyExc_TypeError, "third argument not callable");
        return NULL;
    }
    if (func != Py_None) {
	Py_INCREF(func);
	gtk_menu_popup(GTK_MENU(self->obj), pms, pmi,
		       (GtkMenuPositionFunc)pygtk_menu_position,
		       func, button, time);
    } else
	gtk_menu_popup(GTK_MENU(self->obj), pms, pmi, NULL,NULL, button,time);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_pixmap_get noargs
static PyObject *
_wrap_gtk_pixmap_get(PyGObject *self)
{
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    gtk_pixmap_get(GTK_PIXMAP(self->obj), &pixmap, &mask);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}

%%
ignore gtk_button_new_with_label gtk_button_new_from_stock gtk_button_new_with_mnemonic
%%
override gtk_button_new kwargs
static int
_wrap_gtk_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", "stock", NULL };
    gchar *text = NULL, *stock = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|zz:GtkButton.__init__",
				     kwlist, &text, &stock))
	return -1;
    if (stock)
	self->obj = (GObject *)gtk_button_new_from_stock(stock);
    else if (text)
	self->obj = (GObject *)gtk_button_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkButton object");
	return -1;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_button_box_get_child_size noargs
static PyObject *
_wrap_gtk_button_box_get_child_size(PyGObject *self)
{
    gint min_width;
    gint min_height;

    gtk_button_box_get_child_size(GTK_BUTTON_BOX(self->obj), &min_width, &min_height);
    return Py_BuildValue("(ii)", min_width, min_height);
}
%%
override gtk_button_box_get_child_ipadding noargs
static PyObject *
_wrap_gtk_button_box_get_child_ipadding(PyGObject *self)
{
    gint ipad_x;
    gint ipad_y;

    gtk_button_box_get_child_ipadding(GTK_BUTTON_BOX(self->obj), &ipad_x, &ipad_y);
    return Py_BuildValue("(ii)", ipad_x, ipad_y);
}
%%
ignore gtk_toggle_button_new_with_label gtk_toggle_button_new_with_mnemonic
%%
override gtk_toggle_button_new kwargs
static int
_wrap_gtk_toggle_button_new(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|z:GtkToggleButton.__init__", kwlist,
				     &text))
	return -1;
    if (text)
	self->obj = (GObject *)gtk_toggle_button_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_toggle_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkToggleButton object");
	return -1;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
ignore gtk_check_button_new_with_label gtk_check_button_new_with_mnemonic
%%
override gtk_check_button_new kwargs
static int
_wrap_gtk_check_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|z:GtkCheckButton.__init__",
				     kwlist, &text))
	return -1;
    if (text)
	self->obj = (GObject *)gtk_check_button_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_check_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkCheckButton object");
	return -1;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
ignore-glob gtk_radio_button_new_*
%%
override gtk_radio_button_new kwargs
static int
_wrap_gtk_radio_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "group", "label", NULL };
    PyObject *py_group = Py_None;
    gchar *label = NULL;
    GtkRadioButton *group;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,"|Oz:GtkRadioButton.__init__",
				     kwlist, &py_group, &label))
	return -1;
    if (py_group == Py_None)
	group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioButton_Type))
	group = GTK_RADIO_BUTTON(pygobject_get(py_group));
    else {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a GtkRadioButton or None");
	return -1;
    }
    /* various configs for create radio buttons ... */
    if (label == NULL) {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_button_new(NULL);
	else
	    self->obj = (GObject *)gtk_radio_button_new_from_widget(group);
    } else {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_button_new_with_mnemonic(NULL,label);
	else
	    self->obj = (GObject *)gtk_radio_button_new_with_mnemonic_from_widget
		(group, label);
    }
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioButton object");
	return -1;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_radio_button_get_group noargs
static PyObject *
_wrap_gtk_radio_button_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;
    
    list = gtk_radio_button_get_group(GTK_RADIO_BUTTON(self->obj));
    
    if ((py_list = PyList_New(0)) == NULL) {
	return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
	gtk_obj = pygobject_new(G_OBJECT(tmp->data));
	if (gtk_obj == NULL) {
	    Py_DECREF(py_list);
	    return NULL;
	}
	PyList_Append(py_list, gtk_obj);
	Py_DECREF(gtk_obj);
    }
    return py_list;
}
%%
ignore gtk_list_item_new_with_label
%%
override gtk_list_item_new kwargs
static int
_wrap_gtk_list_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkListItem.__init__",
				     kwlist, &text))
	return -1;
    if (text)
	self->obj = (GObject *)gtk_list_item_new_with_label(text);
    else
	self->obj = (GObject *)gtk_list_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkListItem object");
	return -1;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
ignore gtk_menu_item_new_with_label gtk_menu_item_new_with_mnemonic
%%
override gtk_menu_item_new kwargs
static int
_wrap_gtk_menu_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkMenuItem.__init__",
				     kwlist, &text))
	return -1;
    if (text)
	self->obj = (GObject *)gtk_menu_item_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_menu_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkMenuItem object");
	return -1;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
ignore gtk_check_menu_item_new_with_label gtk_check_menu_item_new_with_mnemonic
%%
override gtk_check_menu_item_new kwargs
static int
_wrap_gtk_check_menu_item_new(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|z:GtkCheckMenuItem.__init__", kwlist,
				     &text))
	return -1;
    if (text)
	self->obj = (GObject *)gtk_check_menu_item_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_check_menu_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkCheckMenuItem object");
	return -1;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
ignore gtk_radio_menu_item_new_with_label gtk_radio_menu_item_new_with_mnemonic
%%
override gtk_radio_menu_item_new kwargs
static int
_wrap_gtk_radio_menu_item_new(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "group", "label", NULL };
    gchar *text = NULL;
    PyObject *py_group = Py_None;
    GtkRadioMenuItem *group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|Oz:GtkRadioMenuItem.__init__", kwlist,
				     &py_group, &text))
	return -1;
    if (py_group == Py_None)
	group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioMenuItem_Type))
	group = GTK_RADIO_MENU_ITEM(pygobject_get(py_group));
    else {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a GtkRadioMenuItem or None");
	return -1;
    }
    /* various configs for create radio buttons ... */
    if (text == NULL) {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_menu_item_new(NULL);
	else
	    self->obj = (GObject *)gtk_radio_menu_item_new(group->group);
    } else {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_menu_item_new_with_mnemonic(NULL,
									 text);
	else
	    self->obj = (GObject *)gtk_radio_menu_item_new_with_mnemonic
		(group->group, text);
    }
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioMenuItem object");
	return -1;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
ignore gtk_ctree_construct
  gtk_ctree_insert_gnode
  gtk_ctree_export_to_gnode
  gtk_ctree_post_recursive
  gtk_ctree_post_recursive_to_depth
  gtk_ctree_pre_recursive
  gtk_ctree_pre_recursive_to_depth
  gtk_ctree_find_node_ptr
%%
ignore gtk_ctree_new
%%
override-attr GtkCTree.selection
static PyObject *
_wrap_gtk_ctree__get_selection(PyGObject *self, void *closure)
{
    GList *selection;
    GtkCTreeNode *node;
    PyObject *ret, *py_node;
    if ((ret = PyList_New(0)) == NULL)
	return NULL;

    for (selection = GTK_CLIST(self->obj)->selection; selection != NULL;
	 selection = selection->next) {
	node = selection->data;
	if ((py_node = pyg_pointer_new(GTK_TYPE_CTREE_NODE, node)) == NULL) {
	    Py_DECREF(ret);
	    return NULL;
	}
	PyList_Append(ret, py_node);
	Py_DECREF(py_node);
    }
    return ret;
}
%%
override gtk_ctree_new_with_titles kwargs
static int
_wrap_gtk_ctree_new_with_titles(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "columns", "tree_column", "titles", NULL };
    int columns = 1, tree_column = 0;
    PyObject *py_titles = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iiO:GtkCTree.__init__",
				     kwlist, &columns, &tree_column,
				     &py_titles))
	return -1;
    if (py_titles) {
	gchar **titles;
	gint i;

	if (!PySequence_Check(py_titles)) {
	    PyErr_SetString(PyExc_TypeError, "titles must be a sequence");
	    return -1;
	}
	if (PySequence_Length(py_titles) < columns) {
	    PyErr_SetString(PyExc_TypeError, "titles too short");
	    return -1;
	}
	titles = g_new(gchar *, columns);
	for (i = 0; i < columns; i++) {
	    PyObject *item = PySequence_GetItem(py_titles, i);

	    Py_DECREF(item);
	    if (!PyString_Check(item) && !PyUnicode_Check(item)) {
		PyErr_SetString(PyExc_TypeError,
				"sequence item not a string or unicode object");
		g_free(titles);
		return -1;
	    }
	    titles[i] = PyString_AsString(item);
	}
	self->obj = (GObject *)gtk_ctree_new_with_titles(columns,
						tree_column, titles);
	g_free(titles);
    } else
	self->obj = (GObject *)gtk_ctree_new(columns, tree_column);
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError,"could not create GtkCTree object");
	return -1;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_ctree_base_nodes
static PyObject*
_wrap_gtk_ctree_base_nodes(PyGObject *self, PyObject *args)
{
    PyObject *ret;
    GtkCTreeNode *node;
    
    /* the first row is always a base node */
    node = GTK_CTREE_NODE(GTK_CLIST(self->obj)->row_list);
    if ((ret = PyList_New(0)) == NULL)
	return NULL;
    while (node) {
	PyObject *obj = pyg_pointer_new(GTK_TYPE_CTREE_NODE, node);
	if (obj == NULL) {
	    Py_DECREF(ret);
	    return NULL;
	}
	PyList_Append(ret, obj);
	Py_DECREF(obj);
	node = GTK_CTREE_ROW(node)->sibling;
    }
    return ret;
}
%%
override gtk_ctree_insert_node kwargs
static PyObject *
_wrap_gtk_ctree_insert_node(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", "text", "spacing",
			      "pixmap_closed", "mask_closed", "pixmap_opened",
			      "mask_opened", "is_leaf", "expanded", NULL };
    PyObject *py_text;
    PyGPointer *py_parent, *py_sibling;
    PyGObject *py_pixmap_closed = (PyGObject *) Py_None;
    PyGObject *py_mask_closed = (PyGObject *) Py_None;
    PyGObject *py_pixmap_opened = (PyGObject *) Py_None;
    PyGObject *py_mask_opened = (PyGObject *) Py_None;
    GtkCTreeNode *parent = NULL, *sibling = NULL, *ret;
    gchar **text = NULL;
    GdkPixmap *pixmap_closed = NULL, *pixmap_opened = NULL;
    GdkBitmap *mask_closed = NULL, *mask_opened = NULL;
    gint spacing = 5, is_leaf = 1, expanded = 0, columns, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOO|iOOOOii:GtkCTree.insert_node",
				     kwlist,
				     &py_parent, &py_sibling, &py_text,
				     &spacing, &py_pixmap_closed,
				     &py_mask_closed, &py_pixmap_opened,
				     &py_mask_opened, &is_leaf, &expanded))
	return NULL;
    if (pyg_pointer_check(py_parent, GTK_TYPE_CTREE_NODE))
	parent = pyg_pointer_get(py_parent, GtkCTreeNode);
    else if ((PyObject *)py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError, "parent must be a CTreeNode or None");
	return NULL;
    }
    if (pyg_pointer_check(py_parent, GTK_TYPE_CTREE_NODE))
	sibling = pyg_pointer_get(py_sibling, GtkCTreeNode);
    else if ((PyObject *)py_sibling != Py_None) {
	PyErr_SetString(PyExc_TypeError,"sibling must be a CTreeNode or None");
	return NULL;
    }
    if (pygobject_check(py_pixmap_closed, &PyGdkPixmap_Type))
	pixmap_closed = GDK_PIXMAP(py_pixmap_closed->obj);
    else if ((PyObject *)py_pixmap_closed != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"pixmap_closed must be a GdkPixmap or None");
	return NULL;
    }
    if (pygobject_check(py_mask_closed, &PyGdkPixmap_Type))
	mask_closed = GDK_PIXMAP(py_mask_closed->obj);
    else if ((PyObject *)py_mask_closed != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"mask_closed must be a GdkBitmap or None");
	return NULL;
    }
    if (pygobject_check(py_pixmap_opened, &PyGdkPixmap_Type))
	pixmap_opened = GDK_PIXMAP(py_pixmap_opened->obj);
    else if ((PyObject *)py_pixmap_opened != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"pixmap_opened must be a GdkPixmap or None");
	return NULL;
    }
    if (pygobject_check(py_mask_opened, &PyGdkPixmap_Type))
	mask_opened = GDK_PIXMAP(py_mask_opened->obj);
    else if ((PyObject *)py_mask_opened != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"mask_opened must be a GdkBitmap or None");
	return NULL;
    }
    if (!PySequence_Check(py_text)) {
	PyErr_SetString(PyExc_TypeError, "text must be a sequence");
	return NULL;
    }
    columns = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_text) < columns) {
	PyErr_SetString(PyExc_TypeError, "text is too short");
	return NULL;
    }
    text = g_new(gchar *, columns);
    for (i = 0; i < columns; i++) {
	PyObject *item = PySequence_GetItem(py_text, i);

	Py_DECREF(item);
	if (!PyString_Check(item) && !PyUnicode_Check(item)) {
	    PyErr_SetString(PyExc_TypeError,
			    "sequence item not a string or unicode object");
	    g_free(text);
	    return NULL;
	}
	text[i] = PyString_AsString(item);
    }
    ret = gtk_ctree_insert_node(GTK_CTREE(self->obj), parent, sibling, text,
				spacing, pixmap_closed, mask_closed,
				pixmap_opened, mask_opened, is_leaf, expanded);
    g_free(text);
    return pyg_pointer_new(GTK_TYPE_CTREE_NODE, ret);
}
%%
ignore gtk_ctree_find_by_row_data_custom gtk_ctree_find_all_by_row_data_custom
%%
override gtk_ctree_find_by_row_data kwargs
static PyObject *
_wrap_gtk_ctree_find_by_row_data(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyObject *data;
    PyGPointer *py_node;
    GtkCTreeNode *node = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "OO:GtkCTree.find_by_row_data", kwlist,
                                    &py_node, &data))
       return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
	node = pyg_pointer_get(py_node, GtkCTreeNode);
    else if ((PyObject *)py_node != Py_None) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode or None");
	return NULL;
    }
    ret = gtk_ctree_find_by_row_data(GTK_CTREE(self->obj), node, data);
    if (ret)
	return pyg_pointer_new(GTK_TYPE_CTREE_NODE, ret);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_ctree_find_all_by_row_data kwargs
static PyObject *
_wrap_gtk_ctree_find_all_by_row_data(PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyGPointer *py_node;
    PyObject *data, *list;
    GtkCTreeNode *node = NULL;
    GList *ret, *tmp;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkCTree.find_all_by_row_data",kwlist,
				     &py_node, &data))
	return NULL;
    if (pyg_pointer_check(py_node, GTK_TYPE_CTREE_NODE))
	node = pyg_pointer_get(py_node, GtkCTreeNode);
    else if ((PyObject *)py_node != Py_None) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode or None");
	return NULL;
    }
    ret = gtk_ctree_find_all_by_row_data(GTK_CTREE(self->obj), node, data);
    if ((list = PyList_New(0)) == NULL)
	return NULL;
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *item = pyg_pointer_new(GTK_TYPE_CTREE_NODE,
					 (GtkCTreeNode *) tmp->data);
	if (item == NULL) {
	    Py_DECREF(list);
	    return NULL;
	}
	PyList_Append(list, item);
	Py_DECREF(item);
    }
    g_list_free(ret);
    return list;
}
%%
override gtk_ctree_node_get_text kwargs
static PyObject *
_wrap_gtk_ctree_node_get_text(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyGPointer *node;
    int column;
    char *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oi:GtkCTree.node_get_text", kwlist,
				     &node, &column))
	return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
	return NULL;
    }
    
    if (!gtk_ctree_node_get_text(GTK_CTREE(self->obj),
				 pyg_pointer_get(node, GtkCTreeNode), column,
				 &text)) {
	PyErr_SetString(PyExc_ValueError, "can't get text value");
	return NULL;
    }
    return PyString_FromString(text);
}
%%
override gtk_ctree_node_get_pixmap kwargs
static PyObject *
_wrap_gtk_ctree_node_get_pixmap(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyObject *node;
    int column;
    GdkPixmap *pixmap = NULL;
    GdkBitmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oi:GtkCTree.node_get_pixmap", kwlist,
				     &node, &column))
	return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
	return NULL;
    }
    
    if (!gtk_ctree_node_get_pixmap(GTK_CTREE(self->obj),
				   pyg_pointer_get(node, GtkCTreeNode), column,
				   &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixmap value");
	return NULL;
    }
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_ctree_node_get_pixtext kwargs
static PyObject *
_wrap_gtk_ctree_node_get_pixtext(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyObject *node;
    int column;
    gchar *text = NULL;
    guint8 spacing;
    GdkPixmap *pixmap = NULL;
    GdkBitmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oi:GtkCTree.node_get_pixtext", kwlist,
				     &node, &column))
	return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
	return NULL;
    }
    
    if (!gtk_ctree_node_get_pixtext(GTK_CTREE(self->obj),
				    pyg_pointer_get(node, GtkCTreeNode), column,
				    &text, &spacing, &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixtext value");
	return NULL;
    }
    return Py_BuildValue("(siNN)", text, (int)spacing,
			 pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_ctree_get_node_info kwargs
static PyObject *
_wrap_gtk_ctree_get_node_info(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *node;
    gchar *text;
    guint8 spacing;
    GdkPixmap *pixmap_closed, *pixmap_opened;
    GdkBitmap *mask_closed, *mask_opened;
    gboolean is_leaf, expanded;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCTree.get_node_info",
				     kwlist, &node))
	return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
	return NULL;
    }
    
    if (!gtk_ctree_get_node_info(GTK_CTREE(self->obj), pyg_pointer_get(node, GtkCTreeNode),
				 &text, &spacing, &pixmap_closed, &mask_closed,
				 &pixmap_opened, &mask_opened,
				 &is_leaf, &expanded)) {
	PyErr_SetString(PyExc_ValueError, "can't get node info");
	return NULL;
    }
    return Py_BuildValue("(siNNNNii)", text, (int)spacing,
			 pygobject_new((GObject *)pixmap_opened),
			 pygobject_new((GObject *)mask_closed),
			 pygobject_new((GObject *)pixmap_opened),
			 pygobject_new((GObject *)mask_opened),
			 (int)is_leaf, (int)expanded);
}
%%
ignore gtk_ctree_node_set_row_data_full
%%
override gtk_ctree_node_set_row_data kwargs
static PyObject *
_wrap_gtk_ctree_node_set_row_data(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyObject *node, *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkCTree.node_set_row_data", kwlist,
				     &node, &data))
	return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
	return NULL;
    }
    
    Py_INCREF(data);
    gtk_ctree_node_set_row_data_full(GTK_CTREE(self->obj),
				     pyg_pointer_get(node, GtkCTreeNode), data,
				     (GDestroyNotify)pyg_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_ctree_node_get_row_data kwargs
static PyObject *
_wrap_gtk_ctree_node_get_row_data(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *node, *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkCTree.node_get_row_data", kwlist,
				     &node))
	return NULL;

    if (!pyg_pointer_check(node, GTK_TYPE_CTREE_NODE)) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode");
	return NULL;
    }
    
    data = gtk_ctree_node_get_row_data(GTK_CTREE(self->obj),
				       pyg_pointer_get(node, GtkCTreeNode));
    if (!data) data = Py_None;
    Py_INCREF(data);
    return data;
}
%%
override gtk_ctree_node_getattr
static PyObject *
_wrap_gtk_ctree_node_getattr(PyGBoxed *self, char *attr)
{
    if (!strcmp(attr, "__members__"))
	return Py_BuildValue("[ssssss]", "children", "expanded", "is_leaf",
			     "level", "parent", "sibling");
    if (!strcmp(attr, "parent")) {
	GtkCTreeNode *node = GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->parent;
	if (node)
	    return pyg_pointer_new(GTK_TYPE_CTREE_NODE, node);
	Py_INCREF(Py_None);
	return Py_None;
    } else if (!strcmp(attr, "sibling")) {
	GtkCTreeNode *node = GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->sibling;
	if (node)
	    return pyg_pointer_new(GTK_TYPE_CTREE_NODE, node);
	Py_INCREF(Py_None);
	return Py_None;
    } else if (!strcmp(attr, "children")) {
	GtkCTreeNode *node = GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->children;
	PyObject *ret = PyList_New(0);
	if (ret == NULL)
	    return NULL;
	while (node) {
	    PyObject *py_node = pyg_pointer_new(GTK_TYPE_CTREE_NODE, node);
	    if (py_node == NULL) {
		Py_DECREF(ret);
		return NULL;
	    }
	    PyList_Append(ret, py_node);
	    Py_DECREF(py_node);
	    node = GTK_CTREE_ROW(node)->sibling;
	}
	return ret;
    } else if (!strcmp(attr, "level"))
	return PyInt_FromLong(GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->level);
    else if (!strcmp(attr, "is_leaf"))
	return PyInt_FromLong(GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->is_leaf);
    else if (!strcmp(attr, "expanded"))
	return PyInt_FromLong(GTK_CTREE_ROW(pyg_pointer_get(self, GtkCTreeNode))->expanded);
    PyErr_SetString(PyExc_AttributeError, attr);
    return NULL;
}
%%
ignore gtk_tree_remove_items
%%
override gtk_toolbar_append_item kwargs
static PyObject *
_wrap_gtk_toolbar_append_item(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
			      "icon", "callback", "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param=NULL;
    GtkWidget *icon = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "zzzOO|O:GtkToolbar.append_item", kwlist,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"forth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_append_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
				  tooltip_private_text, icon, NULL, NULL);
    if (ret && PyCallable_Check(callback)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_prepend_item kwargs
static PyObject *
_wrap_gtk_toolbar_prepend_item(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
			      "icon", "callback", "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param;
    GtkWidget *icon = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "zzzOOO:GtkToolbar.prepend_item", kwlist,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"forth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_prepend_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
				  tooltip_private_text, icon, NULL, NULL);
    if (ret && PyCallable_Check(callback)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_insert_item kwargs
static PyObject *
_wrap_gtk_toolbar_insert_item(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
			      "icon", "callback", "user_data", "position",
			      NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param;
    GtkWidget *icon = NULL, *ret;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "zzzOOOi:GtkToolbar.insert_item", kwlist,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param, &position))
	return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"forth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_insert_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
				  tooltip_private_text, icon, NULL, NULL,
				  position);
    if (ret && PyCallable_Check(callback)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_insert_stock kwargs
static PyObject *
_wrap_gtk_toolbar_insert_stock(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "tooltip_text", "tooltip_private_text",
			      "callback", "user_data", "position",
			      NULL };
    char *stock_id, *tooltip_text, *tooltip_private_text;
    PyObject *callback, *param;
    GtkWidget *ret;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "zzzOOi:GtkToolbar.insert_stock", kwlist,
				     &stock_id, &tooltip_text,
				     &tooltip_private_text,
				     &callback, &param, &position))
	return NULL;

    ret = gtk_toolbar_insert_stock(GTK_TOOLBAR(self->obj), stock_id, tooltip_text,
				  tooltip_private_text, NULL, NULL,
				  position);
    if (ret && PyCallable_Check(callback)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_append_element kwargs
static PyObject *
_wrap_gtk_toolbar_append_element(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
			      "tooltip_private_text", "icon", "callback",
			      "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOzzzOOO:GtkToolbar.append_element",
				     kwlist,
				     &py_type, &py_widget,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
			   py_type, (gint *)&type))
	return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
	widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"second argument must be a GtkWidget or None");
	return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sixth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_append_element(GTK_TOOLBAR(self->obj), type, widget,
				     text, tooltip_text, tooltip_private_text,
				     icon, NULL, NULL);
    if (ret && PyCallable_Check(callback) &&
	(type == GTK_TOOLBAR_CHILD_BUTTON ||
	 type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	 type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_prepend_element kwargs
static PyObject *
_wrap_gtk_toolbar_prepend_element(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
			      "tooltip_private_text", "icon", "callback",
			      "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOzzzOOO:GtkToolbar.prepend_element",
				     kwlist,
				     &py_type, &py_widget,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
			   py_type, (gint *)&type))
	return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
	widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"second argument must be a GtkWidget or None");
	return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sixth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_prepend_element(GTK_TOOLBAR(self->obj), type, widget,
				      text, tooltip_text, tooltip_private_text,
				      icon, NULL, NULL);
    if (ret && PyCallable_Check(callback) &&
	(type == GTK_TOOLBAR_CHILD_BUTTON ||
	 type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	 type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_insert_element kwargs
static PyObject *
_wrap_gtk_toolbar_insert_element(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
			      "tooltip_private_text", "icon", "callback",
			      "user_data", "position", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOzzzOOOi:GtkToolbar.insert_element",
				     kwlist,
				     &py_type, &py_widget,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param, &position))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
			   py_type, (gint *)&type))
	return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
	widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"second argument must be a GtkWidget or None");
	return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sixth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_insert_element(GTK_TOOLBAR(self->obj), type, widget,
				     text, tooltip_text, tooltip_private_text,
				     icon, NULL, NULL, position);
    if (ret && PyCallable_Check(callback) &&
	(type == GTK_TOOLBAR_CHILD_BUTTON ||
	 type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	 type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_notebook_query_tab_label_packing kwargs
static PyObject *
_wrap_gtk_notebook_query_tab_label_packing(PyGObject *self, PyObject *args,
					   PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    gboolean expand, fill;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkNotebook.query_tab_label_packing",
				     kwlist, &child))
	return NULL;
    if (!pygobject_check(child, &PyGtkWidget_Type)) {
	PyErr_SetString(PyExc_TypeError, "child must be a GtkWidget");
	return NULL;
    }
    gtk_notebook_query_tab_label_packing(GTK_NOTEBOOK(self->obj),
					 GTK_WIDGET(child->obj),
					 &expand, &fill, &pack_type);
    return Py_BuildValue("(iii)", expand, fill, pack_type);
}
%%
override gtk_list_insert_items kwargs
static PyObject *
_wrap_gtk_list_insert_items(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "items", "position", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int position, len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!i:GtkList.insert_items",
				     kwlist, &PyList_Type, &py_items,
				     &position))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_insert_items(GTK_LIST(self->obj), items, position);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_append_items kwargs
static PyObject *
_wrap_gtk_list_append_items(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.append_items",
				     kwlist, &PyList_Type, &py_items))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_append_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_prepend_items kwargs
static PyObject *
_wrap_gtk_list_prepend_items(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.preppend_items",
				     kwlist, &PyList_Type, &py_items))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_prepend_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_remove_items kwargs
static PyObject *
_wrap_gtk_list_remove_items(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.remove_items",
				     kwlist, &PyList_Type, &py_items))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_remove_items(GTK_LIST(self->obj), items);
    g_list_free(items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_list_remove_items_no_unref
%%
override-attr GtkList.selection
static PyObject *
_wrap_gtk_list__get_selection(PyGObject *self, void *closure)
{
    GList *selection;
    PyObject *item, *ret = PyList_New(0);

    if (ret == NULL)
	return NULL;

    for (selection = GTK_LIST(self->obj)->selection; selection != NULL;
	 selection = selection->next) {
	item = pygobject_new((GObject *) GTK_LIST_ITEM(selection->data));

	if (!item) {
	    Py_DECREF(ret);
	    return NULL;
	}

	PyList_Append(ret, item);
	Py_DECREF(item);
    }
    return ret;
}
%%
override gtk_list_get_selection noargs
static PyObject *
_wrap_gtk_list__get_selection(PyGObject *self, void *closure);
static PyObject *
_wrap_gtk_list_get_selection(PyGObject *self)
{
    return _wrap_gtk_list__get_selection(self, NULL);
}
%%
override gtk_color_selection_get_current_color noargs
static PyObject *
_wrap_gtk_color_selection_get_current_color(PyGObject *self)
{
    GdkColor colour = { 0, };

    gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(self->obj),
					  &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gtk_color_selection_get_previous_color noargs
static PyObject *
_wrap_gtk_color_selection_get_previous_color(PyGObject *self)
{
    GdkColor colour = { 0, };

    gtk_color_selection_get_previous_color(GTK_COLOR_SELECTION(self->obj),
					   &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gtk_calendar_get_date noargs
static PyObject *
_wrap_gtk_calendar_get_date(PyGObject *self)
{
    guint year, month, day;

    gtk_calendar_get_date(GTK_CALENDAR(self->obj), &year, &month, &day);
    return Py_BuildValue("(iii)", year, month, day);
}
%%
override gtk_drag_dest_set kwargs
static PyObject *
_wrap_gtk_drag_dest_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "flags", "targets", "actions", NULL };
    PyObject *py_flags, *py_targets, *py_actions;
    GtkDestDefaults flags;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOO:GtkWidget.drag_dest_set", kwlist,
				     &py_flags, &py_targets, &py_actions))
	return NULL;
    if (pyg_flags_get_value(GTK_TYPE_DEST_DEFAULTS, py_flags, (gint *)&flags))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
			     py_actions, (gint *)&actions))
	return NULL;
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
			      &targets[i].flags, &targets[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(targets);
	    return NULL;
	}
    }
    gtk_drag_dest_set(GTK_WIDGET(self->obj), flags, targets, n_targets,
		      actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_source_set kwargs
static PyObject *
_wrap_gtk_drag_source_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start_button_mask", "targets", "actions", NULL };
    PyObject *py_sbmask, *py_targets, *py_actions;
    GdkModifierType sbmask;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOO:GtkWidget.drag_source_set", kwlist,
				     &py_sbmask, &py_targets, &py_actions))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,
			     py_sbmask, (gint *)&sbmask))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
			     py_actions, (gint *)&actions))
	return NULL;
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
			      &targets[i].flags, &targets[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(targets);
	    return NULL;
	}
    }
    gtk_drag_source_set(GTK_WIDGET(self->obj), sbmask, targets, n_targets,
			actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_begin kwargs
static PyObject *
_wrap_gtk_drag_begin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "actions", "button", "event", NULL };
    PyObject *py_targets, *py_actions, *event;
    GtkTargetEntry *tents;
    GtkTargetList *targets;
    GdkDragAction actions;
    gint button, n_targets, i;
    GdkDragContext *context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOiO:GtkWidget.drag_begin", kwlist,
				     &py_targets, &py_actions, &button,
				     &event))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
			     py_actions, (gint *)&actions))
	return NULL;
    if (!pyg_boxed_check(event, GDK_TYPE_EVENT)) {
	PyErr_SetString(PyExc_TypeError, "event must be a GdkEvent");
	return NULL;
    }
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    tents = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &tents[i].target,
			      &tents[i].flags, &tents[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(tents);
	    return NULL;
	}
    }
    targets = gtk_target_list_new(tents, n_targets);
    g_free(tents);
    context = gtk_drag_begin(GTK_WIDGET(self->obj), targets, actions, button,
			     pyg_boxed_get(event, GdkEvent));
    gtk_target_list_unref(targets);
    return pygobject_new((GObject *)context);
}
%%
ignore
  gtk_drag_source_handle_event gtk_drag_dest_handle_event
  gtk_selection_request gtk_selection_notify gtk_selection_property_notify
  gtk_selection_incr_event
%%
override gtk_selection_add_targets kwargs
static PyObject *
_wrap_gtk_selection_add_targets(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "selection", "targets", NULL };
    PyObject *py_targets, *py_selection;
    GtkTargetEntry *targets;
    GdkAtom selection;
    int n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkWidget.selection_add_targets",
				     kwlist, &py_selection, &py_targets))
	return NULL;
    selection = pygdk_atom_from_pyobject(py_selection);
    if (PyErr_Occurred())
	return NULL;
    
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
			      &targets[i].flags, &targets[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "sequence items should be of form (string,int,int)");
	    g_free(targets);
	    return NULL;
	}
    }
    gtk_selection_add_targets(GTK_WIDGET(self->obj), selection,
			      targets, n_targets);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_text_iter_free
%%
override gtk_text_iter_copy noargs
static PyObject *
_wrap_gtk_text_iter_copy(PyGBoxed *self)
{
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, pyg_boxed_get(self, GtkTextIter),
			 TRUE, TRUE);
}
%%
override gtk_text_iter_get_char noargs
static PyObject *
_wrap_gtk_text_iter_get_char(PyGBoxed *self)
{
    gunichar chr;
    Py_UNICODE pychr;

    chr = gtk_text_iter_get_char(pyg_boxed_get(self, GtkTextIter));
    if (chr > 0xffff) {
	PyErr_SetString(PyExc_RuntimeError, "python's broken unicode handling only supports 16 bit unicode, and you just hit this limit");
	return NULL;
    }
    pychr = (Py_UNICODE)chr;
    return PyUnicode_FromUnicode(&pychr, 1);

}
%%
override gtk_text_iter_get_slice kwargs
static PyObject *
_wrap_gtk_text_iter_get_slice(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextIter.get_slice",
				     kwlist, &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_slice(pyg_boxed_get(self, GtkTextIter),
				   pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_text kwargs
static PyObject *
_wrap_gtk_text_iter_get_text(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextIter.get_text",
				     kwlist, &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_text(pyg_boxed_get(self, GtkTextIter),
				   pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_visible_slice kwargs
static PyObject *
_wrap_gtk_text_iter_get_visible_slice(PyGBoxed *self, PyObject *args,
				      PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkTextIter.get_visible_slice", kwlist,
				     &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_visible_slice(pyg_boxed_get(self, GtkTextIter),
					   pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_visible_text kwargs
static PyObject *
_wrap_gtk_text_iter_get_visible_text(PyGBoxed *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkTextIter.get_visible_text", kwlist,
				     &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_visible_text(pyg_boxed_get(self, GtkTextIter),
					  pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_marks noargs
static PyObject *
_wrap_gtk_text_iter_get_marks(PyGBoxed *self)
{
    GSList *ret, *tmp;
    PyObject *pyret;

    ret = gtk_text_iter_get_marks(pyg_boxed_get(self, GtkTextIter));
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *mark = pygobject_new((GObject *)tmp->data);
	PyList_Append(pyret, mark);
	Py_DECREF(mark);
    }
    g_slist_free(ret);
    return pyret;
}
%%
override gtk_text_iter_get_toggled_tags kwargs
static PyObject *
_wrap_gtk_text_iter_get_toggled_tags(PyGBoxed *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "toggled_on", NULL };
    GSList *ret, *tmp;
    int toggled_on;
    PyObject *pyret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "i:GtkTextIter.get_toggled_tags", kwlist,
				     &toggled_on))
	return NULL;
    ret = gtk_text_iter_get_toggled_tags(pyg_boxed_get(self, GtkTextIter),
					 toggled_on);
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *tag = pygobject_new((GObject *)tmp->data);
	PyList_Append(pyret, tag);
	Py_DECREF(tag);
    }
    g_slist_free(ret);
    return pyret;
}
%%
override gtk_text_iter_get_tags noargs
static PyObject *
_wrap_gtk_text_iter_get_tags(PyGBoxed *self)
{
    GSList *ret, *tmp;
    PyObject *pyret;

    ret = gtk_text_iter_get_tags(pyg_boxed_get(self, GtkTextIter));
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *tag = pygobject_new((GObject *)tmp->data);
	PyList_Append(pyret, tag);
	Py_DECREF(tag);
    }
    g_slist_free(ret);
    return pyret;
}
%%
override gtk_text_iter_forward_search kwargs
static PyObject *
_wrap_gtk_text_iter_forward_search(PyGBoxed *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "str", "flags", "limit", NULL };
    gchar *str;
    PyObject *py_limit = Py_None;
    GtkTextIter match_start, match_end, *limit = NULL;
    GtkTextSearchFlags flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "si|O:GtkTextIter.forward_search",
				     kwlist, &str, &flags, &py_limit))
	return NULL;
    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
	limit = pyg_boxed_get(py_limit, GtkTextIter);
    else if (py_limit != Py_None) {
	PyErr_SetString(PyExc_TypeError,"limit must be a GtkTextIter or None");
	return NULL;
    }
    if (gtk_text_iter_forward_search(pyg_boxed_get(self, GtkTextIter), str,
				     flags, &match_start, &match_end, limit))
	return Py_BuildValue("(NN)",
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_start,
					   TRUE, TRUE),
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_end,
					   TRUE, TRUE));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_text_iter_backward_search kwargs
static PyObject *
_wrap_gtk_text_iter_backward_search(PyGBoxed *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "str", "flags", "limit", NULL };
    gchar *str;
    PyObject *py_limit = Py_None;
    GtkTextIter match_start, match_end, *limit = NULL;
    GtkTextSearchFlags flags;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "si|O:GtkTextIter.backward_search",
				     kwlist, &str, &flags, &py_limit))
	return NULL;
    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
	limit = pyg_boxed_get(py_limit, GtkTextIter);
    else if (py_limit != Py_None) {
	PyErr_SetString(PyExc_TypeError,"limit must be a GtkTextIter or None");
	return NULL;
    }
    if (gtk_text_iter_backward_search(pyg_boxed_get(self, GtkTextIter), str,
				      flags, &match_start, &match_end, limit))
	return Py_BuildValue("(NN)",
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_start,
					   TRUE, TRUE),
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_end,
					   TRUE, TRUE));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_text_buffer_create_tag kwargs
static PyObject *
_wrap_gtk_text_buffer_create_tag(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tag_name", NULL };
    gchar *tag_name;
    GtkTextTag *tag;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:GtkTextBuffer.create_tag", kwlist,
				     &tag_name))
	return NULL;
    tag = gtk_text_buffer_create_tag(GTK_TEXT_BUFFER(self->obj),
				     tag_name, NULL);
    return pygobject_new((GObject *)tag);
}
%%
override gtk_text_buffer_get_iter_at_line_offset kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line_offset(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "line_number", "char_offset", NULL };
    GtkTextIter iter;
    int line_number, char_offset;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkTextBuffer.get_iter_at_line_offset", kwlist, &line_number, &char_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_line_offset(GTK_TEXT_BUFFER(self->obj), &iter,
					    line_number, char_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_iter_at_line_index kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line_index(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "line_number", "byte_offset", NULL };
    GtkTextIter iter;
    int line_number, byte_offset;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkTextBuffer.get_iter_at_line_index", kwlist, &line_number, &byte_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_line_index(GTK_TEXT_BUFFER(self->obj), &iter,
					   line_number, byte_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_iter_at_offset kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_offset(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    int char_offset;
    static char *kwlist[] = { "char_offset", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkTextBuffer.get_iter_at_offset", kwlist, &char_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj),
				       &iter, char_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_iter_at_line kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    int line_number;
    static char *kwlist[] = { "line_number", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkTextBuffer.get_iter_at_line", kwlist, &line_number))
        return NULL;

    gtk_text_buffer_get_iter_at_line(GTK_TEXT_BUFFER(self->obj),
				     &iter, line_number);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_start_iter noargs
static PyObject *
_wrap_gtk_text_buffer_get_start_iter(PyGObject *self)
{
    GtkTextIter iter;

    gtk_text_buffer_get_start_iter(GTK_TEXT_BUFFER(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_end_iter noargs
static PyObject *
_wrap_gtk_text_buffer_get_end_iter(PyGObject *self)
{
    GtkTextIter iter;

    gtk_text_buffer_get_end_iter(GTK_TEXT_BUFFER(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_bounds noargs
static PyObject *
_wrap_gtk_text_buffer_get_bounds(PyGObject *self)
{
    GtkTextIter start, end;

    gtk_text_buffer_get_bounds(GTK_TEXT_BUFFER(self->obj), &start, &end);
    return Py_BuildValue("(NN)",
			 pyg_boxed_new(GTK_TYPE_TEXT_ITER, &start, TRUE, TRUE),
			 pyg_boxed_new(GTK_TYPE_TEXT_ITER, &end, TRUE, TRUE));
}
%%
override gtk_text_buffer_get_iter_at_mark kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_mark(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyGObject *mark;
    static char *kwlist[] = { "mark", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextBuffer.get_iter_at_mark", kwlist, &mark))
        return NULL;
    if (!pygobject_check(mark, &PyGtkTextMark_Type)) {
        PyErr_SetString(PyExc_TypeError, "mark should be a GtkTextMark");
        return NULL;
    }

    gtk_text_buffer_get_iter_at_mark(GTK_TEXT_BUFFER(self->obj), &iter,
				     GTK_TEXT_MARK(mark->obj));
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_set_text kwargs
static PyObject *
_wrap_gtk_text_buffer_set_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    char *text;
    static char *kwlist[] = { "text", "len", NULL };
    int len;

    /* tricky, allows user to override calculated text length. */
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s#|i:GtkTextBuffer.set_text", kwlist,
				     &text, &len, &len))
        return NULL;

    gtk_text_buffer_set_text(GTK_TEXT_BUFFER(self->obj), text, len);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_dialog_new
%%
override gtk_dialog_new_with_buttons kwargs
static int
_wrap_gtk_dialog_new_with_buttons(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    gchar *title = NULL;
    PyGObject *py_window = NULL;
    PyObject *py_buttons = Py_None;
    GtkDialogFlags flags = 0;
    int len, i;
    
    static char *kwlist[] = { "title", "parent", "flags", "buttons", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|sOiO!:GtkDialog.__init__", kwlist,
				     &title, &py_window, &flags,
				     &PyTuple_Type, &py_buttons))
        return -1;

    if (py_window != NULL && py_window != (PyGObject *) Py_None
	&& !pygobject_check(py_window, &PyGtkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "window must be a GtkWindow or None");
	return -1;
    }

    if (py_buttons != Py_None)
	len = PyTuple_Size(py_buttons);
    else
	len = 0;
    
    if (len % 2) {
	PyErr_SetString(PyExc_RuntimeError,
			"buttons tuple must contain text/response id pairs");
	return -1;
    }

    self->obj = (GObject *)
	gtk_dialog_new_with_buttons(title,
				    (py_window && py_window != (PyGObject *) Py_None) ? GTK_WINDOW(py_window->obj) : NULL,
				    flags, NULL);
    
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkDialog object");
        return -1;
    }

    for (i = 0; i < len; i += 2) {
	PyObject *text = PyTuple_GetItem(py_buttons, i);
	PyObject *id = PyTuple_GetItem(py_buttons, i + 1);
	if (!PyString_Check(text)) {
	    gtk_object_destroy(GTK_OBJECT(self->obj));
	    self->obj = NULL;
	    PyErr_SetString(PyExc_RuntimeError,
			    "first member of each text/response id pair "
			    "must be a string");
	    return -1;
	}
	if (!PyInt_Check(id)) {
	    gtk_object_destroy(GTK_OBJECT(self->obj));
	    self->obj = NULL;
	    PyErr_SetString(PyExc_RuntimeError,
			    "second member of each text/response id pair "
			    "must be a number");
	    return -1;
	}
	gtk_dialog_add_button(GTK_DIALOG(self->obj), PyString_AsString(text),
			      PyInt_AsLong(id));
    }
	
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_dialog_run noargs
static PyObject *
_wrap_gtk_dialog_run(PyGObject *self)
{
    gint retval;

    pyg_unblock_threads();
    retval = gtk_dialog_run(GTK_DIALOG(self->obj));
    pyg_block_threads();

    return PyInt_FromLong(retval);
}
%%
override gtk_message_dialog_new kwargs
static int
_wrap_gtk_message_dialog_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GtkButtonsType buttons = GTK_BUTTONS_NONE;
    static char *kwlist[] = { "parent", "flags", "type", "buttons", "message_format", NULL };
    PyObject *py_flags = NULL, *py_type = NULL, *py_buttons = NULL;
    GtkDialogFlags flags = 0;
    GtkWindow *parent = NULL;
    GtkMessageType type = GTK_MESSAGE_INFO;
    PyGObject *py_parent = NULL;
    char *message_format = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OOOOz:GtkMessageDialog.__init__", kwlist, &py_parent, &py_flags, &py_type, &py_buttons, &message_format))
        return -1;
    if ((PyObject *)py_parent == Py_None)
        parent = NULL;
    else if (py_parent && pygobject_check(py_parent, &PyGtkWindow_Type))
        parent = GTK_WINDOW(py_parent->obj);
    else if (py_parent) {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkWindow or None");
        return -1;
    }
    if (pyg_enum_get_value(GTK_TYPE_DIALOG_FLAGS, py_flags, (gint *)&flags))
        return -1;
    if (pyg_enum_get_value(GTK_TYPE_MESSAGE_TYPE, py_type, (gint *)&type))
        return -1;
    if (pyg_enum_get_value(GTK_TYPE_BUTTONS_TYPE, py_buttons, (gint *)&buttons))
        return -1;

    self->obj = (GObject *)gtk_message_dialog_new(parent, flags, type, buttons, "%s", message_format);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkMessageDialog object");
        return -1;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
ignore gtk_progress_bar_new
%%
override gtk_progress_bar_new_with_adjustment kwargs
static PyObject *
_wrap_gtk_progress_bar_new_with_adjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GtkAdjustment *adjustment = NULL;
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *py_adjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkProgressBar.__init__", kwlist, &py_adjustment))
        return NULL;
    if ((PyObject *)py_adjustment == Py_None)
        adjustment = NULL;
    else if (py_adjustment && pygobject_check(py_adjustment, &PyGtkAdjustment_Type))
        adjustment = GTK_ADJUSTMENT(py_adjustment->obj);
    else if (py_adjustment) {
        PyErr_SetString(PyExc_TypeError, "adjustment should be a GtkAdjustment or None");
        return NULL;
    }

    if (adjustment)
	self->obj = (GObject *)gtk_progress_bar_new_with_adjustment(adjustment);
    else
	self->obj = (GObject *)gtk_progress_bar_new();

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkProgressBar object");
        return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_rc_set_default_files kwargs
static PyObject *
_wrap_gtk_rc_set_default_files(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    gchar **filenames = NULL;
    static char *kwlist[] = { "filenames", NULL };
    PyObject *py_filenames = NULL;
    int i, n_files;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:rc_set_default_files",
				     kwlist, &py_filenames))
        return NULL;

    if (!PySequence_Check(py_filenames)) {
	PyErr_SetString(PyExc_TypeError, "filenames must be a sequence");
	return NULL;
    }

    n_files = PySequence_Length(py_filenames);
    filenames = g_new(gchar *, n_files + 1);
    for (i = 0; i < n_files; i++) {
	PyObject *item = PySequence_GetItem(py_filenames, i);
	Py_DECREF(item); /* PySequence_GetItem INCREF's */
	filenames[i] = PyString_AsString(item);
    }
    filenames[n_files] = NULL;

    gtk_rc_set_default_files(filenames);

    g_free(filenames);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_rc_get_default_files noargs
static PyObject *
_wrap_gtk_rc_get_default_files(PyGObject *self)
{
    gchar **filenames = NULL, **tmp;
    int i = 0, j;
    PyObject *ret;

    filenames = gtk_rc_get_default_files();

    tmp = filenames;
    while (*tmp)
	tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
	PyTuple_SetItem(ret, j, PyString_FromString(filenames[j]));
    
    return ret;
}
%%
override gtk_icon_set_new_from_pixbuf kwargs
static int
_wrap_gtk_icon_set_new_from_pixbuf(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *pixbuf = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkIconSet.__init__", kwlist, &pixbuf))
        return -1;
    if (pixbuf && !pygobject_check(pixbuf, &PyGdkPixbuf_Type)) {
        PyErr_SetString(PyExc_TypeError, "pixbuf should be a GdkPixbuf");
        return -1;
    }
    self->gtype = GTK_TYPE_ICON_SET;
    self->free_on_dealloc = FALSE;
    if (pixbuf)
	self->boxed = gtk_icon_set_new_from_pixbuf(GDK_PIXBUF(pixbuf->obj));
    else
	self->boxed = gtk_icon_set_new();

    if (!self->boxed) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkIconSet object");
        return -1;
    }
    self->free_on_dealloc = TRUE;
    return 0;
}
%%
override gtk_icon_set_get_sizes noargs
static PyObject *
_wrap_gtk_icon_set_get_sizes(PyGObject *self)
{
    GtkIconSize *sizes;
    int i, n_sizes;
    PyObject *ret;

    gtk_icon_set_get_sizes(pyg_boxed_get(self, GtkIconSet), &sizes, &n_sizes);

    ret = PyTuple_New(n_sizes);
    for (i = 0; i < n_sizes; i++)
	PyTuple_SetItem(ret, i, PyInt_FromLong(sizes[i]));
    g_free(sizes);
    
    return ret;
}
%%
override gtk_cell_renderer_get_size kwargs
static PyObject *
_wrap_gtk_cell_renderer_get_size(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    gint x_offset, y_offset, width, height;
    GdkRectangle cell_area;
    PyObject *py_widget;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkCellRenderer.get_size", kwlist,
				     &py_widget))
        return NULL;

    if (!pygobject_check(py_widget, &PyGtkWidget_Type)) {
	PyErr_SetString(PyExc_TypeError, "widget must be a GtkWidget");
	return NULL;
    }

    gtk_cell_renderer_get_size(GTK_CELL_RENDERER(self->obj),
			       GTK_WIDGET(pygobject_get(py_widget)),
			       &cell_area, &x_offset, &y_offset, &width,
			       &height);

    return Py_BuildValue("(Niiii)", pyg_boxed_new(GDK_TYPE_RECTANGLE,
						  &cell_area, TRUE, TRUE),
			 x_offset, y_offset, width, height);
}
%%
override gtk_cell_renderer_get_fixed_size noargs
static PyObject *
_wrap_gtk_cell_renderer_get_fixed_size(PyGObject *self)
{
    gint width, height;

    gtk_cell_renderer_get_fixed_size(GTK_CELL_RENDERER(self->obj),
				     &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
%%
override gtk_stock_add kwargs
static PyObject *
_wrap_gtk_stock_add(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    PyObject *py_item;
    GtkStockItem *items = NULL;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:stock_add", kwlist,
				     &py_items))
        return NULL;

    if (!PySequence_Check(py_items)) {
	PyErr_SetString(PyExc_TypeError,
			"items must be a sequence of five-element tuples");
	return NULL;
    }

    len = PySequence_Length(py_items);
    items = g_new(GtkStockItem, len);
    if (items) {
	for (i = 0; i < len; i++) {
	    py_item = PySequence_GetItem(py_items, i);
	    if (!py_item) goto error;
	    if (!PyArg_ParseTuple(py_item, "zziiz",
				  &items[i].stock_id, &items[i].label,
				  &items[i].modifier, &items[i].keyval,
				  &items[i].translation_domain)) {
		PyErr_Clear();
		PyErr_SetString(PyExc_TypeError, "items sequence members "
				"must be of form (stock_id, label, modifiers, "
				"keyval, domain)");
		goto error;
	    }
	}
	gtk_stock_add(items, PySequence_Length(py_items));
	g_free(items);
	Py_INCREF(Py_None);
	return Py_None;
    }
 error:
    g_free(items);
    return NULL;
}
%%
override gtk_layout_get_size noargs
static PyObject *
_wrap_gtk_layout_get_size(PyGObject *self)
{
    guint width, height;
    gtk_layout_get_size(GTK_LAYOUT(self->obj), &width, &height);
    
    return Py_BuildValue("(ii)", width, height);
}
%%
override gtk_frame_get_label_align noargs
static PyObject *
_wrap_gtk_frame_get_label_align(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_frame_get_label_align(GTK_FRAME(self->obj), &xalign, &yalign);
    return Py_BuildValue("(ff)", xalign, yalign);
}
%%
override gtk_misc_get_alignment noargs
static PyObject *
_wrap_gtk_misc_get_alignment(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_misc_get_alignment(GTK_MISC(self->obj), &xalign, &yalign);
    return 
Py_BuildValue("(ff)", xalign, yalign);
}
%%
override gtk_ruler_get_range noargs
static PyObject *
_wrap_gtk_ruler_get_range(PyGObject *self)
{
    gdouble lower, upper, position, max_size;

    gtk_ruler_get_range(GTK_RULER(self->obj), &lower, &upper, &position,
			&max_size);
    return Py_BuildValue("(dddd)", lower, upper, position, max_size);
}
