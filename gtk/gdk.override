/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include <gtk/gtk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include "pygtk-private.h"

/* small fix */
#undef gdk_window_get_type
#define gdk_window_get_type gdk_window_object_get_type

/* gross hack until gdk-pixbuf types get set up as normal enums/flags */
#define GDK_TYPE_COLORSPACE G_TYPE_INVALID
#define GDK_TYPE_INTERP_TYPE G_TYPE_INVALID
#define GDK_TYPE_PIXBUF_ALPHA_MODE G_TYPE_INVALID

static PyExtensionClass *_PyGObject_Type;
#define PyGObject_Type (*_PyGObject_Type)

static PyExtensionClass *_PyPangoContext_Type;
#define PyPangoContext_Type (*_PyPangoContext_Type)
static PyExtensionClass *_PyPangoFont_Type;
#define PyPangoFont_Type (*_PyPangoFont_Type)
static PyExtensionClass *_PyPangoLayout_Type;
#define PyPangoLayout_Type (*_PyPangoLayout_Type)

%%
init
{
    PyObject *pygobject = PyImport_ImportModule("gobject");
    PyObject *pypango;

    if (pygobject != NULL) {
	PyObject *module_dict = PyModule_GetDict(pygobject);

	_PyGObject_Type = (PyExtensionClass *)PyDict_GetItemString(module_dict,
								   "GObject");
    } else {
	Py_FatalError("could not import gobject");
	return;
    }
    pypango = PyImport_ImportModule("pango");
    if (pypango != NULL) {
	PyObject *module_dict = PyModule_GetDict(pypango);

	_PyPangoContext_Type =
	    (PyExtensionClass *)PyDict_GetItemString(module_dict,
						     "Context");
	_PyPangoFont_Type =
	    (PyExtensionClass *)PyDict_GetItemString(module_dict,
						     "Font");
	_PyPangoLayout_Type =
	    (PyExtensionClass *)PyDict_GetItemString(module_dict,
						     "Layout");
    } else {
	Py_FatalError("could not import pango");
	return;
    }
}
%%
ignore-glob
  *_get_type
%%
override gdk_draw_polygon kwargs
static PyObject *
_wrap_gdk_draw_polygon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "filled", "points", NULL };
    PyGObject *gc;
    PyObject *py_points;
    gint filled, npoints, i;
    GdkPoint *points;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OiO:GdkDrawable.draw_polygon",
				     kwlist, &gc, &filled, &py_points))
	return NULL;
    if (!pygobject_check(gc, &PyGdkGC_Type)) {
	PyErr_SetString(PyExc_TypeError, "gc must be a GdkGC");
	return NULL;
    }
    if (!PySequence_Check(py_points)) {
	PyErr_SetString(PyExc_TypeError, "points must be a sequence");
	return NULL;
    }
    npoints = PySequence_Length(py_points);
    points = g_new(GdkPoint, npoints);
    for (i = 0; i < npoints; i++) {
	PyObject *item = PySequence_GetItem(py_points, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "hh", &points[i].x, &points[i].y)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "sequence members must be 2-tuples");
	    g_free(points);
	    return NULL;
	}
    }
    gdk_draw_polygon(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj), filled,
		     points, npoints);
    g_free(points);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_text kwargs
static PyObject *
_wrap_gdk_draw_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "font", "gc", "x", "y", "text",NULL};
    PyGObject *gc;
    PyObject *font;
    int x, y, len;
    char *text;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOiis#:GdkDrawable.draw_text",
				     kwlist,  &font,
				     &gc, &x, &y, &text, &len))
	return NULL;
    if (!pyg_boxed_check(font, GDK_TYPE_FONT)) {
	PyErr_SetString(PyExc_TypeError, "font must be a GdkFont");
	return NULL;
    }
    if (!pygobject_check(gc, &PyGdkGC_Type)) {
	PyErr_SetString(PyExc_TypeError, "gc must be a GdkGC");
	return NULL;
    }
    gdk_draw_text(GDK_DRAWABLE(self->obj), pyg_boxed_get(font, GdkFont),
		  GDK_GC(gc->obj), x, y, text, len);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_points kwargs
static PyObject *
_wrap_gdk_draw_points(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "points", NULL };
    PyGObject *gc;
    PyObject *py_points;
    gint npoints, i;
    GdkPoint *points;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GdkDrawable.draw_points",
				     kwlist, &gc, &py_points))
	return NULL;
    if (!pygobject_check(gc, &PyGdkGC_Type)) {
	PyErr_SetString(PyExc_TypeError, "gc must be a GdkGC");
	return NULL;
    }
    if (!PySequence_Check(py_points)) {
	PyErr_SetString(PyExc_TypeError, "points must be a sequence");
	return NULL;
    }
    npoints = PySequence_Length(py_points);
    points = g_new(GdkPoint, npoints);
    for (i = 0; i < npoints; i++) {
	PyObject *item = PySequence_GetItem(py_points, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "hh", &points[i].x, &points[i].y)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "sequence members must be 2-tuples");
	    g_free(points);
	    return NULL;
	}
    }
    gdk_draw_points(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj), points, npoints);
    g_free(points);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_segments kwargs
static PyObject *
_wrap_gdk_draw_segments(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "segs", NULL };
    PyGObject *gc;
    PyObject *py_segs;
    gint nsegs, i;
    GdkSegment *segs;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GdkDrawable.draw_segments",
				     kwlist, &gc, &py_segs))
	return NULL;
    if (!pygobject_check(gc, &PyGdkGC_Type)) {
	PyErr_SetString(PyExc_TypeError, "gc must be a GdkGC");
	return NULL;
    }
    if (!PySequence_Check(py_segs)) {
	PyErr_SetString(PyExc_TypeError, "segs must be a sequence");
	return NULL;
    }
    nsegs = PySequence_Length(py_segs);
    segs = g_new(GdkSegment, nsegs);
    for (i = 0; i < nsegs; i++) {
	PyObject *item = PySequence_GetItem(py_segs, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "hhhh", &segs[i].x1, &segs[i].y1,
			      &segs[i].x2, &segs[i].y2)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "sequence members must be 4-tuples");
	    g_free(segs);
	    return NULL;
	}
    }
    gdk_draw_segments(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj), segs, nsegs);
    g_free(segs);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_lines kwargs
static PyObject *
_wrap_gdk_draw_lines(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "points", NULL };
    PyGObject *gc;
    PyObject *py_points;
    gint npoints, i;
    GdkPoint *points;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:GdkDrawable.draw_lines",
				     kwlist, &gc, &py_points))
	return NULL;
    if (!pygobject_check(gc, &PyGdkGC_Type)) {
	PyErr_SetString(PyExc_TypeError, "gc must be a GdkGC");
	return NULL;
    }
    if (!PySequence_Check(py_points)) {
	PyErr_SetString(PyExc_TypeError, "points must be a sequence");
	return NULL;
    }
    npoints = PySequence_Length(py_points);
    points = g_new(GdkPoint, npoints);
    for (i = 0; i < npoints; i++) {
	PyObject *item = PySequence_GetItem(py_points, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "hh", &points[i].x, &points[i].y)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "sequence members must be 2-tuples");
	    g_free(points);
	    return NULL;
	}
    }
    gdk_draw_lines(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj), points, npoints);
    g_free(points);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore
  gdk_color_copy gdk_color_free
  gdk_color_hash gdk_color_equal
  gdk_color_parse
%%
override gdk_fontset_load kwargs
static PyObject *
_wrap_gdk_fontset_load(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fontset_name", NULL };
    char *fontset_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:fontset_load", kwlist,
				     &fontset_name))
        return NULL;

    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GDK_TYPE_FONT, gdk_fontset_load(fontset_name),
			 FALSE, TRUE);
}
%%
override gdk_text_extents kwargs
static PyObject *
_wrap_gdk_text_extents(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    gchar *text;
    gint length;
    gint lbearing, rbearing, width, ascent, descent;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s#:GdkFont.extents",
				     kwlist, &text, &length))
	return NULL;
    gdk_text_extents(pyg_boxed_get(self, GdkFont), text, length,
		     &lbearing, &rbearing, &width, &ascent, &descent);
    return Py_BuildValue("(iiiii)", lbearing, rbearing, width,
			 ascent, descent);
}
%%
override gdk_pixmap_create_from_xpm kwargs
static PyObject *
_wrap_gdk_pixmap_create_from_xpm(PyObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "window", "transparent_color", "filename", NULL};
    PyGObject *window;
    PyObject *py_trans_color, *ret;
    GdkColor *trans_color = NULL;
    gchar *filename;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOs:pixmap_create_from_xpm", kwlist,
				     &window, &py_trans_color, &filename))
	return NULL;
    if (!pygobject_check(window, &PyGdkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "window must be a GdkWindow");
	return NULL;
    }
    if (pyg_boxed_check(py_trans_color, GDK_TYPE_COLOR))
	trans_color = pyg_boxed_get(py_trans_color, GdkColor);
    else if (py_trans_color != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"transparent_color must be a colour or None");
	return NULL;
    }
    pixmap = gdk_pixmap_create_from_xpm(GDK_WINDOW(window->obj), &mask,
					trans_color, filename);
    if (pixmap == NULL) {
	PyErr_SetString(PyExc_IOError, "can't load pixmap");
	return NULL;
    }
    ret = Py_BuildValue("(NN)",
			pygobject_new((GObject *)pixmap),
			pygobject_new((GObject *)mask));
    gdk_pixmap_unref(pixmap);
    gdk_bitmap_unref(mask);
    return ret;
}
%%
override gdk_pixmap_colormap_create_from_xpm kwargs
static PyObject *
_wrap_gdk_pixmap_colormap_create_from_xpm(PyObject *self, PyObject *args,
					  PyObject *kwargs)
{
    static char *kwlist[] = { "window", "colormap", "transparent_color",
			      "filename", NULL };
    PyObject *py_window, *py_colormap, *py_trans_color, *ret;
    GdkWindow *window = NULL;
    GdkColormap *colormap = NULL;
    GdkColor *trans_color = NULL;
    gchar *filename;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOOs:pixmap_colormap_create_from_xpm",
				     kwlist, &py_window, &py_colormap,
				     &py_trans_color, &filename))
	return NULL;
    if (pygobject_check(py_window, &PyGdkWindow_Type))
	window = GDK_WINDOW(pygobject_get(py_window));
    else if (py_window != Py_None) {
	PyErr_SetString(PyExc_TypeError, "window must be a GdkWindow or None");
	return NULL;
    }
    if (pygobject_check(py_colormap, &PyGdkColormap_Type))
	colormap = GDK_COLORMAP(pygobject_get(py_colormap));
    else if (py_colormap != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"colormap must be a GdkColormap or None");
	return NULL;
    }
    if (pyg_boxed_check(py_trans_color, GDK_TYPE_COLOR))
	trans_color = pyg_boxed_get(py_trans_color, GdkColor);
    else if (py_trans_color != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"transparent_color must be a colour or None");
	return NULL;
    }
    pixmap = gdk_pixmap_colormap_create_from_xpm(window, colormap, &mask,
						 trans_color, filename);
    if (pixmap == NULL) {
	PyErr_SetString(PyExc_IOError, "can't load pixmap");
	return NULL;
    }
    ret = Py_BuildValue("(NN)",
			pygobject_new((GObject *)pixmap),
			pygobject_new((GObject *)mask));
    gdk_pixmap_unref(pixmap);
    gdk_bitmap_unref(mask);
    return ret;
}
%%
override gdk_pixmap_create_from_xpm_d kwargs
static PyObject *
_wrap_gdk_pixmap_create_from_xpm_d(PyObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "window", "transparent_color", "data", NULL };
    PyGObject *window;
    PyObject *py_trans_color, *py_data, *ret;
    GdkColor *trans_color = NULL;
    gchar **data;
    int len, i;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!OO!:pixmap_create_from_xpm_d", kwlist,
				     &window, &py_trans_color,
				     &PyList_Type, &py_data))
	return NULL;
    if (!pygobject_check(window, &PyGdkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "window must be a GdkWindow");
	return NULL;
    }
    if (pyg_boxed_check(py_trans_color, GDK_TYPE_COLOR))
	trans_color = pyg_boxed_get(py_trans_color, GdkColor);
    else if (py_trans_color != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"transparent_color must be a colour or None");
	return NULL;
    }
    len = PyList_Size(py_data);
    data = g_new(gchar *, len);
    for (i = 0; i < len; i ++) {
	PyObject *item = PyList_GetItem(py_data, i);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "data items must be strings");
	    g_free(data);
	    return NULL;
	}
	data[i] = PyString_AsString(item);
    }
    pixmap = gdk_pixmap_create_from_xpm_d(GDK_WINDOW(window->obj), &mask,
					  trans_color, data);
    g_free(data);
    if (pixmap == NULL) {
	PyErr_SetString(PyExc_IOError, "can't load pixmap");
	return NULL;
    }
    ret = Py_BuildValue("(NN)",
			pygobject_new((GObject *)pixmap),
			pygobject_new((GObject *)mask));
    gdk_pixmap_unref(pixmap);
    gdk_bitmap_unref(mask);
    return ret;
}
%%
override gdk_pixmap_colormap_create_from_xpm_d kwargs
static PyObject *
_wrap_gdk_pixmap_colormap_create_from_xpm_d(PyObject *self, PyObject *args,
					    PyObject *kwargs)
{
    static char *kwlist[] = { "window", "colormap", "transparent_color",
			      "data", NULL };
    PyObject *py_window, *py_colormap, *py_trans_color, *py_data, *ret;
    GdkWindow *window = NULL;
    GdkColormap *colormap = NULL;
    GdkColor *trans_color = NULL;
    gchar **data;
    int len, i;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOOO!:pixmap_colormap_create_from_xpm_d",
				     kwlist, &py_window, &py_colormap,
				     &py_trans_color,
				     &PyList_Type, &py_data))
	return NULL;
    if (pygobject_check(py_window, &PyGdkWindow_Type))
	window = GDK_WINDOW(pygobject_get(py_window));
    else if (py_window != Py_None) {
	PyErr_SetString(PyExc_TypeError, "window must be a GdkWindow or None");
	return NULL;
    }
    if (pygobject_check(py_colormap, &PyGdkColormap_Type))
	colormap = GDK_COLORMAP(pygobject_get(py_colormap));
    else if (py_colormap != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"colormap must be a GdkColormap or None");
	return NULL;
    }
    if (pyg_boxed_check(py_trans_color, GDK_TYPE_COLOR))
	trans_color = pyg_boxed_get(py_trans_color, GdkColor);
    else if (py_trans_color != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"transparent_color must be a colour or None");
	return NULL;
    }
    len = PyList_Size(py_data);
    data = g_new(gchar *, len);
    for (i = 0; i < len; i ++) {
	PyObject *item = PyList_GetItem(py_data, i);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "data items must be strings");
	    g_free(data);
	    return NULL;
	}
	data[i] = PyString_AsString(item);
    }
    pixmap = gdk_pixmap_colormap_create_from_xpm_d(window, colormap, &mask,
						   trans_color, data);
    g_free(data);
    if (pixmap == NULL) {
	PyErr_SetString(PyExc_IOError, "can't load pixmap");
	return NULL;
    }
    ret = Py_BuildValue("(NN)",
			pygobject_new((GObject *)pixmap),
			pygobject_new((GObject *)mask));
    gdk_pixmap_unref(pixmap);
    gdk_bitmap_unref(mask);
    return ret;
}
%%
ignore gdk_cursor_new_from_pixmap
%%
override gdk_cursor_new kwargs
static PyObject *
_wrap_gdk_cursor_new(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist1[] = { "cursor_type", NULL };
    static char *kwlist2[] = { "source", "mask", "fg", "bg", "x", "y", NULL };
    PyObject *py_cursor_type;

    self->gtype = GDK_TYPE_CURSOR;
    self->free_on_dealloc = FALSE;
    self->boxed = NULL;
    if (PyArg_ParseTupleAndKeywords(args, kwargs, "O:GdkCursor.__init__",
				    kwlist1, &py_cursor_type)) {
	GdkCursorType cursor_type;

        if (pyg_enum_get_value(GDK_TYPE_CURSOR_TYPE, py_cursor_type,
			       (gint *)&cursor_type))
	    return NULL;
	self->boxed = gdk_cursor_new(cursor_type);
	if (!self->boxed) {
	    PyErr_SetString(PyExc_RuntimeError,
			    "could not create GdkCursor object");
	    return NULL;
	}
	self->free_on_dealloc = TRUE;
    } else {
	PyGObject *source, *mask;
	PyObject *fg, *bg;
	gint x, y;
	PyErr_Clear();

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "OOOOii:GdkCursor.__init__", kwlist2,
					 &source, &mask, &fg, &bg, &x, &y))
	    return NULL;
	if (!pygobject_check(source, &PyGdkPixmap_Type)) {
	    PyErr_SetString(PyExc_TypeError, "source should be a GdkPixmap");
	    return NULL;
	}
	if (!pygobject_check(mask, &PyGdkPixmap_Type)) {
	    PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap");
	    return NULL;
	}
	if (!pyg_boxed_check(fg, GDK_TYPE_COLOR)) {
	    PyErr_SetString(PyExc_TypeError, "fg should be a GdkColor");
	    return NULL;
	}
	if (!pyg_boxed_check(bg, GDK_TYPE_COLOR)) {
	    PyErr_SetString(PyExc_TypeError, "bg should be a GdkColor");
	    return NULL;
	}
	self->boxed = gdk_cursor_new_from_pixmap(GDK_PIXMAP(source->obj),
						 GDK_PIXMAP(mask->obj),
						 pyg_boxed_get(fg, GdkColor),
						 pyg_boxed_get(bg, GdkColor),
						 x, y);
	if (!self->boxed) {
	    PyErr_SetString(PyExc_RuntimeError,
			    "could not create GdkCursor object");
	    return NULL;
	}
	self->free_on_dealloc = TRUE;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_event_getattr
PyObject *
_wrap_gdk_event_getattr(PyObject *self, char *attr)
{
    GdkEvent *event = pyg_boxed_get(self, GdkEvent);
    guint i;

    if (!strcmp(attr, "type"))
	return PyInt_FromLong(event->type);
    if (!strcmp(attr, "window"))
	return pygobject_new((GObject *)event->any.window);
    if (!strcmp(attr, "send_event"))
	return PyInt_FromLong(event->any.send_event);

    switch(event->type) {
    case GDK_NOTHING: break;
    case GDK_DELETE: break;
    case GDK_DESTROY: break;
    case GDK_EXPOSE:            /*GdkEventExpose            expose*/
	if (!strcmp(attr, "area"))
	    return Py_BuildValue("(iiii)",
				 event->expose.area.x,
				 event->expose.area.y,
				 event->expose.area.width,
				 event->expose.area.height);
	if (!strcmp(attr, "count"))
	    return PyInt_FromLong(event->expose.count);
	break;
    case GDK_MOTION_NOTIFY:     /*GdkEventMotion            motion*/
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->motion.time);
	if (!strcmp(attr, "x"))
	    return PyFloat_FromDouble(event->motion.x);
	if (!strcmp(attr, "y"))
	    return PyFloat_FromDouble(event->motion.y);
	if (!strcmp(attr, "axes")) {
	    if (event->motion.axes) {
		PyObject *v = PyTuple_New(event->motion.device->num_axes);
		if (!v) return NULL;
		for (i = 0; i < event->motion.device->num_axes; i++)
		    PyTuple_SetItem(v, i,PyFloat_FromDouble(
						event->motion.axes[i]));
		return v;
	    } else {
		Py_INCREF(Py_None);
		return Py_None;
	    }
	}
	if (!strcmp(attr, "state"))
	    return PyInt_FromLong(event->motion.state);
	if (!strcmp(attr, "is_hint"))
	    return PyInt_FromLong(event->motion.is_hint);
	if (!strcmp(attr, "device"))
	    return pygobject_new((GObject *)event->motion.device);
	if (!strcmp(attr, "x_root"))
	    return PyFloat_FromDouble(event->motion.x_root);
	if (!strcmp(attr, "y_root"))
	    return PyFloat_FromDouble(event->motion.y_root);
	break;
    case GDK_BUTTON_PRESS:      /*GdkEventButton            button*/
    case GDK_2BUTTON_PRESS:     /*GdkEventButton            button*/
    case GDK_3BUTTON_PRESS:     /*GdkEventButton            button*/
    case GDK_BUTTON_RELEASE:    /*GdkEventButton            button*/
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->button.time);
	if (!strcmp(attr, "x"))
	    return PyFloat_FromDouble(event->button.x);
	if (!strcmp(attr, "y"))
	    return PyFloat_FromDouble(event->button.y);
	if (!strcmp(attr, "axes")) {
	    if (event->button.axes) {
		PyObject *v = PyTuple_New(event->button.device->num_axes);
		if (!v) return NULL;
		for (i = 0; i < event->button.device->num_axes; i++)
		    PyTuple_SetItem(v, i,PyFloat_FromDouble(
						event->button.axes[i]));
		return v;
	    } else {
		Py_INCREF(Py_None);
		return Py_None;
	    }
	}
	if (!strcmp(attr, "state"))
	    return PyInt_FromLong(event->button.state);
	if (!strcmp(attr, "button"))
	    return PyInt_FromLong(event->button.button);
	if (!strcmp(attr, "device"))
	    return pygobject_new((GObject *)event->button.device);
	if (!strcmp(attr, "x_root"))
	    return PyFloat_FromDouble(event->button.x_root);
	if (!strcmp(attr, "y_root"))
	    return PyFloat_FromDouble(event->button.y_root);
	break;
    case GDK_KEY_PRESS:         /*GdkEventKey               key*/
    case GDK_KEY_RELEASE:       /*GdkEventKey               key*/
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->key.time);
	if (!strcmp(attr, "state"))
	    return PyInt_FromLong(event->key.state);
	if (!strcmp(attr, "keyval"))
	    return PyInt_FromLong(event->key.keyval);
	if (!strcmp(attr, "string"))
	    return PyString_FromStringAndSize(event->key.string,
					      event->key.length);
	break;
    case GDK_ENTER_NOTIFY:      /*GdkEventCrossing          crossing*/
    case GDK_LEAVE_NOTIFY:      /*GdkEventCrossing          crossing*/
	if (!strcmp(attr, "subwindow"))
	    return pygobject_new((GObject *)event->crossing.subwindow);
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->crossing.time);
	if (!strcmp(attr, "x"))
	    return PyFloat_FromDouble(event->crossing.x);
	if (!strcmp(attr, "y"))
	    return PyFloat_FromDouble(event->crossing.y);
	if (!strcmp(attr, "x_root"))
	    return PyFloat_FromDouble(event->crossing.x_root);
	if (!strcmp(attr, "y_root"))
	    return PyFloat_FromDouble(event->crossing.y_root);
	if (!strcmp(attr, "mode"))
	    return PyInt_FromLong(event->crossing.mode);
	if (!strcmp(attr, "detail"))
	    return PyInt_FromLong(event->crossing.detail);
	if (!strcmp(attr, "focus"))
	    return PyInt_FromLong(event->crossing.focus);
	if (!strcmp(attr, "state"))
	    return PyInt_FromLong(event->crossing.state);
	break;
    case GDK_FOCUS_CHANGE:      /*GdkEventFocus             focus_change*/
	if (!strcmp(attr, "in_"))
	    return PyInt_FromLong(event->focus_change.in);
	break;
    case GDK_CONFIGURE:         /*GdkEventConfigure         configure*/
	if (!strcmp(attr, "x"))
	    return PyInt_FromLong(event->configure.x);
	if (!strcmp(attr, "y"))
	    return PyInt_FromLong(event->configure.y);
	if (!strcmp(attr, "width"))
	    return PyInt_FromLong(event->configure.width);
	if (!strcmp(attr, "height"))
	    return PyInt_FromLong(event->configure.height);
	break;
    case GDK_MAP: break;
    case GDK_UNMAP: break;
    case GDK_PROPERTY_NOTIFY:   /*GdkEventProperty          property*/
	if (!strcmp(attr, "atom"))
	    return PyGdkAtom_New(event->property.atom);
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->property.time);
	if (!strcmp(attr, "state"))
	    return PyInt_FromLong(event->property.state);
	break;
    case GDK_SELECTION_CLEAR:   /*GdkEventSelection         selection*/
    case GDK_SELECTION_REQUEST: /*GdkEventSelection         selection*/
    case GDK_SELECTION_NOTIFY:  /*GdkEventSelection         selection*/
	if (!strcmp(attr, "selection"))
	    return PyGdkAtom_New(event->selection.selection);
	if (!strcmp(attr, "target"))
	    return PyGdkAtom_New(event->selection.target);
	if (!strcmp(attr, "property"))
	    return PyGdkAtom_New(event->selection.property);
	if (!strcmp(attr, "requestor"))
	    return PyInt_FromLong(event->selection.requestor);
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->selection.time);
	break;
    case GDK_PROXIMITY_IN:      /*GdkEventProximity         proximity*/
    case GDK_PROXIMITY_OUT:     /*GdkEventProximity         proximity*/
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->proximity.time);
	if (!strcmp(attr, "device"))
	    return pygobject_new((GObject *)event->proximity.device);
	break;
    case GDK_DRAG_ENTER:        /*GdkEventDND               dnd*/
    case GDK_DRAG_LEAVE:        /*GdkEventDND               dnd*/
    case GDK_DRAG_MOTION:       /*GdkEventDND               dnd*/
    case GDK_DRAG_STATUS:       /*GdkEventDND               dnd*/
    case GDK_DROP_START:        /*GdkEventDND               dnd*/
    case GDK_DROP_FINISHED:     /*GdkEventDND               dnd*/
	if (!strcmp(attr, "context"))
	    return pygobject_new((GObject *)event->dnd.context);
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->dnd.time);
	if (!strcmp(attr, "x_root"))
	    return PyFloat_FromDouble(event->dnd.x_root);
	if (!strcmp(attr, "y_root"))
	    return PyFloat_FromDouble(event->dnd.y_root);
	break;
    case GDK_CLIENT_EVENT:      /*GdkEventClient            client*/
	if (!strcmp(attr, "message_type"))
	    return PyGdkAtom_New(event->client.message_type);
	if (!strcmp(attr, "data_format"))
	    return PyInt_FromLong(event->client.data_format);
	if (!strcmp(attr, "data"))
	    return PyString_FromStringAndSize(event->client.data.b, 20);
	break;
    case GDK_VISIBILITY_NOTIFY: /*GdkEventVisibility        visibility*/
	if (!strcmp(attr, "state"))
	    return PyInt_FromLong(event->visibility.state);
	break;
    case GDK_NO_EXPOSE:         /*GdkEventNoExpose          no_expose*/
	break;
    case GDK_SCROLL:            /*GdkEventScroll            scroll*/
	if (!strcmp(attr, "time"))
	    return PyInt_FromLong(event->scroll.time);
	if (!strcmp(attr, "x"))
	    return PyFloat_FromDouble(event->scroll.x);
	if (!strcmp(attr, "y"))
	    return PyFloat_FromDouble(event->scroll.y);
	if (!strcmp(attr, "state"))
	    return PyInt_FromLong(event->scroll.state);
	if (!strcmp(attr, "direction"))
	    return PyInt_FromLong(event->scroll.direction);
	if (!strcmp(attr, "device"))
	    return pygobject_new((GObject *)event->scroll.device);
	if (!strcmp(attr, "x_root"))
	    return PyFloat_FromDouble(event->scroll.x_root);
	if (!strcmp(attr, "y_root"))
	    return PyFloat_FromDouble(event->scroll.y_root);
	break;
    case GDK_WINDOW_STATE:      /*GdkEventWindowState       window_state*/
	if (!strcmp(attr, "changed_mask"))
	    return PyInt_FromLong(event->window_state.changed_mask);
	if (!strcmp(attr, "new_window_state"))
	    return PyInt_FromLong(event->window_state.new_window_state);
	break;
    case GDK_SETTING:           /*GdkEventSetting           setting*/
	if (!strcmp(attr, "action"))
	    return PyInt_FromLong(event->setting.action);
	if (!strcmp(attr, "name"))
	    return PyString_FromString(event->setting.name);
	break;
    default:
	break;
    }
    PyErr_SetString(PyExc_AttributeError, attr);
    return NULL;
}
%%
override-attr GdkDevice.axes
GdkDevice *device = GDK_DEVICE(self->obj);
PyObject *ret;
gint i;

ret = PyTuple_New(device->num_axes);
for (i = 0; i < device->num_axes; i++)
    PyTuple_SetItem(ret, i, Py_BuildValue("(idd)",
					  device->axes[i].use,
					  device->axes[i].min,
					  device->axes[i].max));
return ret;
%%
override-attr GdkDevice.keys
GdkDevice *device = GDK_DEVICE(self->obj);
PyObject *ret;
gint i;

ret = PyTuple_New(device->num_keys);
for (i = 0; i < device->num_keys; i++)
    PyTuple_SetItem(ret, i, Py_BuildValue("(ii)",
					  device->keys[i].keyval,
					  device->keys[i].modifiers));
return ret;
%%
override gdk_device_get_state kwargs
static PyObject *
_wrap_gdk_device_get_state(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", NULL };
    GdkDevice *device = GDK_DEVICE(self->obj);
    PyGObject *window;
    gdouble *axes;
    GdkModifierType mask;
    PyObject *py_axes;
    guint i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GdkDevice.get_state",
				     kwlist, &window))
	return NULL;
    if (!pygobject_check(window, &PyGdkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "window should be a GdkWindow");
	return NULL;
    }
    axes = g_new0(gdouble, device->num_axes);
    gdk_device_get_state(device, GDK_WINDOW(window->obj), axes, &mask);
    py_axes = PyTuple_New(device->num_axes);
    for (i = 0; i < device->num_axes; i++)
	PyTuple_SetItem(py_axes, i, PyFloat_FromDouble(axes[i]));
    g_free(axes);
    return Py_BuildValue("(Ni)", py_axes, mask);
}
%%
ignore gdk_device_free_history
%%
override gdk_device_get_history kwargs
static PyObject *
_wrap_gdk_device_get_history(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "start", "stop", NULL };
    GdkDevice *device = GDK_DEVICE(self->obj);
    PyGObject *window;
    guint start, stop;
    GdkTimeCoord **events;
    gint n_events;
    PyObject *pyevents;
    guint i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oii:GdkDevice.get_history", kwlist,
				     &window, &start, &stop))
	return NULL;
    if (!pygobject_check(window, &PyGdkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "window should be a GdkWindow");
	return NULL;
    }
    gdk_device_get_history(device, GDK_WINDOW(window->obj), start, stop,
			   &events, &n_events);
    pyevents = PyTuple_New(n_events);
    for (i = 0; i < n_events; i++) {
	PyObject *axes;
	gint j;

	axes = PyTuple_New(device->num_axes);
	for (j = 0; j < device->num_axes; j++)
	    PyTuple_SetItem(axes, j, PyFloat_FromDouble(events[i]->axes[j]));
	PyTuple_SetItem(pyevents, i, Py_BuildValue("(iN)", events[i]->time,
						   axes));
    }
    gdk_device_free_history(events, n_events);
    return pyevents;
}
%%
override gdk_device_get_axis kwargs
static PyObject *
_wrap_gdk_device_get_axis(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "axes", "use", NULL };
    GdkDevice *device = GDK_DEVICE(self->obj);
    PyObject *py_axes;
    gdouble *axes, value;
    GdkAxisUse use;
    gboolean ret;
    gint i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oi:GdkDevice.get_axis",
				     kwlist, &py_axes, &use))
	return NULL;
    if (!PySequence_Check(py_axes)) {
	PyErr_SetString(PyExc_TypeError, "axes must be a sequence");
	return NULL;
    }
    if (PySequence_Length(py_axes) != device->num_axes) {
	PyErr_SetString(PyExc_TypeError, "axes has the wrong length");
	return NULL;
    }
    axes = g_new(gdouble, device->num_axes);
    for (i = 0; i < device->num_axes; i++) {
	PyObject *item = PySequence_GetItem(py_axes, i);

	axes[i] = PyFloat_AsDouble(item);
	Py_DECREF(item);
	if (PyErr_Occurred()) {
	    g_free(axes);
	    return NULL;
       }
    }
    ret = gdk_device_get_axis(device, axes, use, &value);
    g_free(axes);
    if (ret)
	return PyFloat_FromDouble(value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_drag_find_window kwargs
static PyObject *
_wrap_gdk_drag_find_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "drag_window", "x_root", "y_root", NULL };
    PyGObject *drag_window;
    gint x_root, y_root;
    GdkWindow *dest_window;
    GdkDragProtocol protocol;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oii:GdkDragContext.drag_find_window",
				     kwlist, &drag_window, &x_root, &y_root))
	return NULL;
    if (!pygobject_check(drag_window, &PyGdkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "drag_window must be a GdkWindow");
	return NULL;
    }
    gdk_drag_find_window(GDK_DRAG_CONTEXT(self->obj),
			 GDK_WINDOW(drag_window->obj), x_root, y_root,
			 &dest_window, &protocol);
    return Py_BuildValue("(Ni)", pygobject_new((GObject *)dest_window),
			 protocol);
}
%%
override-attr GdkDragContext.targets
PyObject *atom, *ret = PyList_New(0);
GList *tmp;
if (ret == NULL)
    return NULL;
for (tmp = GDK_DRAG_CONTEXT(self->obj)->targets; tmp; tmp = tmp->next) {
    if ((atom = PyGdkAtom_New(GPOINTER_TO_INT(tmp->data))) == NULL) {
	Py_DECREF(ret);
	return NULL;
    }
    PyList_Append(ret, atom);
    Py_DECREF(atom);
}
return ret;
%%
override gdk_gc_new_with_values kwargs
static PyObject *
_wrap_gdk_gc_new_with_values(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "foreground", "background", "font", "function",
			      "fill", "tile", "stipple", "clip_mask",
			      "subwindow_mode", "ts_x_origin", "ts_y_origin",
			      "clip_x_origin", "clip_y_origin",
			      "graphics_exposures", "line_width", "line_style",
			      "cap_style", "join_style", NULL };
    PyObject *foreground = Py_None, *background = Py_None;
    PyObject *font = Py_None;
    gint function = -1, fill = -1;
    PyObject *tile = Py_None, *stipple = Py_None, *clip_mask = Py_None;
    gint subwindow_mode = -1, ts_x_origin = -1, ts_y_origin = -1;
    gint clip_x_origin = -1, clip_y_origin = -1, graphics_exposures = -1;
    gint line_width = -1, line_style = -1, cap_style = -1, join_style = -1;
    GdkGCValues values;
    GdkGCValuesMask mask = 0;
    GdkGC *gc;
    PyObject *pygc;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|OOOiiOOOiiiiiiiiii:GdkDrawable.new_gc",
				     kwlist, &foreground, &background, &font,
				     &function, &fill, &tile, &stipple,
				     &clip_mask, &subwindow_mode,
				     &ts_x_origin, &ts_y_origin,
				     &clip_x_origin, &clip_y_origin,
				     &graphics_exposures, &line_width,
				     &line_style, &cap_style, &join_style))
	return NULL;
    if (pyg_boxed_check(foreground, GDK_TYPE_COLOR)) {
	mask |= GDK_GC_FOREGROUND;
	values.foreground = *pyg_boxed_get(foreground, GdkColor);
    } else if (foreground != Py_None) {
	PyErr_SetString(PyExc_TypeError, "foreground must be a GdkColor");
	return NULL;
    }
    if (pyg_boxed_check(background, GDK_TYPE_COLOR)) {
	mask |= GDK_GC_BACKGROUND;
	values.background = *pyg_boxed_get(background, GdkColor);
    } else if (background != Py_None) {
	PyErr_SetString(PyExc_TypeError, "background must be a GdkColor");
	return NULL;
    }
    if (pyg_boxed_check(font, GDK_TYPE_FONT)) {
	mask |= GDK_GC_FONT;
	values.font = pyg_boxed_get(font, GdkFont);
    } else if (font != Py_None) {
	PyErr_SetString(PyExc_TypeError, "font must be a GdkFont");
	return NULL;
    }
    if (function != -1) {
	mask |= GDK_GC_FUNCTION;
	values.function = function;
    }
    if (fill != -1) {
	mask |= GDK_GC_FILL;
	values.fill = fill;
    }
    if (pygobject_check(tile, &PyGdkPixmap_Type)) {
	mask |= GDK_GC_TILE;
	values.tile = GDK_PIXMAP(pygobject_get(tile));
    } else if (tile != Py_None) {
	PyErr_SetString(PyExc_TypeError, "tile must be a GdkPixmap");
	return NULL;
    }
    if (pygobject_check(stipple, &PyGdkPixmap_Type)) {
	mask |= GDK_GC_STIPPLE;
	values.stipple = GDK_PIXMAP(pygobject_get(stipple));
    } else if (stipple != Py_None) {
	PyErr_SetString(PyExc_TypeError, "stipple must be a GdkPixmap");
	return NULL;
    }
    if (pygobject_check(clip_mask, &PyGdkPixmap_Type)) {
	mask |= GDK_GC_CLIP_MASK;
	values.clip_mask = GDK_PIXMAP(pygobject_get(clip_mask));
    } else if (clip_mask != Py_None) {
	PyErr_SetString(PyExc_TypeError, "clip_mask must be a GdkPixmap");
	return NULL;
    }
    if (subwindow_mode != -1) {
	mask |= GDK_GC_SUBWINDOW;
	values.subwindow_mode = subwindow_mode;
    }
    if (ts_x_origin != -1) {
	mask |= GDK_GC_TS_X_ORIGIN;
	values.ts_x_origin = ts_x_origin;
    }
    if (ts_y_origin != -1) {
	mask |= GDK_GC_TS_Y_ORIGIN;
	values.ts_y_origin = ts_y_origin;
    }
    if (clip_x_origin != -1) {
	mask |= GDK_GC_CLIP_X_ORIGIN;
	values.clip_x_origin = clip_x_origin;
    }
    if (clip_y_origin != -1) {
	mask |= GDK_GC_CLIP_Y_ORIGIN;
	values.clip_y_origin = clip_y_origin;
    }
    if (graphics_exposures != -1) {
	mask |= GDK_GC_EXPOSURES;
	values.graphics_exposures = graphics_exposures;
    }
    if (line_width != -1) {
	mask |= GDK_GC_LINE_WIDTH;
	values.line_width = line_width;
    }
    if (line_style != -1) {
	mask |= GDK_GC_LINE_STYLE;
	values.line_style = line_style;
    }
    if (cap_style != -1) {
	mask |= GDK_GC_CAP_STYLE;
	values.cap_style = cap_style;
    }
    if (join_style != -1) {
	mask |= GDK_GC_JOIN_STYLE;
	values.join_style = join_style;
    }
    gc = gdk_gc_new_with_values(GDK_DRAWABLE(self->obj), &values, mask);
    pygc = pygobject_new((GObject *)gc);
    gdk_gc_unref(gc);
    return pygc;
}
%%
override gdk_drawable_get_size
static PyObject *
_wrap_gdk_drawable_get_size(PyGObject *self, PyObject *args)
{
    gint width;
    gint height;

    if (!PyArg_ParseTuple(args, ":GdkDrawable.get_size"))
	return NULL;
    gdk_drawable_get_size(GDK_DRAWABLE(self->obj), &width, &height);
    return Py_BuildValue("(ii)", width, height);
}
%%
override gdk_drag_begin kwargs
static PyObject *
_wrap_gdk_drag_begin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", NULL };
    PyObject *py_targets;
    GList *targets = NULL;
    guint i, len;
    GdkDragContext *context;
    PyObject *py_context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GdkWindow.drag_begin",
				     kwlist, &py_targets))
	return NULL;
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a list of ints");
	return NULL;
    }
    len = PySequence_Length(py_targets);
    for (i = 0; i < len; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);

	if (PyInt_Check(item)) {
	    targets = g_list_append(targets,
				    GUINT_TO_POINTER(PyInt_AsLong(item)));
	    Py_DECREF(item);
	} else {
	    PyErr_SetString(PyExc_TypeError, "targets must be a list of ints");
	    Py_DECREF(item);
	    g_list_free(targets);
	    return NULL;
	}
    }
    context = gdk_drag_begin(GDK_WINDOW(self->obj), targets);
    g_list_free(targets);
    py_context = pygobject_new((GObject *)context);
    gdk_drag_context_unref(context);
    return py_context;
}
%%
override gdk_property_get kwargs
static PyObject *
_wrap_gdk_property_get(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "property", "type", "pdelete", NULL };
    GdkAtom property, type = 0;
    gint pdelete = FALSE;

    GdkAtom atype;
    gint aformat, alength;
    guchar *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "i|ii:GdkWindow.property_get", kwlist,
				     &property, &type, &pdelete)) {
	gchar *propname;

	PyErr_Clear();
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "s|ii:GdkWindow.property_get", kwlist,
					 &propname, &type, &pdelete))
	    return NULL;
	property = gdk_atom_intern(propname, FALSE);
    }
    if (gdk_property_get(GDK_WINDOW(self->obj), property, type, 0, 9999,
			 pdelete, &atype, &aformat, &alength, &data)) {
	/* success */
	PyObject *pdata = NULL;
	gint i;
	guint16 *data16;
	guint32 *data32;
	switch (aformat) {
	case 8:
	    if ((pdata = PyString_FromStringAndSize(data, alength)) == NULL)
	        return NULL;
	    break;
	case 16:
	    data16 = (guint16 *)data;
	    if ((pdata = PyTuple_New(alength)) == NULL)
	        return NULL;
	    for (i = 0; i < alength; i++)
		PyTuple_SetItem(pdata, i, PyInt_FromLong(data16[i]));
	    break;
	case 32:
	    data32 = (guint32 *)data;
	    if ((pdata = PyTuple_New(alength)) == NULL)
	        return NULL;
	    for (i = 0; i < alength; i++)
		PyTuple_SetItem(pdata, i, PyInt_FromLong(data32[i]));
	    break;
	default:
	    g_warning("got a property format != 8, 16 or 32");
	    g_assert_not_reached();
	}
	g_free(data);
	return Py_BuildValue("(NiN)", PyGdkAtom_New(atype), aformat, pdata);
    } else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
override gdk_property_change kwargs
static PyObject *
_wrap_gdk_property_change(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "property","type","format","mode","data",NULL };
    GdkAtom property, type;
    gint format;
    PyObject *py_mode, *pdata;
    GdkPropMode mode;
    guchar *data = NULL;
    gint nelements;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "iiiOO:GdkWindow.property_change", kwlist,
				     &property, &type, &format, &py_mode,
				     &pdata)) {
	gchar *propname;

	PyErr_Clear();
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "siiOO:GdkWindow.property_change",
					 kwlist, &propname, &type, &format,
					 &py_mode, &pdata))
	    return NULL;
	property = gdk_atom_intern(propname, FALSE);
    }
    if (pyg_enum_get_value(GDK_TYPE_PROP_MODE, py_mode, (gint *)&mode))
	return NULL;
    switch (format) {
    case 8:
	if (!PyString_Check(pdata)) {
	    PyErr_SetString(PyExc_TypeError, "data not a string and format=8");
	    return NULL;
	}
	data = PyString_AsString(pdata);
	nelements = PyString_Size(pdata);
	break;
    case 16:
	{
	    guint16 *data16;
	    gint i;

	    if (!PySequence_Check(pdata)) {
		PyErr_SetString(PyExc_TypeError,
				"data not a sequence and format=16");
		return NULL;
	    }
	    nelements = PySequence_Length(pdata);
	    data16 = g_new(guint16, nelements);
	    data = (guchar *)data16;
	    for (i = 0; i < nelements; i++) {
		PyObject *item = PySequence_GetItem(pdata, i);
		Py_DECREF(item);
		item = PyNumber_Int(item);
		if (!item) {
		    g_free(data16);
		    PyErr_Clear();
		    PyErr_SetString(PyExc_TypeError,"data element not an int");
		    return NULL;
		}
		data16[i] = PyInt_AsLong(item);
		Py_DECREF(item);
	    }
	}
	break;
    case 32:
	{
	    guint32 *data32;
	    gint i;

	    if (!PySequence_Check(pdata)) {
		PyErr_SetString(PyExc_TypeError,
				"data not a sequence and format=32");
		return NULL;
	    }
	    nelements = PySequence_Length(pdata);
	    data32 = g_new(guint32, nelements);
	    data = (guchar *)data32;
	    for (i = 0; i < nelements; i++) {
		PyObject *item = PySequence_GetItem(pdata, i);
		Py_DECREF(item);
		item = PyNumber_Int(item);
		if (!item) {
		    g_free(data32);
		    PyErr_Clear();
		    PyErr_SetString(PyExc_TypeError,"data element not an int");
		    return NULL;
		}
		data32[i] = PyInt_AsLong(item);
		Py_DECREF(item);
	    }
	}
	break;
    default:
	PyErr_SetString(PyExc_TypeError, "format must be 8, 16 or 32");
	return NULL;
	break;
    }
    gdk_property_change(GDK_WINDOW(self->obj), property, type, format, mode,
			data, nelements);
    if (format != 8)
	g_free(data);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_window_get_geometry
static PyObject *
_wrap_gdk_window_get_geometry(PyGObject *self, PyObject *args)
{
    gint x, y, width, height, depth;

    if (!PyArg_ParseTuple(args, ":GdkWindow.get_geometry"))
	return NULL;
    gdk_window_get_geometry(GDK_WINDOW(self->obj), &x, &y, &width, &height,
			    &depth);
    return Py_BuildValue("(iiiii)", x, y, width, height, depth);
}
%%
override gdk_window_get_position
static PyObject *
_wrap_gdk_window_get_position(PyGObject *self, PyObject *args)
{
    gint x, y;

    if (!PyArg_ParseTuple(args, ":GdkWindow.get_position"))
	return NULL;
    gdk_window_get_position(GDK_WINDOW(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gdk_window_get_origin
static PyObject *
_wrap_gdk_window_get_origin(PyGObject *self, PyObject *args)
{
    gint x, y;

    if (!PyArg_ParseTuple(args, ":GdkWindow.get_origin"))
	return NULL;
    gdk_window_get_origin(GDK_WINDOW(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gdk_window_get_deskrelative_origin
static PyObject *
_wrap_gdk_window_get_deskrelative_origin(PyGObject *self, PyObject *args)
{
    gint x, y;

    if (!PyArg_ParseTuple(args, ":GdkWindow.get_deskrelative_origin"))
	return NULL;
    gdk_window_get_deskrelative_origin(GDK_WINDOW(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gdk_window_get_root_origin
static PyObject *
_wrap_gdk_window_get_root_origin(PyGObject *self, PyObject *args)
{
    gint x, y;

    if (!PyArg_ParseTuple(args, ":GdkWindow.get_root_origin"))
	return NULL;
    gdk_window_get_root_origin(GDK_WINDOW(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gdk_window_get_pointer
static PyObject *
_wrap_gdk_window_get_pointer(PyGObject *self, PyObject *args)
{
    gint x, y;
    GdkModifierType mask;

    if (!PyArg_ParseTuple(args, ":GdkWindow.get_pointer"))
	return NULL;
    gdk_window_get_pointer(GDK_WINDOW(self->obj), &x, &y, &mask);
    return Py_BuildValue("(iii)", x, y, (gint)mask);
}
%%
override gdk_window_get_children
static PyObject *
_wrap_gdk_window_get_children(PyGObject *self, PyObject *args)
{
    GList *children, *tmp;
    PyObject *list;

    if (!PyArg_ParseTuple(args, ":GdkWindow.get_children"))
	return NULL;
    children = gdk_window_get_children(GDK_WINDOW(self->obj));
    list = PyList_New(0);
    for (tmp = children; tmp != NULL; tmp = tmp->next) {
	PyObject *item = pygobject_new((GObject *)tmp->data);

	PyList_Append(list, item);
	Py_DECREF(item);
    }
    g_list_free(children);
    return list;
}
