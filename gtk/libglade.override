/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include <pygobject.h>
#include <glade/glade.h>

%%
import gobject.GObject as PyGObject_Type
import gtk._gtk.Widget as PyGtkWidget_Type
%%
ignore-glob *_get_type
%%
ignore
  glade_init
  glade_provide
  glade_require
  glade_xml_construct
  glade_set_custom_handler
  glade_xml_signal_connect_data
  glade_xml_signal_connect_full
  glade_xml_signal_autoconnect_full
%%
override glade_xml_signal_connect
static void
connect_one(const gchar *handler_name, GtkObject *obj,
            const gchar *signal_name, const gchar *signal_data,
            GtkObject *connect_object, gboolean after, gpointer user_data)
{
    GClosure *closure = NULL;
    PyObject *callback = PyTuple_GetItem((PyObject *)user_data, 0);
    PyObject *extra = PyTuple_GetItem((PyObject *)user_data, 1);

    if (connect_object) {
        PyObject *other;

        other = pygobject_new((GObject *)connect_object);
	closure = pyg_closure_new(callback, extra, other);
    } else {
	closure = pyg_closure_new(callback, extra, NULL);
    }

    g_signal_connect_closure(obj, signal_name, closure, after);
}

static PyObject *
_wrap_glade_xml_signal_connect(PyGObject *self, PyObject *args)
{
    guint len;
    PyObject *first, *callback, *extra_args = NULL, *data;
    gchar *handler_name;

    len = PyTuple_Size(args);
    if (len < 2) {
	PyErr_SetString(PyExc_TypeError,
		"GladeXML.signal_connect requires at least 2 arguments");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "sO:GladeXML.signal_connect", &handler_name,
			  &callback)) {
	Py_DECREF(first);
	return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "second argument must be callable");
	return NULL;
    }
    extra_args = PySequence_GetSlice(args, 2, len);
    if (extra_args == NULL)
	return NULL;
    data = Py_BuildValue("(ON)", callback, extra_args);
    glade_xml_signal_connect_full(GLADE_XML(self->obj), handler_name,
				  connect_one, data);
    Py_DECREF(data);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override glade_xml_signal_autoconnect kwargs
static void
connect_many(const gchar *handler_name, GtkObject *obj,
	     const gchar *signal_name, const gchar *signal_data,
	     GtkObject *connect_object, gboolean after, gpointer user_data)
{
    PyObject *handler_dict = user_data;
    PyObject *tuple;
    GClosure *closure = NULL;

    tuple = PyDict_GetItemString(handler_dict, (gchar *)handler_name);
    if (!tuple) {
	PyErr_Clear();
	g_warning("could not find handler `%s'", handler_name);
	return;
    }

    if (PyTuple_Check(tuple)) {
	PyObject *callback = PyTuple_GetItem(tuple, 0);
	PyObject *extra = PySequence_GetSlice(tuple, 1, PyTuple_Size(tuple));

	if (connect_object) {
	    PyObject *other = pygobject_new((GObject *)connect_object);

	    closure = pyg_closure_new(callback, extra, other);
	} else {
	    closure = pyg_closure_new(callback, extra, NULL);
	}	    
	Py_DECREF(extra);
    } else if (PyCallable_Check(tuple)) {
	if (connect_object) {
	    PyObject *other = pygobject_new((GObject *)connect_object);

	    closure = pyg_closure_new(tuple, NULL, other);
	} else {
	    closure = pyg_closure_new(tuple, NULL, NULL);
	}
    } else {
	g_warning("handler for `%s' not callable or a tuple", handler_name);
	Py_DECREF(tuple);
	return;
    }
    Py_DECREF(tuple);

    g_signal_connect_closure(obj, signal_name, closure, after);
}

static PyObject *
_wrap_glade_xml_signal_autoconnect(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "dict", NULL };
    PyObject *dict;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GladeXML.signal_autoconnect", kwlist,
				     &PyDict_Type, &dict))
	return NULL;
    glade_xml_signal_autoconnect_full(GLADE_XML(self->obj), connect_many,dict);
    Py_INCREF(Py_None);
    return Py_None;
}
