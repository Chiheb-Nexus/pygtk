/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include <pygobject.h>
#include <glade/glade.h>
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#include <libintl.h>

%%
modulename gtk.glade
%%
import gobject.GObject as PyGObject_Type
import gtk._gtk.Widget as PyGtkWidget_Type
%%
ignore-glob *_get_type
%%
ignore
  glade_init
  glade_provide
  glade_require
  glade_xml_construct
  glade_set_custom_handler
  glade_xml_signal_connect_data
  glade_xml_signal_connect_full
  glade_xml_signal_autoconnect_full
%%
override glade_xml_signal_connect
static void
connect_one(const gchar *handler_name, GObject *obj,
            const gchar *signal_name, const gchar *signal_data,
            GObject *connect_object, gboolean after, gpointer user_data)
{
    GClosure *closure = NULL;
    PyObject *callback = PyTuple_GetItem((PyObject *)user_data, 0);
    PyObject *extra = PyTuple_GetItem((PyObject *)user_data, 1);
    PyObject *self;

    if (connect_object) {
        PyObject *other;

        other = pygobject_new(connect_object);
	closure = pyg_closure_new(callback, extra, other);
    } else {
	closure = pyg_closure_new(callback, extra, NULL);
    }

    self = pygobject_new(obj);
    g_signal_connect_closure(obj, signal_name, closure, after);
    pygobject_watch_closure(self, closure);
    Py_DECREF(self);
}

static PyObject *
_wrap_glade_xml_signal_connect(PyGObject *self, PyObject *args)
{
    guint len;
    PyObject *first, *callback, *extra_args = NULL, *data;
    gchar *handler_name;

    len = PyTuple_Size(args);
    if (len < 2) {
	PyErr_SetString(PyExc_TypeError,
		"GladeXML.signal_connect requires at least 2 arguments");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "sO:GladeXML.signal_connect", &handler_name,
			  &callback)) {
	Py_DECREF(first);
	return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
	PyErr_SetString(PyExc_TypeError, "second argument must be callable");
	return NULL;
    }
    extra_args = PySequence_GetSlice(args, 2, len);
    if (extra_args == NULL)
	return NULL;
    data = Py_BuildValue("(ON)", callback, extra_args);
    glade_xml_signal_connect_full(GLADE_XML(self->obj), handler_name,
				  connect_one, data);
    Py_DECREF(data);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override glade_xml_signal_autoconnect kwargs
static void
connect_many(const gchar *handler_name, GObject *obj,
	     const gchar *signal_name, const gchar *signal_data,
	     GObject *connect_object, gboolean after, gpointer user_data)
{
    PyObject *handler_dict = user_data;
    PyObject *tuple, *self;
    GClosure *closure = NULL;

    tuple = PyMapping_GetItemString(handler_dict, (gchar *)handler_name);
    if (!tuple) {
        tuple = PyObject_GetAttrString(handler_dict, (gchar *)handler_name);
        if (!tuple) {
            PyErr_Clear();
            return;
        }
    }
    
    if (PyTuple_Check(tuple)) {
	PyObject *callback = PyTuple_GetItem(tuple, 0);
	PyObject *extra = PySequence_GetSlice(tuple, 1, PyTuple_Size(tuple));
	PyObject *other = NULL;

	if (connect_object)
	    other = pygobject_new((GObject *)connect_object);

	closure = pyg_closure_new(callback, extra, other);
	Py_DECREF(extra);
    } else if (PyCallable_Check(tuple)) {
	PyObject *other = NULL;

	if (connect_object)
	    other = pygobject_new((GObject *)connect_object);

	closure = pyg_closure_new(tuple, NULL, other);
    } else {
	g_warning("handler for `%s' not callable or a tuple", handler_name);
	Py_DECREF(tuple);
	return;
    }

    self = pygobject_new(obj);
    g_signal_connect_closure(obj, signal_name, closure, after);
    pygobject_watch_closure(self, closure);
    Py_DECREF(self);
}

static PyObject *
_wrap_glade_xml_signal_autoconnect(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "dict", NULL };
    PyObject *object;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GladeXML.signal_autoconnect", kwlist,
				     &object))
	return NULL;

    glade_xml_signal_autoconnect_full(GLADE_XML(self->obj),
				      connect_many,
				      object);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override glade_xml_get_widget_prefix kwargs
static PyObject *
_wrap_glade_xml_get_widget_prefix(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;
    GList *ret, *tmp;
    PyObject *py_ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:GladeXML.get_widget_prefix", kwlist,
				     &name))
	return NULL;
    ret = glade_xml_get_widget_prefix(GLADE_XML(self->obj), name);
    py_ret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	GtkWidget *widget = tmp->data;
	PyObject *py_widget = pygobject_new((GObject *)widget);

	if (!py_widget) {
	    g_list_free(ret);
	    Py_DECREF(py_ret);
	    return NULL;
	}
	PyList_Append(py_ret, py_widget);
	Py_DECREF(py_widget);
    }
    g_list_free(ret);
    return py_ret;
}
%%
override glade_bindtextdomain kwargs
static PyObject *
_wrap_glade_bindtextdomain(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "domainname", "dirname", NULL };
    char *domainname, *dirname = NULL, *ret;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s|s:glade.bindtextdomain", kwlist,
				     &domainname, &dirname))
	return NULL;
    ret = bindtextdomain(domainname, dirname);
#ifdef HAVE_BIND_TEXTDOMAIN_CODESET
    bind_textdomain_codeset(domainname, "UTF-8");
#endif
    return PyString_FromString(ret);
}
