/* -*- Mode: C; c-basic-offset: 4 -*-
 * pygtk- Python bindings for the GTK toolkit.
 * Copyright (C) 1998-2003  James Henstridge
 *
 *   atk.override: overrides for the ATK library
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include <atk/atk.h>
#include <atk/atk-enum-types.h>
#include <atk/atknoopobjectfactory.h>
#include <atk/atknoopobject.h>
%%
modulename atk
%%
import gobject.GObject as PyGObject_Type
%%
ignore-glob
  *_get_type
%%
override atk_relation_new kwargs
static int
_wrap_atk_relation_new (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "relationship", NULL };
    AtkObject **targets;
    int relationship, count, i;
    PyObject *py_targets;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oi#:relation_new", kwlist,
				     &py_targets, &relationship))
	return -1;

    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError,
                        "targets argument must be a non-empty sequence");
	return -1;
    }

    if ((count = PySequence_Length(py_targets)) == 0) {
	PyErr_SetString(PyExc_ValueError,
                        "targets argument must be a non-empty sequence");
	return -1;
    }
    targets = g_new(AtkObject *, count);
    for (i = 0; i < count; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item); /* PySequence_GetItem INCREF's */
	if (!pygobject_check(item, &PyAtkObject_Type)) {
	    PyErr_SetString(PyExc_TypeError, "targets argument must be a sequence of AtkObjects.");
	    g_free(targets);
	    return -1;
	}
	    
	targets[i] = (AtkObject *) pygobject_get(item);
    }

    self->obj = (GObject *) atk_relation_new(targets, count, relationship);
    
    g_free(targets);

    pygobject_register_wrapper((PyObject *) self);
    return 0;
}
%%
override atk_component_get_extents kwargs
static PyObject *
_wrap_atk_component_get_extents(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "coord_type", NULL };
    gint x, y, width, height;
    AtkCoordType coord_type;
    PyObject *py_coord_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:atk.Component.get_extents", kwlist,
				     &py_coord_type))
	return NULL;

    if (pyg_enum_get_value(ATK_TYPE_COORD_TYPE, py_coord_type,
                           (gint *)&coord_type))
        return NULL;
    atk_component_get_extents(ATK_COMPONENT(self->obj), &x, &y, &width,
                              &height, coord_type);
    return Py_BuildValue("(iiii)", x, y, width, height);
}
%%
override atk_component_get_position kwargs
static PyObject *
_wrap_atk_component_get_position(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "coord_type", NULL };
    gint x, y;
    AtkCoordType coord_type;
    PyObject *py_coord_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:atk.Component.get_position", kwlist,
				     &py_coord_type))
	return NULL;

    if (pyg_enum_get_value(ATK_TYPE_COORD_TYPE, py_coord_type,
                           (gint *)&coord_type))
        return NULL;
    atk_component_get_position(ATK_COMPONENT(self->obj), &x, &y, coord_type);
    return Py_BuildValue("(ii)", x, y);
}
%%
override atk_component_get_size noargs
static PyObject *
_wrap_atk_component_get_size(PyGObject *self)
{
    gint width, height;

    atk_component_get_size(ATK_COMPONENT(self->obj), &width, &height);
    return Py_BuildValue("(ii)", width, height);
}
%%
override atk_editable_text_set_run_attributes kwargs
static PyObject *
_wrap_atk_editable_text_set_run_attributes(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "attrib_set", "start_offset", "end_offset",
                              NULL };
    gint start, end, n_attrs, i;
    gboolean ret;
    AtkAttributeSet *attrib_set = NULL;
    PyObject *py_attrib_set;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oii:atk.EditableText.set_run_attributes",
                                     kwlist, &py_attrib_set, &start, &end))
	return NULL;

    
    if (!(py_attrib_set = PySequence_Fast(py_attrib_set,
                                          "attrib_set must be a sequence")))
        return NULL;

    n_attrs = PySequence_Fast_GET_SIZE(py_attrib_set);
    for (i = 0; i < n_attrs; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_attrib_set, i);
        AtkAttribute *attr = g_new0(AtkAttribute, 1);
        if (!PyArg_ParseTuple(item, "ss", &attr->name, &attr->value)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "attrib_set items should be (string,string)");
            g_free(attr);
            g_slist_foreach(attrib_set, (GFunc)g_free, NULL);
            g_slist_free(attrib_set);
            Py_DECREF(py_attrib_set);
            return NULL;
        }
        g_slist_append(attrib_set, attr);
    }
    ret = atk_editable_text_set_run_attributes(ATK_EDITABLE_TEXT(self->obj),
                                               attrib_set, start, end);
    
    g_slist_foreach(attrib_set, (GFunc)g_free, NULL);
    g_slist_free(attrib_set);
    Py_DECREF(py_attrib_set);
    return PyBool_FromLong(ret);
}
%%
override atk_editable_text_insert_text kwargs
static PyObject *
_wrap_atk_editable_text_insert_text(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "string", "length", "position",
                              NULL };
    gint length, position;
    const gchar *string;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "sii:atk.EditableText.insert_text",
                                     kwlist, &string, &length, &position))
	return NULL;

    atk_editable_text_insert_text(ATK_EDITABLE_TEXT(self->obj),
                                  string, length, &position);
    return PyInt_FromLong(position);
}
%%
override atk_image_get_image_size noargs
static PyObject *
_wrap_atk_image_get_image_size(PyGObject *self)
{
    gint width, height;

    atk_image_get_image_size(ATK_IMAGE(self->obj), &width, &height);
    return Py_BuildValue("(ii)", width, height);
}
%%
override atk_image_get_image_position kwargs
static PyObject *
_wrap_atk_image_get_image_position(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "coord_type", NULL };
    gint x, y;
    AtkCoordType coord_type;
    PyObject *py_coord_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:atk.Image.get_image_position", kwlist,
				     &py_coord_type))
	return NULL;

    if (pyg_enum_get_value(ATK_TYPE_COORD_TYPE, py_coord_type,
                           (gint *)&coord_type))
        return NULL;
    atk_image_get_image_position(ATK_IMAGE(self->obj), &x, &y, coord_type);
    return Py_BuildValue("(ii)", x, y);
}
%%
override atk_relation_get_target noargs
static PyObject *
_wrap_atk_relation_get_target (PyGObject *self)
{
    GPtrArray * trgtarray;
    AtkObject **targets;
    int i;
    PyObject *py_targets;
    
    trgtarray = atk_relation_get_target(ATK_RELATION(self->obj));
    py_targets = PyList_New(trgtarray->len);
    targets = (AtkObject**)trgtarray->pdata;
    for (i = 0; i < trgtarray->len; i++) {
	PyObject *item = pygobject_new((GObject*)targets[i]);
	PyList_SetItem(py_targets, i, item);
    }
    return py_targets;
}
%%
override atk_state_set_add_states kwargs
static PyObject *
_wrap_atk_state_set_add_states(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "types", NULL };
    AtkStateType *types;
    gint count, i;
    PyObject *py_types;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:atk.StateSet.add_states",
                                     kwlist, &py_types))
	return NULL;

    if (!(py_types = PySequence_Fast(py_types, "types must be a sequence")))
        return NULL;

    count = PySequence_Fast_GET_SIZE(py_types);
    types = g_new0(AtkStateType, count);
    for (i = 0; i < count; i++) {
        if (pyg_enum_get_value(ATK_TYPE_STATE_TYPE,
                               PySequence_Fast_GET_ITEM(py_types, i),
                               (gpointer)&types[i]))
            return NULL;
    }
    atk_state_set_add_states(ATK_STATE_SET(self->obj), types, count);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override atk_state_set_contains_states kwargs
static PyObject *
_wrap_atk_state_set_contains_states(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "types", NULL };
    AtkStateType *types;
    gint count, i;
    gboolean ret;
    PyObject *py_types, *py_ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:atk.StateSet.contains_states",
                                     kwlist, &py_types))
	return NULL;

    if (!(py_types = PySequence_Fast(py_types, "types must be a sequence")))
        return NULL;

    count = PySequence_Fast_GET_SIZE(py_types);
    types = g_new0(AtkStateType, count);
    for (i = 0; i < count; i++) {
        if (pyg_enum_get_value(ATK_TYPE_STATE_TYPE,
                               PySequence_Fast_GET_ITEM(py_types, i),
                               (gpointer)&types[i]))
            return NULL;
    }
    ret = atk_state_set_contains_states(ATK_STATE_SET(self->obj), types,
                                        count);
    if (ret)
        py_ret = Py_True;
    else
        py_ret = Py_False;
    Py_INCREF(py_ret);
    return py_ret;
}
%%
override atk_table_get_selected_columns noargs
static PyObject *
_wrap_atk_table_get_selected_columns(PyGObject *self)
{
    gint *selected, ret, i;
    PyObject *py_selected;

    ret = atk_table_get_selected_columns(ATK_TABLE(self->obj), &selected);
    py_selected = PyTuple_New(ret);
    for (i = 0; i < ret; i++) {
        PyTuple_SetItem(py_selected, i, PyInt_FromLong(selected[i]));
    }

    g_free(selected);
    return py_selected;
}
%%
override atk_table_get_selected_rows noargs
static PyObject *
_wrap_atk_table_get_selected_rows(PyGObject *self)
{
    gint *selected, ret, i;
    PyObject *py_selected;

    ret = atk_table_get_selected_rows(ATK_TABLE(self->obj), &selected);
    py_selected = PyTuple_New(ret);
    for (i = 0; i < ret; i++) {
        PyTuple_SetItem(py_selected, i, PyInt_FromLong(selected[i]));
    }

    g_free(selected);
    return py_selected;
}
